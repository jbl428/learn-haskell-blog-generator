# IO 다루기

이전 장에서는 텍스트 문자열을 하스켈 표현으로 변환하는 파서를 만들었고,
HTML 코드를 쉽게 작성할 수 있는 EDSL을 만들었습니다.
하지만 이 프로그램은 다른 사용자에게는 아직 유용하지 않습니다.
왜냐하면 이 기능을 어떤 사용자 인터페이스로도 제공하지 않기 때문입니다.

이번에는 사용자의 입력을 받아서 HTML로 변환하는 프로그램을 만들고자 합니다.
이런 인터페이스를 설계하는 방법은 여러 가지가 있습니다. 예를 들어:

- **표준 입력*으로부터 텍스트를 읽어서 *표준 출력*으로 HTML을 출력합니다.
- *명령줄 인자*로 두 개의 파일 이름을 받아서 첫 번째 파일의 내용을 읽어서 두 번째 파일에 출력합니다.
- 더욱 편리한 명령줄 인터페이스를 제공하고 파일 이름 앞에 플래그를 붙여서 어떤 파일인지 알려줍니다.
- 화려한 GUI 인터페이스를 제공합니다.
- 위의 모든 것을 조합합니다.

우선 다음과 같은 인터페이스부터 시작해 보겠습니다:

1. 사용자가 인자 없이 프로그램을 호출하면 표준 입력에서 읽고 표준 출력으로 출력합니다.
2. 사용자가 두 개의 인자를 주면 첫 번째 인자는 입력 파일 이름이고 두 번째 인자는 출력 파일 이름입니다.
3. 만약 출력 파일이 이미 존재한다면 덮어쓸지 물어봅니다.
4. 그 외의 경우에는 사용법을 설명하는 메시지를 출력합니다.

이후 장에서는, 라이브러리를 사용해서 더 화려한 명령줄 인터페이스를 만들고,
단일 파일뿐만 아니라 디렉토리 전체를 처리하는 방법을 배울 것입니다.

하지만 먼저, 하스켈에서 I/O를 어떻게 다루는지, 특별한 점이 무엇인지, 다른 프로그래밍 언어와 어떻게 다른지 알아보겠습니다.

## 순수 함수형 언어

하스켈은 원래 **비엄격적 의미론(non-strict semantics)**을 가진 **오픈 표준(open standard)** 함수형 언어로 설계되었습니다.
이는 미래의 함수형 언어 설계 연구를 위한 통합 언어로 사용하기 위해 만들어졌습니다.

GHC에서는, 비엄격적 의미론을 구현하기 위해 _지연 평가(lazy evaluation)_ 전략을 사용합니다.
(지연 평가에 대해서는 [이전 장](../04-markup/02-parsing-01.md#laziness)에서 다루었습니다.)

비엄격적 의미론을 위한 요구사항을 충족하고자 한다면 다음과 같은 고민을 해야 합니다:

- 어떻게 하면 단순히 표현식을 평가하는 것 이상의 일을 할 수 있는 언어를 설계할 수 있을지
- 어떻게 하면 외부 세계와 상호작용을 모델링할 수 있을지
- 어떻게 하면 I/O를 다룰지

지연평가 전략을 가진 언어에서 I/O 연산을 한다는 것은, 프로그램이 점점 커질 때, 평가 순서를 파악하기가 더욱 어려워진다는 것을 의미합니다.
다음과 같은 가상의 코드 예제를 생각해 봅시다
(실제로는 하스켈에서는 타입 에러가 발생합니다. 그 이유는 곧 알아보겠습니다):

```haskell
addWithInput :: Int -> Int
addWithInput n = readIntFromStdin + n

main =
  let
    result1 = addWithInput 1
    result2 = addWithInput 2
  in
    print (result2 - result1)
```

This hypothetical program will read 2 integers from the standard input,
and then will subtract the second one (+2) from the first one (+1),
or so we would expect if this was a strict language. In a strict language
we expect the order of operations to happen from the top-down.

But in a lazy language we don't evaluate an expression until
it is needed, and so neither `result1` nor `result2` are evaluated
until we wish to print the result of subtracting one from the other.
And then when we try to evaluate `-`, it evaluates the two arguments
from left to right, so we first evaluate `result2`.

Evaluating `result2`, with substitution, means to replace occurrences of `n`
with the input `2`, and then evaluate the top level function (`+`), which is a
primitive function. We then evaluate its arguments, `readIntFromStdin`
and then `n`; at this point _we are reading the first integer from the stdin_.

After calculating the result, we can move to evaluate `result1`, which
_will read the second integer from stdin_. This is the
complete opposite of what we wanted!

Issues like these make lazy evaluation hard to work with in the presence of
**side effects** - when the evaluation of an expression _can affect or be affected
by the outside world_, this includes reading/writing from mutable memory
or performing I/O operations.

We call functions that have side-effects, such as `addWithInput`, **impure functions**.
And an unfortunate consequence of impure functions is that
**they can return different results even when they take the same input**.

The presence of impure functions makes it harder for us to reason about lazy evaluation,
and also messes up our ability to use **equational reasoning** to understand programs.

Therefore, in Haskell, it was decided to only allow **pure** functions and expressions - ones that
have **no side effects**. Pure functions will _always_ return the same output (given the same input)
and **evaluating pure expressions is deterministic**.

But now, how can we do I/O operations? There are many possible solutions

For Haskell it was decided to design an interface
with an accompanied type called `IO`. `IO`'s interface will force a distinction
from non-I/O expressions, and will also require that in order to _combine_
multiple `IO` operations, we will have to **specify the order the operations**.

## IO

`IO` is an opaque type, like our `Html` type in which we hide its internal
representation from the user behind an interface. But in this case `IO` is a
built-in type that is hidden by the Haskell language rather than a module.

Similar to `Maybe`, `IO` has a payload type which represents the
result of an `IO` operation.
When there isn't a meaningful result, we use the unit type,
`()` (which only has one value: `()`) to represent that.

Here are a few `IO` operations and functions that return `IO` operations:

```haskell
putStrLn :: String -> IO ()

getLine :: IO String

getArgs :: IO [String]

lookupEnv :: String -> IO (Maybe String)

writeFile :: FilePath -> String -> IO ()
```

<!-- You can find more useful IO functions and operations in the
[System.IO](https://hackage.haskell.org/package/base-4.16.4.0/docs/System-IO.html) module.
which is shipped with `base`. -->

Notice that each function returns an `IO <something>`, but what does that mean?

The meaning behind `IO a` is that it is a _description of a program (or subroutine)
that when executed will produce some value of type `a`, and may do some I/O effects
during execution_.

Executing an `IO a` is different from evaluating it.
Evaluating an `IO a` expression is pure - the **evaluation** will always reduce to
the same **description** of a program. This helps us keep purity and equational reasoning!

The Haskell runtime will _execute_ the entry point to the program
(the expression `main`, that must have the type `IO ()`) in order for our IO operation
to also run - it has to be _combined into_ the `main` expression - let's see what that means.

## Combining IO expressions

Just like our `Html.Structure` type, the IO interface provides **combinators** for composing
small `IO` operations into bigger ones. This interface also ensures that the order
of operations is well defined!

Note that, just like the `<>` we've defined for `Html.Structure`, the combinators for `IO`
are implemented as **type-class instances** rather than specialized variants
(for example our `append_` function was a specialized version of `<>` tailored only
for `Structure`).

In this section I will introduce specialized type signatures rather than generalized ones,
because I think it'll be easier to digest, but we'll talk about the generalized versions
later.

### >>=

Our first combinator is `>>=` (pronounced bind), and is the most useful of the bunch:

```haskell
(>>=) :: IO a -> (a -> IO b) -> IO b
```

This combinator takes two arguments, the first is an IO operation, and the second is
a function that takes as input _the result of the first IO operation_ and returns
a new `IO b` which is the final result.

Here are a few examples using the functions we described above:

1. Echo

   ```
   getLine >>= (\line -> putStrLn line)
   ```

   We are reading a line from the standard input on the left of `>>=`,
   we receive the input to the right of `>>=` as an argument to the lambda function,
   and then write it to the standard output in the body of the lambda function.
   `>>=`'s role here is to **pass the result of the IO operation
   on the left to the function returning an IO operation on the right**.

   Notice how `>>=` _defines an order of operations - from left to right_.

   The type of each sub expression here is:

   ```haskell
   getLine :: IO String

   putStrLn :: String -> IO ()

   (>>=) :: IO String -> (String -> IO ()) -> IO ()

   line :: String
   ```

   - Question: what is the type of the whole expression? <details><summary>Answer</summary>IO ()</details>

   Also note that this example can be written in a more concise manner
   in point free style `getLine >>= putStrLn`.

2. Appending two inputs

   ```
   getLine >>= (\honorific -> getLine >>= (\name -> putStrLn ("Hello " ++ honorific ++ " " ++ name)))
   ```

   This subroutine combines multiple operations together, it reads two lines from
   the standard input and prints a greeting.
   Note that:

   - Using `>>=` defines the order of operation from left to right
   - Because of the scoping rules in Haskell, `honorific` will be in scope
     in the body of the function for which it is its input, including the most inner function

   This is a bit hard to read, but we can remove the parenthesis and add indentation to make it a bit easier to read:

   ```
   getLine >>= \honorific ->
     getLine >>= \name ->
       putStrLn ("Hello " ++ honorific ++ " " ++ name)
   ```

Let's see a few more combinators!

### \*> and >>

```haskell
(*>) :: IO a -> IO b -> IO b
(>>) :: IO a -> IO b -> IO b
```

`*>` and `>>` have the same type signature for `IO` and mean the same thing.
In fact, `*>` is a slightly more generalized version of `>>` and can always
be used instead of `>>`, which only still exists to avoid breaking backward
compatibility.

`*>` for `IO` means run the first IO operation, discard the result
then run the second operation. It can be implemented using `>>=`:

```
a *> b = a >>= \_ -> b
```

This combinator is useful when we want to run several `IO` operations one after
the other that might not return anything meaningful, such as `putStrLn`:

```
putStrLn "hello" *> putStrLn "world"
```

### pure and return

```haskell
pure :: a -> IO a
```

like `*>` and `>>`, `pure` is a more general version of `return`. `pure` also has the
advantage of not having a resemblance to an unrelated keyword in other languages.

Remember that we said `IO a` is a description of a program
that when executed will produce some value of type `a` and may do some I/O effects
during execution?

With `pure`, we can build an `IO a` that does no I/O, and will produce a
specific value of type `a`, the one we supply to `pure`!

This function is useful when we want to do some uneffectful computation that depends on `IO`.

For example:

```haskell
confirm :: IO Bool
confirm =
  putStrLn "Are you sure? (y/n)" *>
    getLine >>= \answer ->
      case answer of
        "y" -> pure True
        "n" -> pure False
        _ ->
          putStrLn "Invalid response. use y or n" *>
            confirm
```

Trying to return just `True` or `False` here wouldn't work because of the
type of `>>=`:

```haskell
(>>=) :: IO a -> (a -> IO b) -> IO b
```

The right side of `>>=` in our code example (`\answer -> case ...`) must
be of type `String -> IO Bool`. This is because:

1. `getLine :: IO String`, so the `a` in the type signature of `>>=`
   should be the same as `String` in this instance, and
2. `confirm :: IO Bool`, so `b` should be `Bool`

### fmap and <$>

```haskell
fmap :: (a -> b) -> IO a -> IO b
```

`<$>` is the infix version of `fmap`. Use it at your discretion.

What if we want a function that reads a line from stdin
and returns it with `!` at the end? We could use a combination
of `>>=` and `pure`:

```
getLine >>= \line -> pure (line ++ "!")
```

The pattern is unified to the `fmap` function:

```
fmap (\line -> line ++ "!") getLine
```

`fmap` applies a function to the value to be returned
from the `IO` operation, also known as "mapping" over it.

(By the way, Have you noticed the similarities between `fmap` and `map :: (a -> b) -> [a] -> [b]`?)

### Summary

Here's a list of `IO` combinators we ran into:

```haskell
-- chaining IO operations: passing the *result* of the left IO operation
-- as an argument to the function on the right.
-- Pronounced "bind".
(>>=) :: IO a -> (a -> IO b) -> IO b

-- sequence two IO operations, discarding the payload of the first.
(*>) :: IO a -> IO b -> IO b

-- "lift" a value into IO context, does not add any I/O effects.
pure :: a -> IO a

-- "map" (or apply a function) over the payload value of an IO operation.
fmap :: (a -> b) -> IO a -> IO b
```

## IO is first class

The beauty of `IO` is that it's a completely first-class construct in the language,
and is not really different from `Maybe`, `Either` or `Structure`. We can pass it to
functions, put it in a container, etc. Remember that it represents a description
of a program, and without combining it into `main` in some way won't actually
_do_ anything. It is just a value!

Here's an example of a function that takes IO actions as input:

```haskell
whenIO :: IO Bool -> IO () -> IO ()
whenIO cond action =
  cond >>= \result ->
    if result
      then action
      else pure ()
```

And how it can be used:

```haskell
main :: IO ()
main =
  putStrLn "This program will tell you a secret" *>
    whenIO confirm (putStrLn "IO is actually pretty awesome") *>
      putStrLn "Bye"
```

Notice how `putStrLn "IO is actually pretty awesome"` isn't executed
right away, but only if it is what `whenIO` returns, and in turn is _combined_
with `*>` as part of the `main` expression.

## Getting out of IO?

What we've seen above has great consequences to the Haskell language.
In our `Html` type, we had a function `render :: Html -> String`
that could turn an `Html` to a string value.

In Haskell, **there is no way** to implement a function such as `execute :: IO a -> a`
that preserves purity and equational reasoning!

Also, `IO` is _opaque_. It does not let us examine it. So we are really bound
to what the Haskell API for `IO` allows us to do.

This means that **we need to think about using IO differently**!

In Haskell, once we get into `IO`, there is no getting out.
The only thing we can do is to build bigger IO computations by _combining_
it with more IO computations.

We also can't use `IO a` in place of an `a`. For example,
we can't write `getLine ++ "!"` because `++` expects both
sides to be `String`, but `getLine`'s type is `IO String`. The types do not match!
We have to use `fmap` and the return type must be `IO String`, like we've seen before.

In Haskell we like to keep `IO` usage minimal, and we like to push it to the edges
of the program. This pattern is often called _Functional core, imperative shell_.

## Functional core, imperative shell

In our blog generator program, we want to read a file, parse it, convert it to HTML,
and then print the result to the console.

In many programming languages, we might interleave reading from the file with parsing,
and writing to the file with the HTML conversion. But we don't mix these here.
Parsing operates on a `String` value rather than some file handle,
and `Html` is being converted to a `String` rather than being written to the screen directly.

This approach of separating `IO` and pushing it to the edge of the program gives us
a lot of flexibility. These functions without `IO` are easier to test and examine
(because they are guaranteed to have deterministic evaluation!),
and they are more modular and can work in many contexts (reading from stdin,
reading from network socket, writing to an HTTP connection, and more).

This pattern is often a good approach for building Haskell programs, especially
batch programs.

## Building a blog generator

We'd like to start building a blog generator, and we want to have the following
interface:

1. If the user calls the program without arguments, we will read from
   the standard input, and write to the standard output
2. If the user calls the program with two arguments, the first one
   will be the input file name, and the second one
   will be the output file name
3. If the output file already exists, we'll ask the user if they want
   to overwrite the file
4. On any other kind of input, we'll print a generic message explaining
   the proper usage

We are going to need a few functions:

```haskell
getArgs :: IO [String] -- Get the program arguments

getContents :: IO String -- Read all of the content from stdin

readFile :: FilePath -> IO String -- Read all of the content from a file

writeFile :: FilePath -> String -> IO () -- Write a string into a file

doesFileExist :: FilePath -> IO Bool -- Checks whether a file exists
```

And the following imports:

```haskell
import System.Directory (doesFileExist)
import System.Environment (getArgs)
```

We don't need to add the following import because `Prelude` already imports
these functions for us:

```haskell
-- imported by Prelude
import System.IO (getContents, readFile, writeFile)
```

---

1. Implement a function `process :: Title -> String -> String` which will parse
   a document to markup, convert it to HTML, and then render the HTML to a string.

<details><summary>Answer</summary>

```haskell
process :: Html.Title -> String -> String
process title = Html.render . convert title . Markup.parse
```

</details>

2. Try implementing the "imperative shell" for our blog generator program.
   Start with `main`, pattern match on the result of `getArgs`, and decide what to
   do. Look back at the examples above for inspiration.

<details><summary>Answer</summary>

```haskell
-- Main.hs
module Main where

import qualified Markup
import qualified Html
import Convert (convert)

import System.Directory (doesFileExist)
import System.Environment (getArgs)

main :: IO ()
main =
  getArgs >>= \args ->
    case args of
      -- No program arguments: reading from stdin and writing to stdout
      [] ->
        getContents >>= \content ->
          putStrLn (process "Empty title" content)

      -- With input and output file paths as program arguments
      [input, output] ->
        readFile input >>= \content ->
          doesFileExist output >>= \exists ->
            let
              writeResult = writeFile output (process input content)
            in
              if exists
                then whenIO confirm writeResult
                else writeResult

      -- Any other kind of program arguments
      _ ->
        putStrLn "Usage: runghc Main.hs [-- <input-file> <output-file>]"

process :: Html.Title -> String -> String
process title = Html.render . convert title . Markup.parse

confirm :: IO Bool
confirm =
  putStrLn "Are you sure? (y/n)" *>
    getLine >>= \answer ->
      case answer of
        "y" -> pure True
        "n" -> pure False
        _ -> putStrLn "Invalid response. use y or n" *>
          confirm

whenIO :: IO Bool -> IO () -> IO ()
whenIO cond action =
  cond >>= \result ->
    if result
      then action
      else pure ()
```

</details>

---

## Do notation

While using `>>=` to chain `IO` actions is manageable, Haskell provides
an even more convenient syntactic sugar called _do notation_
which emulates imperative programming.

A _do block_ starts with the `do` keyword, and continues with one or more
"statements" which can be one of the following:

1. An expression of type `IO ()`, such as:
   - `putStrLn "Hello"`
   - `if True then putStrLn "Yes" else putStrLn "No"`
2. A let block, such as
   - `let x = 1`
   - or multiple let declarations:
     ```haskell
     let
       x = 1
       y = 2
     ```
     Note that we do not write the `in` here.
3. A binding `<variable> <- <expresion>`, such as
   ```haskell
   line <- getLine
   ```

And the last "statement" must be an expression of type `IO <something>` -
this will be the result type of the do block.

These constructs are desugared (translated) by the Haskell compiler to:

1. `<expression> *>`,
2. `let ... in` and
3. `<expression> >>= \<variable>`

respectively.

For example:

```haskell
greeting :: IO ()
greeting = do
  putStrLn "Tell me your name."
  let greet name = "Hello, " ++ name ++ "!"
  name <- getLine
  putStrLn (greet name)
```

Is just syntactic sugar for:

```haskell
greeting :: IO ()
greeting =
  putStrLn "Tell me your name." *>
    let
      greet name = "Hello, " ++ name ++ "!"
    in
      getLine >>= \name ->
        putStrLn (greet name)
```

It's important to note the difference between `let` and `<-` (bind).
`let` is used to give a new name to an expression which will be in scope
for subsequent lines, and `<-` is used to bind the result `a` in an `IO a`
action to a new name which will be in scope for subsequent lines.

[//]: # "<table>"
[//]: # "  <tr>"
[//]: # "    <th>code</th>"
[//]: # "    <th>operator</th>"
[//]: # "    <th>type of the left side</th>"
[//]: # "    <th>type of the right side</th>"
[//]: # "    <th>comment</th>"
[//]: # "  </tr>"
[//]: # "  <tr>"
[//]: # '    <td><pre><pre>let gretting = "hello"</pre></pre></td>'
[//]: # "    <td><pre>=</pre></td>"
[//]: # "    <td><pre>String</pre></td>"
[//]: # "    <td><pre>String</pre></td>"
[//]: # "    <td>Both sides are interchangeable</td>"
[//]: # "  </tr>"
[//]: # "  <tr>"
[//]: # "    <td><pre>let mygetline = getLine</pre></td>"
[//]: # "    <td><pre>=</pre></td>"
[//]: # "    <td><pre>IO String</pre></td>"
[//]: # "    <td><pre>IO String</pre></td>"
[//]: # "    <td>We just create a new name for <code>getLine</code></td>"
[//]: # "  </tr>"
[//]: # "  <tr>"
[//]: # "    <td><pre>name <- getLine</pre></td>"
[//]: # "    <td><pre><-</pre></td>"
[//]: # "    <td><pre>String</pre></td>"
[//]: # "    <td><pre>IO String</pre></td>"
[//]: # "    <td>Technically <code><-</code> is not an operator, but just a syntactic sugar for <code>>>=</code> + lambda, where we bind the result of the computation to a variable</td>"
[//]: # "  </tr>"
[//]: # "</table>"

Do notation is very very common and is often preferable to using `>>=` directly.

---

1. Exercise: Translate the examples in this chapter to _do notation_.

2. Exercise: Translate our glue code for the blog generator to _do notation_.

<details><summary>Solution</summary>

```haskell
-- Main.hs
module Main where

import qualified Markup
import qualified Html
import Convert (convert)

import System.Directory (doesFileExist)
import System.Environment (getArgs)

main :: IO ()
main = do
  args <- getArgs
  case args of
    -- No program arguments: reading from stdin and writing to stdout
    [] -> do
      content <- getContents
      putStrLn (process "Empty title" content)

    -- With input and output file paths as program arguments
    [input, output] -> do
      content <- readFile input
      exists <- doesFileExist output
      let
        writeResult = writeFile output (process input content)
      if exists
        then whenIO confirm writeResult
        else writeResult

    -- Any other kind of program arguments
    _ ->
      putStrLn "Usage: runghc Main.hs [-- <input-file> <output-file>]"

process :: Html.Title -> String -> String
process title = Html.render . convert title . Markup.parse

confirm :: IO Bool
confirm = do
  putStrLn "Are you sure? (y/n)"
  answer <- getLine
  case answer of
    "y" -> pure True
    "n" -> pure False
    _ -> do
      putStrLn "Invalid response. use y or n"
      confirm

whenIO :: IO Bool -> IO () -> IO ()
whenIO cond action = do
  result <- cond
  if result
    then action
    else pure ()
```

</details>

---

## Summary

In this chapter we discussed what "purely functional" means,
where the initial motivation for being purely functional comes from,
and how Haskell's I/O interface allows us to create descriptions of programs
without breaking purity.

We have also achieved a major milestone. With this chapter, we have implemented
enough pieces to finally run our program on a single document
and get an HTML rendered result!

However, our command-line interface is still sub-par. We want to render a blog
with multiple articles, create an index page, and more. We still have more to do
to be able to call our program a blog generator.

Let's keep going!

> You can view the git commit of
> [the changes we've made](https://github.com/soupi/learn-haskell-blog-generator/commit/908e7173cf32de5ce8507e43a1fb9124fc5d63f4)
> and the [code up until now](https://github.com/soupi/learn-haskell-blog-generator/tree/908e7173cf32de5ce8507e43a1fb9124fc5d63f4).
