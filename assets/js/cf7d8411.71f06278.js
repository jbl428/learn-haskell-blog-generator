"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[554],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>k});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=p(t),d=r,k=c["".concat(s,".").concat(d)]||c[d]||m[d]||i;return t?a.createElement(k,l(l({ref:n},u),{},{components:t})):a.createElement(k,l({ref:n},u))}));function k(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[c]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9343:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const i={},l="\ub9c8\ud06c\uc5c5 \ud30c\uc2f1\ud558\uae30 02 (\ud328\ud134 \ub9e4\uce6d)",o={unversionedId:"markup/parsing-02",id:"markup/parsing-02",title:"\ub9c8\ud06c\uc5c5 \ud30c\uc2f1\ud558\uae30 02 (\ud328\ud134 \ub9e4\uce6d)",description:"Maybe",source:"@site/docs/04-markup/04-parsing-02.md",sourceDirName:"04-markup",slug:"/markup/parsing-02",permalink:"/learn-haskell-blog-generator/markup/parsing-02",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/04-markup/04-parsing-02.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ud30c\uc2f1 \uacb0\uacfc \ubcf4\uc5ec\uc8fc\uae30 (\ud0c0\uc785 \ud074\ub798\uc2a4)",permalink:"/learn-haskell-blog-generator/markup/displaying-results"},next:{title:"Gluing things together",permalink:"/learn-haskell-blog-generator/glue/"}},s={},p=[{value:"Maybe",id:"maybe",level:2},{value:"\ud328\ud134 \ub9e4\uce6d",id:"\ud328\ud134-\ub9e4\uce6d",level:2},{value:"\uc5f0\uacb0 \ub9ac\uc2a4\ud2b8 \ud328\ud134 \ub9e4\uce6d",id:"\uc5f0\uacb0-\ub9ac\uc2a4\ud2b8-\ud328\ud134-\ub9e4\uce6d",level:3},{value:"Parsing with rich context",id:"parsing-with-rich-context",level:2},{value:"How do we know our parser works correctly?",id:"how-do-we-know-our-parser-works-correctly",level:3}],u={toc:p},c="wrapper";function m(e){let{components:n,...t}=e;return(0,r.kt)(c,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"\ub9c8\ud06c\uc5c5-\ud30c\uc2f1\ud558\uae30-02-\ud328\ud134-\ub9e4\uce6d"},"\ub9c8\ud06c\uc5c5 \ud30c\uc2f1\ud558\uae30 02 (\ud328\ud134 \ub9e4\uce6d)"),(0,r.kt)("h2",{id:"maybe"},"Maybe"),(0,r.kt)("p",null,"\uc774\uc804\uc5d0 \ubd80\ubd84 \ud568\uc218\ub97c \ub9cc\ub4e4\uc9c0 \uc54a\ub294 \ubc29\ubc95 \uc911 \ud558\ub098\ub85c, ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe"),"\ub97c \uc0ac\uc6a9\ud558\uc5ec \uacb0\uacfc\uac00 \uc5c6\ub294 \uacbd\uc6b0\ub97c \ud45c\ud604\ud558\ub294 \uac83\uc744 \uc0b4\ud3b4 \ubcf4\uc558\uc2b5\ub2c8\ub2e4."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Maybe a\n  = Nothing\n  | Just a\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Maybe"),"\ub294 \ud45c\uc900 \ub77c\uc774\ube0c\ub7ec\ub9ac(",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base"},"base"),")\uc5d0\uc11c \uc81c\uacf5\ud558\ub294 \ub370\uc774\ud130 \ud0c0\uc785\uc73c\ub85c,\n\uac12\uc758 \ubd80\uc7ac\ub97c \uc758\ubbf8\ud558\ub294 \ucd94\uac00\uc801\uc778 \uac12\uc744 \ud0c0\uc785\uc5d0 \ucd94\uac00\ud558\ub294 \ub370 \uc0ac\uc6a9\ub429\ub2c8\ub2e4.\n\uc608\ub97c \ub4e4\uc5b4, ",(0,r.kt)("inlineCode",{parentName:"p"},"Just")," \uc0dd\uc131\uc790\ub294 \uc77c\ubc18\uc801\uc778 \ubd88\ub9ac\uc5b8 \uac12\uc774 \uc788\uc74c\uc744 \ub098\ud0c0\ub0b4\uace0, (",(0,r.kt)("inlineCode",{parentName:"p"},"Just True"),"\uc640 ",(0,r.kt)("inlineCode",{parentName:"p"},"Just False"),")\n",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing")," \uc0dd\uc131\uc790\ub294 \ubd88\ub9ac\uc5b8 \uac12\uc774 \uc5c6\uc74c\uc744 \ub098\ud0c0\ub0c5\ub2c8\ub2e4."),(0,r.kt)("p",null,"\uc774\ub97c \ud1b5\ud574 \uc8fc\uc5b4\uc9c4 \ub9ac\uc2a4\ud2b8\uc758 \uccab \ubc88\uc9f8 \uc694\uc18c\ub97c \ubc18\ud658\ud558\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"head")," \ud568\uc218\ub97c \ubd80\ubd84 \ud568\uc218\ub85c \ub9cc\ub4e4\uc9c0 \uc54a\uace0 \ud56d\uc0c1 \uac12\uc744 \ubc18\ud658\ud558\uac8c \ub9cc\ub4e4 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"safeHead :: [a] -> Maybe a\n")),(0,r.kt)("p",null,"\uc704 \ubc29\uc2dd\uc740 \ub9ac\uc2a4\ud2b8\uac00 \ube44\uc5b4\uc788\ub2e4\uba74, ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing"),"\uc744 \ubc18\ud658\ud558\uace0, \ube44\uc5b4\uc788\uc9c0 \uc54a\ub2e4\uba74 ",(0,r.kt)("inlineCode",{parentName:"p"},"Just <\uccab \ubc88\uc9f8 \uc694\uc18c>"),"\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4.\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Maybe.html"},"Data.Maybe")," \ubaa8\ub4c8\uc758\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Maybe.html#v:listToMaybe"},"listToMaybe")," \ud568\uc218\uac00 \uc774 \uc5ed\ud560\uc744 \ud569\ub2c8\ub2e4."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Maybe <\ubb34\uc5b8\uac00>")," \ub610\ub294 \ub2e4\ub978 ",(0,r.kt)("inlineCode",{parentName:"p"},"data"),"\ub85c \uc0dd\uc131\ub41c \ud0c0\uc785\uc758 \uac12\uc744 ",(0,r.kt)("em",{parentName:"p"},"\uaebc\ub0b4\uae30"),"\uc704\ud574, \ud328\ud134 \ub9e4\uce6d\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("h2",{id:"\ud328\ud134-\ub9e4\uce6d"},"\ud328\ud134 \ub9e4\uce6d"),(0,r.kt)("p",null,"\uc774\uc804\uc5d0 \ud328\ud134 \ub9e4\uce6d\uc5d0 \ub300\ud574 \uc774\ubbf8 \uba87 \ubc88 \ubcf4\uc558\uc2b5\ub2c8\ub2e4.\n\ud328\ud134 \ub9e4\uce6d\uc740 \ud558\uc2a4\ucf08\uc758 \ub9e4\uc6b0 \uc720\uc6a9\ud55c \uae30\ub2a5\uc73c\ub85c, \uc8fc\ub85c \ub450 \uac00\uc9c0 \uc8fc\uc694 \ubaa9\uc801\uc73c\ub85c \uc0ac\uc6a9\ud569\ub2c8\ub2e4:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"\ubcf5\uc7a1\ud55c \uac12\uc744 \ubd84\ud574"),(0,r.kt)("li",{parentName:"ol"},"\ud750\ub984 \uc81c\uc5b4")),(0,r.kt)("p",null,"\uc774\uc804 ",(0,r.kt)("a",{parentName:"p",href:"/learn-haskell-blog-generator/html/safer-construction#using-newtypes"},"newtype"),"\uc744 \uc18c\uac1c\ud560 \ub54c,\n",(0,r.kt)("strong",{parentName:"p"},"case \ud45c\ud604\uc2dd"),"\uacfc ",(0,r.kt)("strong",{parentName:"p"},"\ud568\uc218 \uc815\uc758"),"\ub97c \uc0ac\uc6a9\ud558\uc5ec ",(0,r.kt)("inlineCode",{parentName:"p"},"newtype"),"\uc744 \ubd84\ud574\ud558\ub294 \ubc29\ubc95\uc744 \uc0b4\ud3b4\ubcf4\uc558\uc2b5\ub2c8\ub2e4.\n",(0,r.kt)("inlineCode",{parentName:"p"},"data")," \ud0c0\uc785\uc5d0 \ub300\ud574\uc11c\ub3c4 \uac19\uc740 \ubc29\ubc95\uc744 \uc801\uc6a9\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- | \uc0c9\uc0c1\uc744 \ud45c\ud604\ud558\ub294 \ub370\uc774\ud130 \ud0c0\uc785\ndata Color\n  = RGB Word8 Word8 Word8\n\ngetBluePart :: Color -> Word8\ngetBluePart color =\n  case color of\n    RGB _ _ blue -> blue\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getBluePart")," \ud568\uc218\ub294 \uc8fc\uc5b4\uc9c4 \ud569\uc131 \uac12\uc744 \ubd84\ud574\ud558\uc5ec RGB\uc5d0\uc11c \uc138 \ubc88\uc9f8 \uc694\uc18c\uc778 \ud30c\ub780\uc0c9 \uac12\uc744 \ucd94\ucd9c\ud569\ub2c8\ub2e4."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"blue"),"\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"color"),"\uc758 \uc138 \ubc88\uc9f8 \uc694\uc18c\uc5d0 \uc900 \uc774\ub984\uc73c\ub85c \uc624\ub978\ucabd \ud654\uc0b4\ud45c \ub2e4\uc74c\uc5d0 \uc624\ub294 \ud328\ud134\uc5d0 \ubc14\uc778\ub529\ub429\ub2c8\ub2e4.\n\uc774\ub294 \ud568\uc218 \uc778\uc218\uc640 \uc720\uc0ac\ud569\ub2c8\ub2e4.\n\ub610\ud55c ",(0,r.kt)("inlineCode",{parentName:"p"},"_"),"\ub294 \uc774\ub984\uc744 \ubc14\uc778\ub529\ud558\uc9c0 \uc54a\uace0 \ubaa8\ub4e0 \uac12\uacfc \uc77c\uce58\ud558\ub294 \ud328\ud134\uc785\ub2c8\ub2e4."),(0,r.kt)("p",null,"\uac12\uc744 \ub450 \uac1c \uc774\uc0c1\uc758 \ud328\ud134\uacfc \ube44\uad50\ud560 \uc218\ub3c4 \uc788\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Brightness\n  = Dark\n  | Bright\n\ndata EightColor\n  = Black\n  | Red\n  | Green\n  | Yellow\n  | Blue\n  | Magenta\n  | Cyan\n  | White\n\ndata AnsiColor\n  = AnsiColor Brightness EightColor\n\nansiColorToVGA :: AnsiColor -> Color\nansiColorToVGA ansicolor =\n  case ansicolor of\n    AnsiColor Dark Black ->\n      RGB 0 0 0\n    AnsiColor Bright Black ->\n      RGB 85 85 85\n    AnsiColor Dark Red ->\n      RGB 170 0 0\n    AnsiColor Bright Red ->\n      RGB 255 85 85\n    -- and so on\n")),(0,r.kt)("p",null,"\ub2e4\uc74c \ud56d\ubaa9\uc744 \uc8fc\ubaa9\ud558\uc138\uc694:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"\ud328\ud134\uc740 \uc911\ucca9\ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4. ",(0,r.kt)("inlineCode",{parentName:"li"},"ansicolor"),"\ub97c \uc5ec\ub7ec \ub2e8\uacc4\ub85c \ubd84\ud574\ud558\ub294 \uac83\uc744 \uc54c \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("li",{parentName:"ol"},"\ud328\ud134\uc740 \uc704\uc5d0\uc11c \uc544\ub798\ub85c \ub9e4\uce6d\ub418\ubbc0\ub85c, \ud328\ud134\uc774 \uc911\ucca9\ub418\uba74 \uc704\uc5d0 \uc788\ub294 \ud328\ud134\uc774 \uc6b0\uc120\ud569\ub2c8\ub2e4."),(0,r.kt)("li",{parentName:"ol"},"\uc5b4\ub5a4 \uac12\uc774 \uc8fc\uc5b4\uc9c4 \ubaa8\ub4e0 \ud328\ud134\uacfc \uc77c\uce58\ud558\uc9c0 \uc54a\uc73c\uba74 \ub7f0\ud0c0\uc784\uc5d0 \uc5d0\ub7ec\uac00 \ubc1c\uc0dd\ud569\ub2c8\ub2e4.")),(0,r.kt)("p",null,"GHC\uc5d0\uac8c \uc6b0\ub9ac\uac00 \uc2e4\uc218\ub85c \ud328\ud134\uc744 \uc911\ubcf5\ud574\uc11c \uc791\uc131\ud588\uac70\ub098, \ubaa8\ub4e0 \uac00\ub2a5\ud55c \uac12\uc744 \ub9e4\uce6d\ud560 \uc218 \uc788\ub3c4\ub85d \uc791\uc131\ud558\uc9c0 \uc54a\uc558\ub2e4\ub294 \uac83\uc744 \uc54c\ub824\uc8fc\ub3c4\ub85d \ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n",(0,r.kt)("inlineCode",{parentName:"p"},"ghc")," \ub610\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"runghc"),"\uc5d0 ",(0,r.kt)("inlineCode",{parentName:"p"},"-Wall")," \ud50c\ub798\uadf8\ub97c \uc804\ub2ec\ud558\uba74 \ub429\ub2c8\ub2e4."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\ud56d\uc0c1 ",(0,r.kt)("inlineCode",{parentName:"strong"},"-Wall"),"\uc744 \uc0ac\uc6a9\ud558\ub294 \uac83\uc744 \uad8c\uc7a5\ud569\ub2c8\ub2e4"),"!"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"\ud568\uc218\ub97c \uc5ec\ub7ec\ubc88 \uc815\uc758\ud558\ub294 \ubc29\uc2dd\uc744 \ud1b5\ud574, \ud328\ud134 \ub9e4\uce6d\uc744 \ud568\uc218 \uc815\uc758\uc5d0\ub3c4 \uc0ac\uc6a9\ud560 \uc218\ub3c4 \uc788\uc2b5\ub2c8\ub2e4.\n\ud558\uc9c0\ub9cc ",(0,r.kt)("a",{parentName:"p",href:"https://twitter.com/_gilmi/status/1257225601079029760"},"\uac1c\uc778\uc801\uc73c\ub85c \uadf8 \uae30\ub2a5\uc744 \uc369 \uc88b\uc544\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4"),"\n\uac00\ub2a5\ud558\uba74 case \ud45c\ud604\uc2dd\uc744 \uc0ac\uc6a9\ud558\ub294 \uac83\uc744 \uad8c\uc7a5\ud569\ub2c8\ub2e4.\n\ud558\uc9c0\ub9cc \uc6d0\ud55c\ub2e4\uba74 case \ud45c\ud604\uc2dd \ub300\uc2e0 \uc0ac\uc6a9\ud574\ub3c4 \uc88b\uc2b5\ub2c8\ub2e4.")),(0,r.kt)("h3",{id:"\uc5f0\uacb0-\ub9ac\uc2a4\ud2b8-\ud328\ud134-\ub9e4\uce6d"},"\uc5f0\uacb0 \ub9ac\uc2a4\ud2b8 \ud328\ud134 \ub9e4\uce6d"),(0,r.kt)("p",null,"\uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\uc5d0\ub294 ",(0,r.kt)("a",{parentName:"p",href:"/learn-haskell-blog-generator/html/escaping-characters#linked-lists-briefly"},"\ud2b9\ubcc4\ud55c \ubb38\ubc95"),"\uc774 \uc788\ub294\ub370, \ud328\ud134 \ub9e4\uce6d\uc5d0\ub3c4 \ud2b9\ubcc4\ud55c \ubb38\ubc95\uc774 \uc788\uc2b5\ub2c8\ub2e4.\n\ub9ac\uc2a4\ud2b8\ub97c \ub9cc\ub4e4 \ub54c \uc0ac\uc6a9\ud55c \ud2b9\ubcc4\ud55c \ubb38\ubc95\uc744 \ud1b5\ud574, \ub9ac\uc2a4\ud2b8\uc758 ",(0,r.kt)("em",{parentName:"p"},"\uc694\uc18c"),"\ub97c \ud328\ud134\uc73c\ub85c \uc0ac\uc6a9\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\uc608\ub97c \ub4e4\uc5b4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"safeHead :: [a] -> Maybe a\nsafeHead list =\n  case list of\n    -- \ube48 \ub9ac\uc2a4\ud2b8\n    [] -> Nothing\n\n    -- cons \uc140 \ud328\ud134, \ub9ac\uc2a4\ud2b8\uc758 \uccab \ubc88\uc9f8 \uc694\uc18c\ub97c x\uc5d0 \ub9e4\uce6d\n    x : _ -> Just x\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"exactlyTwo :: [a] -> Maybe (a, a)\nexactlyTwo list =\n  case list of\n    -- \uc815\ud655\ud788 \ub450 \uac1c\uc758 \uc694\uc18c\ub97c \uac00\uc9c4 \ub9ac\uc2a4\ud2b8\uc640 \ub9e4\uce6d\n    [x, y] -> Just (x, y)\n\n    -- \ub098\uba38\uc9c0 \ubaa8\ub4e0 \ud328\ud134\uacfc \ub9e4\uce6d\n    _ -> Nothing\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- \ub2e4\uc74c \ud568\uc218\ub3c4 \uac19\uc740 \uacb0\uacfc\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4\nexactlyTwoVersion2 :: [a] -> Maybe (a, a)\nexactlyTwoVersion2 list =\n  case list of\n    -- \uc815\ud655\ud788 \ub450 \uac1c\uc758 \uc694\uc18c\ub97c \uac00\uc9c4 \ub9ac\uc2a4\ud2b8\uc640 \ub9e4\uce6d\n    x : y : [] -> Just (x, y)\n\n    -- \ub098\uba38\uc9c0 \ubaa8\ub4e0 \ud328\ud134\uacfc \ub9e4\uce6d\n    _ -> Nothing\n")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"\uc5f0\uc2b5\ubb38\uc81c:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"\uc8fc\uc5b4\uc9c4 \uc0c9\uc774 \ubc1d\uc740 \uc0c9\uc778\uc9c0\ub97c \ud655\uc778\ud558\ub294 ",(0,r.kt)("inlineCode",{parentName:"li"},"isBright :: AnsiColor -> Bool")," \ud568\uc218\ub97c \uc791\uc131\ud558\uc138\uc694."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit"},"\uc774 \ud45c"),"\ub97c \uc0ac\uc6a9\ud558\uc5ec ",(0,r.kt)("inlineCode",{parentName:"li"},"ansiToUbuntu")," \ud568\uc218\ub97c \uc791\uc131\ud558\uc138\uc694."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"listToMaybe"),"\ub97c \uc0ac\uc6a9\ud574 \ub9ac\uc2a4\ud2b8\uac00 \ube44\uc5b4\uc788\ub294\uc9c0 \ud655\uc778\ud558\ub294 ",(0,r.kt)("inlineCode",{parentName:"li"},"isEmpty :: [a] -> Bool")," \ud568\uc218\ub97c \uc791\uc131\ud558\uc138\uc694."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"listToMaybe"),"\ub97c ",(0,r.kt)("em",{parentName:"li"},"\uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0")," \ub9ac\uc2a4\ud2b8\uac00 \ube44\uc5b4\uc788\ub294\uc9c0 \ud655\uc778\ud558\ub294 ",(0,r.kt)("inlineCode",{parentName:"li"},"isEmpty :: [a] -> Bool")," \ud568\uc218\ub97c \uc791\uc131\ud558\uc138\uc694.")),(0,r.kt)("p",null,"\uc815\ub2f5:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"\uc5f0\uc2b5\ubb38\uc81c (1)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"isBright :: AnsiColor -> Bool\nisBright ansiColor =\n  case ansiColor of\n    AnsiColor Bright _ -> True\n    AnsiColor Dark _ -> False\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"\uc5f0\uc2b5\ubb38\uc81c (2)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ansiToUbuntu :: AnsiColor -> Color\nansiToUbuntu ansiColor =\n  case ansiColor of\n    AnsiColor brightness color ->\n      case brightness of\n        Dark ->\n          case color of\n            Black -> RGB 0 0 0\n            Red -> RGB 194 54 33\n            Green -> RGB 37 188 36\n            Yellow -> RGB 173 173 39\n            Blue -> RGB 73 46 225\n            Magenta -> RGB 211 56 211\n            Cyan -> RGB 51 187 200\n            White -> RGB 203 204 205\n\n        Bright ->\n          case color of\n            Black -> RGB 129 131 131\n            Red -> RGB 252 57 31\n            Green -> RGB 49 231 34\n            Yellow -> RGB 234 236 35\n            Blue -> RGB 88 51 255\n            Magenta -> RGB 249 53 248\n            Cyan -> RGB 20 240 240\n            White -> RGB 233 235 235\n")),(0,r.kt)("p",null,"\uc704 \ucf54\ub4dc\ucc98\ub7fc \ud328\ud134 \ub9e4\uce6d\uc740 \ud55c \uc5c6\uc774 \uae4a\uc5b4\uc9c8 \uc218 \uc788\uae30\uc5d0, \ud558\ub098\uc758 ",(0,r.kt)("inlineCode",{parentName:"p"},"case")," \ud45c\ud604\uc2dd\uc744 \uc0ac\uc6a9\ud574 \ubaa8\ub4e0 \uacbd\uc6b0\ub97c \ub9e4\uce6d\ud560 \uc218\ub3c4 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ansiToUbuntu :: AnsiColor -> Color\nansiToUbuntu ansiColor =\n  case ansiColor of\n    AnsiColor Dark Black -> RGB 0 0 0\n    AnsiColor Dark Red -> RGB 194 54 33\n    AnsiColor Dark Green -> RGB 37 188 36\n    AnsiColor Dark Yellow -> RGB 173 173 39\n    AnsiColor Dark Blue -> RGB 73 46 225\n    AnsiColor Dark Magenta -> RGB 211 56 211\n    AnsiColor Dark Cyan -> RGB 51 187 200\n    AnsiColor Dark White -> RGB 203 204 205\n    AnsiColor Bright Black -> RGB 129 131 131\n    AnsiColor Bright Red -> RGB 252 57 31\n    AnsiColor Bright Green -> RGB 49 231 34\n    AnsiColor Bright Yellow -> RGB 234 236 35\n    AnsiColor Bright Blue -> RGB 88 51 255\n    AnsiColor Bright Magenta -> RGB 249 53 248\n    AnsiColor Bright Cyan -> RGB 20 240 240\n    AnsiColor Bright White -> RGB 233 235 235\n")),(0,r.kt)("p",null,"\ud558\uc9c0\ub9cc \uc774 \ubc29\uc2dd\uc740 ",(0,r.kt)("inlineCode",{parentName:"p"},"AnsiColor"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Dark")," \uadf8\ub9ac\uace0 ",(0,r.kt)("inlineCode",{parentName:"p"},"Bright"),"\uac00 \ub9ce\uc774 \ubc18\ubcf5\ub418\ub294 \ub2e8\uc810\uc774 \uc788\uc2b5\ub2c8\ub2e4.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"\uc5f0\uc2b5\ubb38\uc81c (3)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"isEmpty :: [a] -> Bool\nisEmpty list =\n  case listToMaybe list of\n    Nothing -> True\n    Just _ -> False\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"\uc5f0\uc2b5\ubb38\uc81c (4)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"isEmpty :: [a] -> Bool\nisEmpty list =\n  case list of\n    [] -> True\n    _ : _ -> False\n"))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"parsing-with-rich-context"},"Parsing with rich context"),(0,r.kt)("p",null,"Previously we wrote a parser that separates documents into different paragraphs.\nWith new features under our belt we can now remember the exact context we are in\n(whether it is a text paragraph, a list, or a code block) and act accordingly!"),(0,r.kt)("p",null,"Let's look again at the parsing code we wrote previously:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'parse :: String -> Document\nparse = parseLines [] . lines\n\nparseLines :: [String] -> [String] -> Document\nparseLines currentParagraph txts =\n  let\n    paragraph = Paragraph (unlines (reverse currentParagraph))\n  in\n    case txts of\n      [] -> [paragraph]\n      currentLine : rest ->\n        if trim currentLine == ""\n          then\n            paragraph : parseLines [] rest\n          else\n            parseLines (currentLine : currentParagraph) rest\n\ntrim :: String -> String\ntrim = unwords . words\n')),(0,r.kt)("p",null,"Previously our context, ",(0,r.kt)("inlineCode",{parentName:"p"},"currentParagraph"),", was used to group adjacent lines in an accumulative list."),(0,r.kt)("p",null,"Next, instead of using a ",(0,r.kt)("inlineCode",{parentName:"p"},"[String]")," type to denote adjacent lines, we can instead use a ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure")," to denote the context."),(0,r.kt)("p",null,"One issue we might have though with representing context with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure")," type,\nis that when we start parsing we don't have any context.\nBut we have learned of a way to represent the absence of a value with ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe"),"! So our new context type can be ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe Structure")," instead."),(0,r.kt)("p",null,"Let's rewrite our code above with our new context type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'parse :: String -> Document\nparse = parseLines Nothing . lines -- (1)\n\nparseLines :: Maybe Structure -> [String] -> Document\nparseLines context txts =\n  case txts of\n    [] -> maybeToList context -- (2)\n    -- Paragraph case\n    currentLine : rest ->\n      let\n        line = trim currentLine\n      in\n        if line == ""\n          then\n            maybe id (:) context (parseLines Nothing rest) -- (3)\n          else\n            case context of\n              Just (Paragraph paragraph) ->\n                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest -- (4)\n              _ ->\n                maybe id (:) context (parseLines (Just (Paragraph line)) rest)\n\ntrim :: String -> String\ntrim = unwords . words\n')),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"We can now pass ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing")," when we don't have a context")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Unsure what ",(0,r.kt)("inlineCode",{parentName:"p"},"maybeToList")," does? ",(0,r.kt)("a",{parentName:"p",href:"https://hoogle.haskell.org"},"Hoogle")," it!")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"We can split this line into two important parts:"),(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"maybe id (:) context")," - prepending the context to the rest of the document"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"parseLines Nothing rest")," - parsing the rest of the document")),(0,r.kt)("p",{parentName:"li"},"Let's focus on the first part.\nWe want to prepend ",(0,r.kt)("inlineCode",{parentName:"p"},"context")," to the rest of the document, but we can't write\n",(0,r.kt)("inlineCode",{parentName:"p"},"context : parseLines Nothing rest")," because ",(0,r.kt)("inlineCode",{parentName:"p"},"context")," has the type ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe Structure"),"\nand not ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure"),", meaning that we ",(0,r.kt)("em",{parentName:"p"},"might")," have a ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure")," but maybe not.\nIf we do have a ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure")," to prepend, we wish to prepend it. If not, we want to return\nthe result of ",(0,r.kt)("inlineCode",{parentName:"p"},"parseLines Nothing rest")," as is. Try writing this using pattern matching!"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"case context of\n  Nothing -> parseLines Nothing rest\n  Just structure -> structure : parseLines Nothing rest\n"))),(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:maybe"},"maybe"),"\nfunction let's us do the same thing in a more compact way. It is a function\nthat works similarly to pattern matching on a ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe"),":\nthe third argument to ",(0,r.kt)("inlineCode",{parentName:"p"},"maybe")," is the value on which we pattern match,\nthe second argument is a function to apply to the value found in a ",(0,r.kt)("inlineCode",{parentName:"p"},"Just")," case,\nand the first argument is the value to return in case the value\nwe pattern match on is ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing"),". A more faithful translation of\n",(0,r.kt)("inlineCode",{parentName:"p"},"maybe id (:) context (parseLines Nothing rest)"),"\nto pattern matching would look like this:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"( case context of\n    Nothing -> id\n    Just structure -> (:) structure\n) (parseLines Nothing rest)\n")),(0,r.kt)("p",{parentName:"li"},"Note how the result of this case expression is a function of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Document -> Document"),",\nhow we partially apply ",(0,r.kt)("inlineCode",{parentName:"p"},"(:)")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"structure")," to create a function that prepends ",(0,r.kt)("inlineCode",{parentName:"p"},"structure"),",\nand how we apply ",(0,r.kt)("inlineCode",{parentName:"p"},"parseLines Nothing rest")," to the case expression.")),(0,r.kt)("p",{parentName:"li"},"This way of encoding pattern matching using functions is fairly common."),(0,r.kt)("p",{parentName:"li"},"Check out the types of ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"(:)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"maybe id (:)")," in GHCi!")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Hey! Didn't we say that appending ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"s/lists is slow (which is what ",(0,r.kt)("inlineCode",{parentName:"p"},"unwords")," does)? Yes, it is.\nBecause in our ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure")," data type, a paragraph is defined as ",(0,r.kt)("inlineCode",{parentName:"p"},"Paragraph String")," and not ",(0,r.kt)("inlineCode",{parentName:"p"},"Paragraph [String]"),",\nwe can't use our trick of building a list of lines and then reverse it in the end."),(0,r.kt)("p",{parentName:"li"},"So what do we do?\nThere are many ways to handle that, one simple way is to create a different type with the right shape:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Context\n  = CtxHeading Natural String\n  | CtxParagraph [String]\n  | CtxUnorderedList [String]\n  | CtxOrderedList [String]\n  | CtxCodeBlock [String]\n")),(0,r.kt)("p",{parentName:"li"},"Since creating new types in Haskell is cheap, this is a very viable solution."),(0,r.kt)("p",{parentName:"li"},"In this case I'm going with the approach of not worrying about it too much,\nbecause it's a very local piece of code that can easily be fixed later if needed."))),(0,r.kt)("p",null,"Let's cover more parsing cases, we want to handle headings and lists as well.\nWe can do that by examining the first characters of a line:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"parse :: String -> Document\nparse = parseLines Nothing . lines\n\nparseLines :: Maybe Structure -> [String] -> Document\nparseLines context txts =\n  case txts of\n    -- done case\n    [] -> maybeToList context\n\n    -- Heading 1 case\n    ('*' : ' ' : line) : rest ->\n      maybe id (:) context (Heading 1 (trim line) : parseLines Nothing rest)\n\n    -- Unordered list case\n    ('-' : ' ' : line) : rest ->\n      case context of\n        Just (UnorderedList list) ->\n          parseLines (Just (UnorderedList (list <> [trim line]))) rest\n\n        _ ->\n          maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest)\n\n    -- Paragraph case\n    currentLine : rest ->\n      let\n        line = trim currentLine\n      in\n        if line == \"\"\n          then\n            maybe id (:) context (parseLines Nothing rest)\n          else\n            case context of\n              Just (Paragraph paragraph) ->\n                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest\n              _ ->\n                maybe id (:) context (parseLines (Just (Paragraph line)) rest)\n\ntrim :: String -> String\ntrim = unwords . words\n")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Exercise: Add the ",(0,r.kt)("inlineCode",{parentName:"p"},"CodeBlock")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"OrderedList")," cases."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Final module"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- Markup.hs\n\nmodule Markup\n  ( Document\n  , Structure(..)\n  , parse\n  )\nwhere\n\nimport Numeric.Natural\nimport Data.Maybe (maybeToList)\n\ntype Document\n  = [Structure]\n\ndata Structure\n  = Heading Natural String\n  | Paragraph String\n  | UnorderedList [String]\n  | OrderedList [String]\n  | CodeBlock [String]\n  deriving (Eq, Show)    -- (1)\n\n\nparse :: String -> Document\nparse = parseLines Nothing . lines\n\nparseLines :: Maybe Structure -> [String] -> Document\nparseLines context txts =\n  case txts of\n    -- done case\n    [] -> maybeToList context\n\n    -- Heading 1 case\n    ('*' : ' ' : line) : rest ->\n      maybe id (:) context (Heading 1 (trim line) : parseLines Nothing rest)\n\n    -- Unordered list case\n    ('-' : ' ' : line) : rest ->\n      case context of\n        Just (UnorderedList list) ->\n          parseLines (Just (UnorderedList (list <> [trim line]))) rest\n\n        _ ->\n          maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest)\n\n    -- Ordered list case\n    ('#' : ' ' : line) : rest ->\n      case context of\n        Just (OrderedList list) ->\n          parseLines (Just (OrderedList (list <> [trim line]))) rest\n\n        _ ->\n          maybe id (:) context (parseLines (Just (OrderedList [trim line])) rest)\n\n    -- Code block case\n    ('>' : ' ' : line) : rest ->\n      case context of\n        Just (CodeBlock code) ->\n          parseLines (Just (CodeBlock (code <> [line]))) rest\n\n        _ ->\n          maybe id (:) context (parseLines (Just (CodeBlock [line])) rest)\n\n    -- Paragraph case\n    currentLine : rest ->\n      let\n        line = trim currentLine\n      in\n        if line == \"\"\n          then\n            maybe id (:) context (parseLines Nothing rest)\n          else\n            case context of\n              Just (Paragraph paragraph) ->\n                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest\n              _ ->\n                maybe id (:) context (parseLines (Just (Paragraph line)) rest)\n\ntrim :: String -> String\ntrim = unwords . words\n"))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"how-do-we-know-our-parser-works-correctly"},"How do we know our parser works correctly?"),(0,r.kt)("p",null,"In an earlier chapter, we parsed a few examples of our markup language ",(0,r.kt)("a",{parentName:"p",href:"/learn-haskell-blog-generator/markup/data-type#exercises"},"by hand"),".\nNow, we can try to test our parser by comparing our solutions to our parser.\nBy deriving ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," for our ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure"),' data type\n(marked with (1) in "final module" above),\nwe can compare solutions with the ',(0,r.kt)("inlineCode",{parentName:"p"},"==")," (equals) operator."),(0,r.kt)("p",null,"Try it in GHCi! You can read a text file in GHCi using the following syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> txt <- readFile "/tmp/sample.txt"\n')),(0,r.kt)("p",null,"And then compare with the hand written example values from the solutions\n(after adding them to the module and loading them in GHCi):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> parse txt == example4\n")),(0,r.kt)("p",null,"In a later chapter, we'll write automated tests for our parser using a testing framework.\nBut before that, I'd like to glue things together\nso we'll be able to:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Read markup text from a file"),(0,r.kt)("li",{parentName:"ol"},"Parse the text"),(0,r.kt)("li",{parentName:"ol"},"Convert the result to our HTML EDSL"),(0,r.kt)("li",{parentName:"ol"},"Generate HTML code")),(0,r.kt)("p",null,"And also discuss how to work with IO in Haskell while we're at it."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"You can view the git commit of\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/commit/9f951a05d4f78cf59190ee4f3cd8de85e1c33bd1"},"the changes we've made"),"\nand the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/tree/9f951a05d4f78cf59190ee4f3cd8de85e1c33bd1"},"code up until now"),".")))}m.isMDXComponent=!0}}]);