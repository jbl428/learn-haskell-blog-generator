"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[561],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>k});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=a.createContext({}),s=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):p(p({},n),e)),t},u=function(e){var n=s(e.components);return a.createElement(o.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=s(t),c=i,k=m["".concat(o,".").concat(c)]||m[c]||d[c]||r;return t?a.createElement(k,p(p({ref:n},u),{},{components:t})):a.createElement(k,p({ref:n},u))}));function k(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,p=new Array(r);p[0]=c;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l[m]="string"==typeof e?e:i,p[1]=l;for(var s=2;s<r;s++)p[s]=t[s];return a.createElement.apply(null,p)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},1548:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>p,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=t(7462),i=(t(7294),t(3905));const r={},p="\uba4b\uc9c4 \uc635\uc158 \ud30c\uc2f1",l={unversionedId:"glue/optparse",id:"glue/optparse",title:"\uba4b\uc9c4 \uc635\uc158 \ud30c\uc2f1",description:"\uc774\ubc88\uc5d0\ub294 \ud504\ub85c\uadf8\ub7a8\uc744 \uc704\ud55c \ub354 \uba4b\uc9c4 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc815\uc758\ud574\ubcf4\ub824\uace0 \ud569\ub2c8\ub2e4.",source:"@site/docs/05-glue/04-optparse.md",sourceDirName:"05-glue",slug:"/glue/optparse",permalink:"/learn-haskell-blog-generator/glue/optparse",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/05-glue/04-optparse.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ud504\ub85c\uc81d\ud2b8\uc758 \uba85\uc138\ub97c \uc815\uc758\ud558\uae30",permalink:"/learn-haskell-blog-generator/glue/project"},next:{title:"Handling errors and multiple files",permalink:"/learn-haskell-blog-generator/errors_and_files/"}},o={},s=[{value:"\uba85\ub839\uc904 \ud30c\uc11c \ub9cc\ub4e4\uae30",id:"\uba85\ub839\uc904-\ud30c\uc11c-\ub9cc\ub4e4\uae30",level:2},{value:"\ubaa8\ub378 \uc815\uc758\ud558\uae30",id:"\ubaa8\ub378-\uc815\uc758\ud558\uae30",level:3},{value:"\ud30c\uc11c \ub9cc\ub4e4\uae30",id:"\ud30c\uc11c-\ub9cc\ub4e4\uae30",level:3},{value:"Functor",id:"functor",level:4},{value:"Applicative",id:"applicative",level:4},{value:"Alternative",id:"alternative",level:4},{value:"Commands and subparsers",id:"commands-and-subparsers",level:4},{value:"ParserInfo",id:"parserinfo",level:4},{value:"Running a parser",id:"running-a-parser",level:3},{value:"Pattern matching on Options",id:"pattern-matching-on-options",level:3},{value:"Summary",id:"summary",level:2}],u={toc:s},m="wrapper";function d(e){let{components:n,...t}=e;return(0,i.kt)(m,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"\uba4b\uc9c4-\uc635\uc158-\ud30c\uc2f1"},"\uba4b\uc9c4 \uc635\uc158 \ud30c\uc2f1"),(0,i.kt)("p",null,"\uc774\ubc88\uc5d0\ub294 \ud504\ub85c\uadf8\ub7a8\uc744 \uc704\ud55c \ub354 \uba4b\uc9c4 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc815\uc758\ud574\ubcf4\ub824\uace0 \ud569\ub2c8\ub2e4.\n",(0,i.kt)("inlineCode",{parentName:"p"},"getArgs"),"\uc640 \ud328\ud134 \ub9e4\uce6d\uc73c\ub85c\ub3c4 \ubb34\uc5b8\uac00\ub97c \ub9cc\ub4e4 \uc218 \uc788\uc9c0\ub9cc, \ub77c\uc774\ube0c\ub7ec\ub9ac\ub97c \uc0ac\uc6a9\ud558\uba74 \ub354 \uc88b\uc740 \uacb0\uacfc\ub97c \uc5bb\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\uc774\ubc88 \uc7a5\uc5d0\uc11c\ub294 ",(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/optparse-applicative"},"optparse-applicative"),"\ub77c\ub294 \ud328\ud0a4\uc9c0\ub97c \uc0ac\uc6a9\ud560 \uac83\uc785\ub2c8\ub2e4."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"optparse-applicative"),"\ub294 \uba85\ub839\ud589 \uc778\uc790 \ud30c\uc11c\ub97c \ub9cc\ub4e4\uae30 \uc704\ud55c EDSL\uc744 \uc81c\uacf5\ud569\ub2c8\ub2e4.\n\uba85\ub839, \uc2a4\uc704\uce58, \ud50c\ub798\uadf8 \ub4f1\uc744 \ub9cc\ub4e4\uace0 \uc870\ud569\ud558\uc5ec \uc2e4\uc81c\ub85c \ubb38\uc790\uc5f4\uc5d0 \ub300\ud55c \uc5f0\uc0b0\uc744 \uc791\uc131\ud558\uc9c0 \uc54a\uace0\ub3c4\n\uba85\ub839\ud589 \uc778\uc790\ub97c \ud30c\uc2f1\ud558\ub294 \ud30c\uc11c\ub97c \ub9cc\ub4e4 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\ub610\ud55c \uc0ac\uc6a9\ubc95, \ub3c4\uc6c0\ub9d0, \uc5d0\ub7ec \uba54\uc2dc\uc9c0 \ub4f1\uc744 \uc790\ub3d9\uc73c\ub85c \uc0dd\uc131\ud574\uc8fc\ub294 \ub4f1\uc758 \uae30\ub2a5\ub3c4 \uc81c\uacf5\ud569\ub2c8\ub2e4."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"optparse-applicative"),"\uc758 \uc758\uc874\uc131 \ud48b\ud504\ub9b0\ud2b8\ub294 \ud06c\uc9c0 \uc54a\uc9c0\ub9cc, \uc6b0\ub9ac \ub77c\uc774\ube0c\ub7ec\ub9ac\ub97c \uc0ac\uc6a9\ud558\ub294 \uc0ac\uc6a9\uc790\uac00\n\uba85\ub839\ud589 \ud30c\uc2f1\uc774 \ud544\uc694\ud558\uc9c0 \uc54a\uc744 \uac00\ub2a5\uc131\uc774 \ub192\uae30 \ub54c\ubb38\uc5d0 ",(0,i.kt)("inlineCode",{parentName:"p"},".cabal")," \ud30c\uc77c\uc758 (",(0,i.kt)("inlineCode",{parentName:"p"},"libray")," \uc139\uc158\uc774 \uc544\ub2cc) ",(0,i.kt)("inlineCode",{parentName:"p"},"executable")," \uc139\uc158\uc5d0\n\uc758\uc874\uc131\uc744 \ucd94\uac00\ud558\ub294\uac8c \ubc14\ub78c\uc9c1\ud569\ub2c8\ub2e4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"}," executable hs-blog-gen\n   import: common-settings\n   hs-source-dirs: app\n   main-is: Main.hs\n   build-depends:\n       base\n+    , optparse-applicative\n     , hs-blog\n   ghc-options:\n     -O\n")),(0,i.kt)("h2",{id:"\uba85\ub839\uc904-\ud30c\uc11c-\ub9cc\ub4e4\uae30"},"\uba85\ub839\uc904 \ud30c\uc11c \ub9cc\ub4e4\uae30"),(0,i.kt)("p",null,"optparse-applicative \ud328\ud0a4\uc9c0\ub294 \uaf64 \uad1c\ucc2e\uc740\n",(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/optparse-applicative-0.16.1.0#optparse-applicative"},"\ubb38\uc11c"),",\n\ub97c \uac00\uc9c0\uace0 \uc788\uc2b5\ub2c8\ub2e4. \ud558\uc9c0\ub9cc \uc774 \uc7a5\uc5d0\uc11c \uc911\uc694\ud55c \uba87 \uac00\uc9c0 \uc0ac\ud56d\uc744 \ub2e4\ub8f0 \uac83\uc785\ub2c8\ub2e4."),(0,i.kt)("p",null,"\uc77c\ubc18\uc801\uc73c\ub85c, \uc6b0\ub9ac\uac00 \ud574\uc57c \ud560 \uc77c\uc740 \ub124 \uac00\uc9c0\uac00 \uc788\uc2b5\ub2c8\ub2e4:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"\ubaa8\ub378\uc744 \uc815\uc758\ud569\ub2c8\ub2e4 - \ud504\ub85c\uadf8\ub7a8\uc758 \ub2e4\uc591\ud55c \uc635\uc158\uacfc \uba85\ub839\uc744 \uc124\uba85\ud558\ub294 ADT\ub97c \uc815\uc758\ud569\ub2c8\ub2e4."),(0,i.kt)("li",{parentName:"ol"},"\uc2e4\ud589\ud560 \ub54c \ubaa8\ub378 \ud0c0\uc785\uc758 \uac12\uc744 \uc0dd\uc131\ud558\ub294 \ud30c\uc11c\ub97c \uc815\uc758\ud569\ub2c8\ub2e4."),(0,i.kt)("li",{parentName:"ol"},"\ud30c\uc11c\ub97c \ud504\ub85c\uadf8\ub7a8 \uc778\uc790 \uc785\ub825\uc5d0 \uc2e4\ud589\ud569\ub2c8\ub2e4."),(0,i.kt)("li",{parentName:"ol"},"\ubaa8\ub378\uc744 \ud328\ud134 \ub9e4\uce6d\ud558\uace0 \uc635\uc158\uc5d0 \ub530\ub77c \uc62c\ubc14\ub978 \uc791\uc5c5\uc744 \ud638\ucd9c\ud569\ub2c8\ub2e4.")),(0,i.kt)("h3",{id:"\ubaa8\ub378-\uc815\uc758\ud558\uae30"},"\ubaa8\ub378 \uc815\uc758\ud558\uae30"),(0,i.kt)("p",null,"\uba3c\uc800 \uc6b0\ub9ac\uc758 \uba85\ub839\uc904 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc0c1\uc0c1\ud574\ubd05\uc2dc\ub2e4. \uc5b4\ub5a4 \uae30\ub2a5\uc774 \uc788\uc744\uae4c\uc694?"),(0,i.kt)("p",null,"\ub2e8\uc77c \ud30c\uc77c\uc774\ub098 \uc785\ub825 \uc2a4\ud2b8\ub9bc\uc744 \ud30c\uc77c\uc774\ub098 \ucd9c\ub825 \uc2a4\ud2b8\ub9bc\uc73c\ub85c \ubcc0\ud658\ud574\uac70\ub098,\n\ub514\ub809\ud1a0\ub9ac \uc804\uccb4\ub97c \ucc98\ub9ac\ud558\uace0 \uc0c8 \ub514\ub809\ud1a0\ub9ac\ub97c \uc0dd\uc131\ud560 \uc218 \uc788\uc5b4\uc57c \ud569\ub2c8\ub2e4.\n\uc6b0\ub9ac\ub294 \uc774\ub97c ADT\ub85c \ubaa8\ub378\ub9c1 \ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"data Options\n  = ConvertSingle SingleInput SingleOutput\n  | ConvertDir FilePath FilePath\n  deriving Show\n\ndata SingleInput\n  = Stdin\n  | InputFile FilePath\n  deriving Show\n\ndata SingleOutput\n  = Stdout\n  | OutputFile FilePath\n  deriving Show\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"SingleInput"),"\uacfc ",(0,i.kt)("inlineCode",{parentName:"p"},"SingleOutput"),"\uc744 ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe FilePath"),"\ub85c \ud45c\ud604\ud558\ub294 \uac83\ub3c4 \ud558\ub098\uc758 \ubc29\ubc95\uc785\ub2c8\ub2e4.\n\ud558\uc9c0\ub9cc \uc774 \uacbd\uc6b0 \uac01 \ubb38\ub9e5\uc5d0\uc11c ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing"),"\uc774 \ubb34\uc5c7\uc744 \uc758\ubbf8\ud558\ub294\uc9c0 \uae30\uc5b5\ud574\uc57c \ud569\ub2c8\ub2e4.\n\uac01 \uc635\uc158\uc5d0 \ub300\ud55c \uc801\uc808\ud55c \uc774\ub984\uc744 \uac00\uc9c4 \uc0c8\ub85c\uc6b4 \ud0c0\uc785\uc744 \ub9cc\ub4dc\ub294 \uac83\uc774 \ucf54\ub4dc\uc758 \uc758\ubbf8\ub97c \uc774\ud574\ud558\ub294\ub370 \ub3c4\uc6c0\uc774 \ub429\ub2c8\ub2e4.")),(0,i.kt)("p",null,"\uc778\ud130\ud398\uc774\uc2a4 \uad00\uc810\uc5d0\uc11c, \uc0ac\uc6a9\uc790\uac00 \ub2e8\uc77c \uc785\ub825 \uc18c\uc2a4\ub97c \ubcc0\ud658\ud558\ub824\uba74 ",(0,i.kt)("inlineCode",{parentName:"p"},"convert")," \uba85\ub839\uc5b4\ub97c \uc0ac\uc6a9\ud558\uace0\n\uc635\uc158\uc73c\ub85c ",(0,i.kt)("inlineCode",{parentName:"p"},"--input FILEPATH"),"\uc640 ",(0,i.kt)("inlineCode",{parentName:"p"},"--output FILEPATH"),"\ub97c \uc81c\uacf5\ud558\uc5ec \ud30c\uc77c\uc5d0\uc11c \uc77d\uac70\ub098 \uc4f0\uac8c\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\ub9cc\uc57d \uc0ac\uc6a9\uc790\uac00 \ud558\ub098 \uc774\uc0c1\uc758 \uc635\uc158\uc744 \uc81c\uacf5\ud558\uc9c0 \uc54a\uc73c\uba74 \ud45c\uc900 \uc785\ub825/\ucd9c\ub825\uc5d0\uc11c \uc77d\uac70\ub098 \uc4f8 \uac83\uc785\ub2c8\ub2e4."),(0,i.kt)("p",null,"\ub9cc\uc57d \uc0ac\uc6a9\uc790\uac00 \ub514\ub809\ud1a0\ub9ac\ub97c \ubcc0\ud658\ud558\ub824\uba74 ",(0,i.kt)("inlineCode",{parentName:"p"},"convert-dir")," \uba85\ub839\uc5b4\ub97c \uc0ac\uc6a9\ud558\uace0\n",(0,i.kt)("inlineCode",{parentName:"p"},"--input FILEPATH"),"\uc640 ",(0,i.kt)("inlineCode",{parentName:"p"},"--output FILEPATH"),"\ub97c \ud544\uc218\ub85c \uc785\ub825\ud574\uc57c \ud569\ub2c8\ub2e4."),(0,i.kt)("h3",{id:"\ud30c\uc11c-\ub9cc\ub4e4\uae30"},"\ud30c\uc11c \ub9cc\ub4e4\uae30"),(0,i.kt)("p",null,"\uc774 \uacfc\uc815\uc5d0\uc11c \uac00\uc7a5 \ud765\ubbf8\ub85c\uc6b4 \ubd80\ubd84\uc785\ub2c8\ub2e4. \uc5b4\ub5bb\uac8c \ubaa8\ub378\uc5d0 \ub9de\ub294 \ud30c\uc11c\ub97c \ub9cc\ub4e4 \uc218 \uc788\uc744\uae4c\uc694?"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"optparse-applicative")," \ub77c\uc774\ube0c\ub7ec\ub9ac\ub294 ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),"\ub77c\ub294 \uc0c8\ub85c\uc6b4 \ud0c0\uc785\uc744 \uc81c\uacf5\ud569\ub2c8\ub2e4.\n",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),"\ub294 ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),"\ub098 ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),"\uc640 \uac19\uc774 kind\uac00 ",(0,i.kt)("inlineCode",{parentName:"p"},"* -> *"),"\uc778 \ud0c0\uc785\uc785\ub2c8\ub2e4.\n",(0,i.kt)("inlineCode",{parentName:"p"},"Int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Bool")," \ub610\ub294 ",(0,i.kt)("inlineCode",{parentName:"p"},"Options"),"\uc640 \uac19\uc740 \uad6c\uccb4\uc801\uc778 \ud0c0\uc785\uc744 \uc81c\uacf5\ud574\uc57c ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),"\ub294 (\uac12\uc744 \uac00\uc9c0\ub294) \uad6c\uccb4\uc801\uc778 \ud0c0\uc785\uc774 \ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Parser a"),"\ub294 \uba85\ub839\uc904 \uc778\uc790\uac00 \uc131\uacf5\uc801\uc73c\ub85c \ud30c\uc2f1\ub41c \uacbd\uc6b0 \ud0c0\uc785 ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),"\uc758 \uac12\uc744 \uc0dd\uc131\ud558\ub294 \uba85\ub839\uc904 \ud30c\uc11c\uc758 \uba85\uc138\ub97c \uc758\ubbf8\ud569\ub2c8\ub2e4.\n\uc774\ub294 ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a"),"\uac00 ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),"\uc758 \uac12\uc744 \uc0dd\uc131\ud558\ub294 \ud504\ub85c\uadf8\ub7a8\uc758 \uba85\uc138\ub97c \uc758\ubbf8\ud558\ub294 \uac83\uacfc \uc720\uc0ac\ud569\ub2c8\ub2e4.\n\uc774 \ub450 \ud0c0\uc785\uc758 \uc8fc\uc694 \ucc28\uc774\uc810\uc740 ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a"),"\ub97c ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),"\ub85c \ubcc0\ud658\ud560 \uc218 \uc5c6\uc9c0\ub9cc\n(\uc6b0\ub9ac\ub294 \ub2e8\uc9c0 IO \uc5f0\uc0b0\uc744 \uc5f0\uacb0\ud558\uace0 Haskell \ub7f0\ud0c0\uc784\uc774 \uadf8\uac83\ub4e4\uc744 \uc2e4\ud589\ud558\uac8c \ud569\ub2c8\ub2e4),\n",(0,i.kt)("inlineCode",{parentName:"p"},"Parser a"),"\ub97c \ud504\ub85c\uadf8\ub7a8 \uc778\uc790\ub97c \uc758\ubbf8\ud558\ub294 \ubb38\uc790\uc5f4 \ubaa9\ub85d\uc744 \ubc1b\uace0 \uc778\uc790\ub97c \ud30c\uc2f1\ud560 \uc218 \uc788\uc73c\uba74 ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),"\ub97c \uc0dd\uc131\ud558\ub294 \ud568\uc218\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\ub2e4\ub294 \uac83\uc785\ub2c8\ub2e4."),(0,i.kt)("p",null,"\uc774\uc804 EDSL\uacfc \ub9c8\ucc2c\uac00\uc9c0\ub85c, \uc774 \ub77c\uc774\ube0c\ub7ec\ub9ac\ub294 ",(0,i.kt)("em",{parentName:"p"},"\uc870\ud569\uc790 \ud328\ud134"),"\uc744 \uc0ac\uc6a9\ud569\ub2c8\ub2e4.\n\uc6b0\ub9ac\ub294 \ud30c\uc11c\ub97c \ub9cc\ub4e4\uae30 \uc704\ud55c \uc6d0\uc2dc\uac12\ub4e4\uacfc \uc791\uc740 \ud30c\uc11c\ub97c \ud070 \ud30c\uc11c\ub85c \uc870\ud569\ud558\ub294 \ubc29\ubc95\uc744 \uc775\ud600\uc57c \ud569\ub2c8\ub2e4."),(0,i.kt)("p",null,"\uc791\uc740 \ud30c\uc11c\uc758 \uc608\uc81c\ub97c \uc0b4\ud3b4\ubd05\uc2dc\ub2e4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'inp :: Parser FilePath\ninp =\n  strOption\n    ( long "input"\n      <> short \'i\'\n      <> metavar "FILE"\n      <> help "Input file"\n    )\n\nout :: Parser FilePath\nout =\n  strOption\n    ( long "output"\n      <> short \'o\'\n      <> metavar "FILE"\n      <> help "Output file"\n    )\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"strOption"),"\ub294 \ud30c\uc11c\ub97c \ub9cc\ub4dc\ub294 \ud568\uc218\uc785\ub2c8\ub2e4. \uc774 \ud568\uc218\ub294 \uc778\uc790\ub85c \uc870\ud569\ub41c ",(0,i.kt)("em",{parentName:"p"},"\uc635\uc158 \uc218\uc815\uc790"),"\ub97c \ubc1b\uc544 \ubb38\uc790\uc5f4\uc744 \ud30c\uc2f1\ud558\ub294 \ud30c\uc11c\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4.\n\ud0c0\uc785\uc744 ",(0,i.kt)("inlineCode",{parentName:"p"},"FilePath"),"\ub85c \uc9c0\uc815\ud560 \uc218\ub3c4 \uc788\ub294\ub370, ",(0,i.kt)("inlineCode",{parentName:"p"},"FilePath"),"\uac00 ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),"\uc758 \ubcc4\uce6d\uc774\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4.\n\ud30c\uc11c \ube4c\ub354\ub294 \uac12\uc744 \ud30c\uc2f1\ud558\ub294 \ubc29\ubc95\uc744 \uc124\uba85\ud558\uace0, \uc218\uc815\uc790\ub294 \ud50c\ub798\uadf8 \uc774\ub984, \ud50c\ub798\uadf8 \uc774\ub984\uc758 \uc57d\uc5b4, \uc0ac\uc6a9\ubc95 \ubc0f \ub3c4\uc6c0\ub9d0 \uba54\uc2dc\uc9c0\uc5d0 \ub300\ud55c \ub0b4\uc6a9\uacfc \uac19\uc740 \uc18d\uc131\uc744 \uc124\uba85\ud569\ub2c8\ub2e4."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\uc0ac\uc2e4 ",(0,i.kt)("inlineCode",{parentName:"p"},"strOption"),"\ub294 ",(0,i.kt)("inlineCode",{parentName:"p"},"IsString")," \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud558\ub294 \uc5b4\ub5a4 \ubb38\uc790\uc5f4 \ud0c0\uc785\uc774\ub77c\ub3c4 \ubc18\ud658\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\uadf8 \uc608\ub85c ",(0,i.kt)("inlineCode",{parentName:"p"},"text")," \ud328\ud0a4\uc9c0\uc5d0\uc11c \uac00\uc838\uc628 \ud6e8\uc52c \ud6a8\uc728\uc801\uc778 \uc720\ub2c8\ucf54\ub4dc \ud14d\uc2a4\ud2b8 \ud0c0\uc785\uc778 ",(0,i.kt)("inlineCode",{parentName:"p"},"Text"),"\uac00 \uc788\uc2b5\ub2c8\ub2e4.\n",(0,i.kt)("inlineCode",{parentName:"p"},"String"),"\uc740 ",(0,i.kt)("inlineCode",{parentName:"p"},"Char"),"\uc758 \ub9c1\ud06c\ub4dc \ub9ac\uc2a4\ud2b8\ub85c \uad6c\ud604\ub418\uc9c0\ub9cc, ",(0,i.kt)("inlineCode",{parentName:"p"},"Text"),"\ub294 \ubc14\uc774\ud2b8 \ubc30\uc5f4\ub85c \uad6c\ud604\ub418\uae30 \ub54c\ubb38\uc5d0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Text"),"\uac00 \ub354 \ud6a8\uc728\uc801\uc785\ub2c8\ub2e4.\n\ud14d\uc2a4\ud2b8 \uac12\uc744 \uc704\ud574 ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," \ub300\uc2e0 ",(0,i.kt)("inlineCode",{parentName:"p"},"Text"),"\ub97c \uc0ac\uc6a9\ud558\ub294\uac8c \uc88b\uc2b5\ub2c8\ub2e4.\n\uc9c0\uae08\uae4c\uc9c0\ub294 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uc558\ub294\ub370 \uc774\ub294 ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),"\ubcf4\ub2e4 \uc57d\uac04 \uc0ac\uc6a9\ud558\uae30 \ubd88\ud3b8\ud558\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4.\n\ud558\uc9c0\ub9cc \ud14d\uc2a4\ud2b8\ub97c \ud45c\ud604\ud560\ub54c \ub9ce\uc774 \uc0ac\uc6a9\ud558\ub294 \ud0c0\uc785\uc785\ub2c8\ub2e4!")),(0,i.kt)("p",null,"\ubcf4\uc2dc\ub2e4\uc2dc\ud53c, \uc218\uc815\uc790\ub294 ",(0,i.kt)("inlineCode",{parentName:"p"},"<>")," \ud568\uc218\ub97c \uc0ac\uc6a9\ud558\uc5ec \ud569\uc131\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\uc989, \uc218\uc815\uc790\ub294 ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup")," \ud0c0\uc785\ud074\ub798\uc2a4\uc758 \uc778\uc2a4\ud134\uc2a4\ub97c \uad6c\ud604\ud588\ub2e4\ub294 \uac83\uc744 \uc758\ubbf8\ud569\ub2c8\ub2e4!"),(0,i.kt)("p",null,"\uc774\ub7ec\ud55c \uc778\ud130\ud398\uc774\uc2a4\ub85c \uc778\ud574, \uc6b0\ub9ac\ub294 \ubaa8\ub4e0 \uc218\uc815\uc790 \uc635\uc158\uc744 \uc81c\uacf5\ud560 \ud544\uc694\uac00 \uc5c6\uc774 \ud544\uc694\ud55c \ud56d\ubaa9\ub9cc \uc81c\uacf5\ud558\uba74 \ub429\ub2c8\ub2e4.\n\ub530\ub77c\uc11c \uc6b0\ub9ac\uac00 \uc9e7\uc740 \ud50c\ub798\uadf8 \uc774\ub984\uc744 \uac00\uc9c0\uace0 \uc2f6\uc9c0 \uc54a\ub2e4\uba74, \ucd94\uac00\ud560 \ud544\uc694\uac00 \uc5c6\uc2b5\ub2c8\ub2e4."),(0,i.kt)("h4",{id:"functor"},"Functor"),(0,i.kt)("p",null,"\uc6b0\ub9ac\uac00 \uc815\uc758\ud55c \ub370\uc774\ud130 \ud0c0\uc785\uc744 \uc704\ud574, ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser FilePath"),"\ub97c \uc815\uc758\ud588\ub2e4\ub294 \uac83\uc740\n\uc6b0\ub9ac\uac00 \uc6d0\ud558\ub294 \ubc29\ud5a5\uc73c\ub85c \ud070 \ud30c\uc11c\ub97c \ub9cc\ub4e4 \uc218 \uc788\ub294 \uc88b\uc740 \uc2dc\uc791\uc774\uc9c0\ub9cc, ",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertSingle"),"\uc5d0 \ud544\uc694\ud55c \uac83\uc740 \uc544\ub2d9\ub2c8\ub2e4.\n",(0,i.kt)("inlineCode",{parentName:"p"},"SingleInput"),"\uacfc ",(0,i.kt)("inlineCode",{parentName:"p"},"SingleOutput"),"\uc744 \uc704\ud55c ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),"\uac00 \ud544\uc694\ud569\ub2c8\ub2e4.\n\ub9cc\uc57d ",(0,i.kt)("inlineCode",{parentName:"p"},"FilePath"),"\uac00 \uc788\ub2e4\uba74, ",(0,i.kt)("inlineCode",{parentName:"p"},"InputFile")," \uc0dd\uc131\uc790\ub97c \uc0ac\uc6a9\ud558\uc5ec ",(0,i.kt)("inlineCode",{parentName:"p"},"SingleInput"),"\uc73c\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n",(0,i.kt)("inlineCode",{parentName:"p"},"InputFile"),"\ub3c4 \ud568\uc218\ub77c\ub294 \uac83\uc744 \uae30\uc5b5\ud558\uc138\uc694:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"InputFile :: FilePath -> SingleInput\nOutputFile :: FilePath -> SingleOutput\n")),(0,i.kt)("p",null,"\uadf8\ub7ec\ub098 \ud30c\uc11c\ub97c \ubcc0\ud658\ud558\ub824\uba74 \ub2e4\uc74c\uacfc \uac19\uc740 \ud0c0\uc785\uc758 \ud568\uc218\uac00 \ud544\uc694\ud569\ub2c8\ub2e4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"f :: Parser FilePath -> Parser SingleInput\ng :: Parser FilePath -> Parser SingleOutput\n")),(0,i.kt)("p",null,"\ub2e4\ud589\ud788\ub3c4, ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser")," \uc778\ud130\ud398\uc774\uc2a4\ub294 ",(0,i.kt)("inlineCode",{parentName:"p"},"FilePath -> SingleInput"),'\uc640 \uac19\uc740 \ud568\uc218\ub97c "lift"\ud558\ub294 \ud568\uc218\ub97c \uc81c\uacf5\ud569\ub2c8\ub2e4.\n\uc989 ',(0,i.kt)("inlineCode",{parentName:"p"},"Parser FilePath -> Parser SingleInput"),"\uc640 \uac19\uc740 \ud0c0\uc785\uc758 \ud568\uc218\ub97c \ub9cc\ub4e4\uc5b4\uc90d\ub2c8\ub2e4.\n\uc774 \ud568\uc218\ub294 \uc5b4\ub5a0\ud55c \uc785\ub825\uacfc \ucd9c\ub825 \ubaa8\ub450\uc5d0 \ub300\ud574 \uc791\ub3d9\ud558\uae30\uc5d0 ",(0,i.kt)("inlineCode",{parentName:"p"},"a -> b")," \ud0c0\uc785\uc758 \ud568\uc218\uac00 \uc788\ub2e4\uba74\n\uc778\uc790\ub85c \uc804\ub2ec\ud574 ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser a -> Parser b")," \ud0c0\uc785\uc758 \uc0c8 \ud568\uc218\ub97c \uc5bb\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,i.kt)("p",null,"\uc774\ub7ec\ud55c \ud568\uc218\ub97c ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),"\uc774\ub77c\uace0 \ubd80\ub985\ub2c8\ub2e4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"fmap :: (a -> b) -> Parser a -> Parser b\n\n-- \ub610\ub294 \uc911\uc704 \ud45c\uae30\ubc95\uc73c\ub85c\n(<$>)  :: (a -> b) -> Parser a -> Parser b\n")),(0,i.kt)("p",null,"\uc6b0\ub9ac\ub294 \uc774\uc804\uc5d0 \ub2e4\ub978 \ud0c0\uc785\uc758 \uc778\ud130\ud398\uc774\uc2a4\uc5d0\uc11c ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),"\uc744 \ubcf4\uc558\uc2b5\ub2c8\ub2e4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"fmap :: (a -> b) -> [a] -> [b]\n\nfmap :: (a -> b) -> IO a -> IO b\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),"\uc740 ",(0,i.kt)("inlineCode",{parentName:"p"},"<>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"show"),"\uc640 \uac19\uc740 \ud0c0\uc785\ud074\ub798\uc2a4 \ud568\uc218\uc785\ub2c8\ub2e4.\n\uc774\ub294 ",(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Functor.html#t:Functor"},(0,i.kt)("inlineCode",{parentName:"a"},"Functor")),"\ub77c\ub294 \ud0c0\uc785\ud074\ub798\uc2a4\uc5d0 \uc18d\ud569\ub2c8\ub2e4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"class Functor f where\n  fmap :: (a -> b) -> f a -> f b\n")),(0,i.kt)("p",null,"\uadf8\ub9ac\uace0 \ub2e4\uc74c\uacfc \uac19\uc740 \ubc95\uce59\uc774 \uc788\uc2b5\ub2c8\ub2e4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"-- 1. \ud56d\ub4f1 \ubc95\uce59:\n--    \uac12\ub4e4\uc744 \ubcc0\uacbd\ud558\uc9c0 \uc54a\uc73c\uba74 \uc544\ubb34\uac83\ub3c4 \ubcc0\uacbd\ub418\uc9c0 \uc54a\uc544\uc57c \ud569\ub2c8\ub2e4.\nfmap id = id\n\n-- 2. \ud569\uc131 \ubc95\uce59:\n--    lift\ud55c \ud568\uc218\ub97c \ud569\uc131\ud558\ub294 \uac83\uc740 fmap\uc73c\ub85c lift\ud55c \ud568\uc218\ub97c \ud569\uc131\ud558\ub294 \uac83\uacfc \uac19\uc2b5\ub2c8\ub2e4.\nfmap (f . g) == fmap f . fmap g\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),"\uc744 \uad6c\ud604\ud558\uace0 \uc704 \ubc95\uce59\uc744 \ub530\ub974\ub294 \ud0c0\uc785\uc740 ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor"),"\uc758 \uc778\uc2a4\ud134\uc2a4\uac00 \ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"f"),"\uc758 kind\uac00 ",(0,i.kt)("inlineCode",{parentName:"p"},"* -> *"),"\ub77c\ub294 \uac83\uc744 \uae30\uc5b5\ud558\uc138\uc694.\n",(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),"\uc758 \ud0c0\uc785 \uc2dc\uadf8\ub2c8\ucc98\ub97c \ud1b5\ud574 ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),"\uc758 kind\ub97c \ucd94\ub860\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,i.kt)("ol",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"a"),"\uc640 ",(0,i.kt)("inlineCode",{parentName:"li"},"b"),"\uc758 kind\ub294 ",(0,i.kt)("inlineCode",{parentName:"li"},"*"),"\uc785\ub2c8\ub2e4. \uc65c\ub0d0\ud558\uba74 \ud568\uc218\uc758 \uc778\uc790/\ubc18\ud658 \ud0c0\uc785\uc73c\ub85c \uc0ac\uc6a9\ub418\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"f a"),"\uc758 kind\ub294 ",(0,i.kt)("inlineCode",{parentName:"li"},"*"),"\uc785\ub2c8\ub2e4. \uc65c\ub0d0\ud558\uba74 \ud568\uc218\uc758 \uc778\uc790\ub85c \uc0ac\uc6a9\ub418\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4."),(0,i.kt)("li",{parentName:"ol"},"\uadf8\ub7ec\ubbc0\ub85c ",(0,i.kt)("inlineCode",{parentName:"li"},"f"),"\uc758 kind\ub294 ",(0,i.kt)("inlineCode",{parentName:"li"},"* -> *"),"\uc785\ub2c8\ub2e4."))),(0,i.kt)("p",null,"\ub370\uc774\ud130 \ud0c0\uc785 \ud558\ub098\ub97c \uc120\ud0dd\ud574 ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," \uc778\uc2a4\ud134\uc2a4\ub97c \uad6c\ud604\ud574\ubd05\uc2dc\ub2e4.\n\uba3c\uc800 ",(0,i.kt)("inlineCode",{parentName:"p"},"* -> *")," kind\ub97c \uac00\uc9c4 \ub370\uc774\ud130 \ud0c0\uc785\uc744 \uc120\ud0dd\ud574\uc57c \ud569\ub2c8\ub2e4. ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),"\uac00 \uc801\ud569\ud569\ub2c8\ub2e4.\n\uc774\uc81c ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap :: (a -> b) -> Maybe a -> Maybe b")," \ud568\uc218\ub97c \uad6c\ud604\ud574\uc57c \ud569\ub2c8\ub2e4.\n\ub2e4\uc74c\uc740 \ub9e4\uc6b0 \uac04\ub2e8\ud558\uace0 (\uadf8\ub9ac\uace0 \uc798\ubabb\ub41c) \uad6c\ud604\uc785\ub2c8\ub2e4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"mapMaybe :: (a -> b) -> Maybe a -> Maybe b\nmapMaybe func maybeX = Nothing\n")),(0,i.kt)("p",null,"\ud55c \ubc88 \ucef4\ud30c\uc77c\ud574\ubcf4\uc138\uc694! \uc131\uacf5\uc801\uc73c\ub85c \ucef4\ud30c\uc77c\ub429\ub2c8\ub2e4! \ud558\uc9c0\ub9cc \ubd88\ud589\ud558\uac8c\ub3c4 \uccab \ubc88\uc9f8 \ubc95\uce59\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.\n",(0,i.kt)("inlineCode",{parentName:"p"},"fmap id = id"),"\ub294 ",(0,i.kt)("inlineCode",{parentName:"p"},"mapMaybe id (Just x) == Just x"),"\ub97c \uc758\ubbf8\ud569\ub2c8\ub2e4.\n\uadf8\ub7ec\ub098 \uc815\uc758\uc5d0\uc11c ",(0,i.kt)("inlineCode",{parentName:"p"},"mapMaybe id (Just x) == Nothing"),"\uc774\ub77c\ub294 \uac83\uc744 \uba85\ud655\ud788 \uc54c \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,i.kt)("p",null,"\uc774\ub294 \ud558\uc2a4\ucf08\uc774 \ubc95\uce59\uc744 \ub9cc\uc871\ud560 \uc218 \uc788\uac8c \ubcf4\uc7a5\ud574\uc8fc\uc9c0 \uc54a\ub294\ub2e4\ub294 \uac83\uacfc \uc774\ub7ec\ud55c \ubc95\uce59\uc774 \uc911\uc694\ud558\ub2e4\ub294 \uac83\uc744 \ubcf4\uc5ec\uc90d\ub2c8\ub2e4.\n\ubc95\uce59\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\ub294 ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," \uc778\uc2a4\ud134\uc2a4\ub294 \uc6b0\ub9ac\uac00 \uae30\ub300\ud558\ub294 \uac83\uacfc \ub2e4\ub974\uac8c \ub3d9\uc791\ud560 \uac83\uc785\ub2c8\ub2e4.\n\ub2e4\uc2dc \ud55c \ubc88 \uc2dc\ub3c4\ud574\ubd05\uc2dc\ub2e4!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"mapMaybe :: (a -> b) -> Maybe a -> Maybe b\nmapMaybe func maybeX =\n  case maybeX of\n    Nothing -> Nothing\n    Just x -> Just (func x)\n")),(0,i.kt)("p",null,"\uc774 ",(0,i.kt)("inlineCode",{parentName:"p"},"mapMaybe"),"\ub294 \ubc95\uce59\uc744 \ub9cc\uc871\ud569\ub2c8\ub2e4. \uc774\ub294 \ub300\uc218\ud559\uc744 \ud1b5\ud574 \uc99d\uba85\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\ub9cc\uc57d \uce58\ud658\uc744 \ud1b5\ud574 \ub4f1\uc2dd\uc758 \ud55c\ucabd\uc5d0\uc11c \ub2e4\ub978 \ucabd\uc73c\ub85c \ub3c4\ub2ec\ud560 \uc218 \uc788\ub2e4\uba74, \ubc95\uce59\uc740 \uc131\ub9bd\ud569\ub2c8\ub2e4.")),(0,i.kt)("p",null,"Functor\ub294 \ub9e4\uc6b0 \uc911\uc694\ud55c \ud0c0\uc785\ud074\ub798\uc2a4\uc774\uba70, \ub9ce\uc740 \ud0c0\uc785\uc774 \uc774 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud569\ub2c8\ub2e4.\n\uc6b0\ub9ac\uac00 \uc54c\uace0 \uc788\ub294 \uac83\ucc98\ub7fc, ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser")," \ubaa8\ub450 ",(0,i.kt)("inlineCode",{parentName:"p"},"* -> *"),' kind\ub97c \uac00\uc9c0\uba70\n\uadf8\ub4e4\uc758 "payload" \ud0c0\uc785\uc5d0 \ub300\ud574 ',(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),"\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\uc885\uc885 \uc0ac\ub78c\ub4e4\uc740 \ud0c0\uc785\ud074\ub798\uc2a4\uac00 \ubb34\uc5c7\uc744 \uc758\ubbf8\ud558\ub294\uc9c0\uc5d0 \ub300\ud55c \ube44\uc720\ub098 \uc740\uc720\ub97c \ucc3e\uc73c\ub824\uace0 \ud569\ub2c8\ub2e4.\n\ud558\uc9c0\ub9cc Functor`\uc640 \uac19\uc740 \uc7ac\ubbf8\uc788\ub294 \uc774\ub984\uc758 \ud0c0\uc785\ud074\ub798\uc2a4\ub294 \uc77c\ubc18\uc801\uc73c\ub85c \ubaa8\ub4e0 \uacbd\uc6b0\uc5d0 \uc801\ud569\ud55c\n\ube44\uc720\ub098 \uc740\uc720\ub97c \uac00\uc9c0\uace0 \uc788\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \uc740\uc720\ub97c \ud3ec\uae30\ud558\uace0 \ubc95\uce59\uc744 \uac00\uc9c4 \uc778\ud130\ud398\uc774\uc2a4\ub85c \uadf8 \uc790\uccb4\ub85c \uc0dd\uac01\ud558\ub294 \uac83\uc774 \ub354 \uc27d\uc2b5\ub2c8\ub2e4.")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),"\uc5d0 \ub300\ud574 ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),"\uc744 \uc0ac\uc6a9\ud574, ",(0,i.kt)("inlineCode",{parentName:"p"},"FilePath"),"\ub97c \ubc18\ud658\ud558\ub294 \ud30c\uc11c\ub97c ",(0,i.kt)("inlineCode",{parentName:"p"},"SingleInput")," \ub610\ub294 ",(0,i.kt)("inlineCode",{parentName:"p"},"SingleOutput"),"\uc744 \ubc18\ud658\ud558\ub294 \ud30c\uc11c\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'pInputFile :: Parser SingleInput\npInputFile = fmap InputFile parser\n  where\n    parser =\n      strOption\n        ( long "input"\n          <> short \'i\'\n          <> metavar "FILE"\n          <> help "Input file"\n        )\n\npOutputFile :: Parser SingleOutput\npOutputFile = OutputFile <$> parser -- fmap \uacfc <$> \ub294 \uac19\uc740 \uc758\ubbf8\uc785\ub2c8\ub2e4.\n  where\n    parser =\n      strOption\n        ( long "output"\n          <> short \'o\'\n          <> metavar "FILE"\n          <> help "Output file"\n        )\n')),(0,i.kt)("h4",{id:"applicative"},"Applicative"),(0,i.kt)("p",null,"Now that we have two parsers,\n",(0,i.kt)("inlineCode",{parentName:"p"},"pInputFile :: Parser SingleInput"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"pOutputFile :: Parser SingleOutput"),",\nwe want to ",(0,i.kt)("em",{parentName:"p"},"combine")," them as ",(0,i.kt)("inlineCode",{parentName:"p"},"Options"),". Again, if we only had\n",(0,i.kt)("inlineCode",{parentName:"p"},"SingleInput")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"SingleOutput"),", we could use the constructor ",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertSingle"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"ConvertSingle :: SingleInput -> SingleOutput -> Options\n")),(0,i.kt)("p",null,"Can we do a similar trick to the one we saw before with ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),"?\nDoes a function exist that can lift a binary function to work\non ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),"s instead? One with this type signature:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"???\n  :: (SingleInput -> SingleOutput -> Options)\n  -> (Parser SingleInput -> Parser SingleOutput -> Parser Options)\n")),(0,i.kt)("p",null,"Yes. This function is called ",(0,i.kt)("inlineCode",{parentName:"p"},"liftA2")," and it is from the ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative"),"\ntype class. ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative")," (also known as applicative functor) has three\nprimary functions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"class Functor f => Applicative f where\n  pure :: a -> f a\n  liftA2 :: (a -> b -> c) -> f a -> f b -> f c\n  (<*>) :: f (a -> b) -> f a -> f b\n")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Applicative.html#t:Applicative"},(0,i.kt)("inlineCode",{parentName:"a"},"Applicative")),"\nis another very popular type class with many instances."),(0,i.kt)("p",null,"Just like any ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup"),", any ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative"),"\nis a ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor"),". This means that any type that wants to implement\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative")," interface should also implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," interface."),(0,i.kt)("p",null,"Beyond what a regular functor can do, which is to lift a function over\na certain ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", applicative functors allow us to apply a function to\n",(0,i.kt)("em",{parentName:"p"},"multiple instances")," of a certain ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),', as well as "lift" any value of type ',(0,i.kt)("inlineCode",{parentName:"p"},"a")," into an ",(0,i.kt)("inlineCode",{parentName:"p"},"f a"),"."),(0,i.kt)("p",null,"You should already be familiar with ",(0,i.kt)("inlineCode",{parentName:"p"},"pure"),", we've seen it when we\ntalked about ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),". For ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"pure")," lets us create an ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," action\nwith a specific return value without doing IO.\nWith ",(0,i.kt)("inlineCode",{parentName:"p"},"pure")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),", we can create a ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser")," that when run\nwill return a specific value as output without doing any parsing."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"liftA2")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<*>")," are two functions that can be implemented in\nterms of one another. ",(0,i.kt)("inlineCode",{parentName:"p"},"<*>")," is actually the more useful one between\nthe two. Because when combined with ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap")," (or rather the infix version ",(0,i.kt)("inlineCode",{parentName:"p"},"<$>"),"),\nit can be used to apply a function with many arguments, instead of just two."),(0,i.kt)("p",null,"To combine our two parsers to one, we can use either ",(0,i.kt)("inlineCode",{parentName:"p"},"liftA2")," or\na combination of ",(0,i.kt)("inlineCode",{parentName:"p"},"<$>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<*>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"-- with liftA2\npConvertSingle :: Parser Options\npConvertSingle =\n  liftA2 ConvertSingle pInputFile pOutputFile\n\n-- with <$> and <*>\npConvertSingle :: Parser Options\npConvertSingle =\n  ConvertSingle <$> pInputFile <*> pOutputFile\n")),(0,i.kt)("p",null,"Note that both ",(0,i.kt)("inlineCode",{parentName:"p"},"<$>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<*>")," associate to the left,\nso we have invisible parenthesis that look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"pConvertSingle :: Parser Options\npConvertSingle =\n  (ConvertSingle <$> pInputFile) <*> pOutputFile\n")),(0,i.kt)("p",null,"Let's take a deeper look at the types of the sub-expressions\nwe have here, to prove that this type-checks:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"pConvertSingle :: Parser Options\n\npInputFile :: Parser SingleInput\npOutputFile :: Parser SingleOutput\n\nConvertSingle :: SingleInput -> SingleOutput -> Options\n\n(<$>) :: (a -> b) -> Parser a -> Parser b\n  -- Specifically, here `a` is `SingleInput`\n  -- and `b` is `SingleOutput -> Options`,\n\nConvertSingle <$> pInputFile :: Parser (SingleOutput -> Options)\n\n(<*>) :: Parser (a -> b) -> Parser a -> Parser b\n  -- Specifically, here `a -> b` is `SingleOutput -> Options`\n  -- so `a` is `SingleOutput` and `b` is `Options`\n\n-- So we get:\n(ConvertSingle <$> pInputFile) <*> pOutputFile :: Parser Options\n")),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"<$>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<*>")," we can chain as many parsers (or any applicative really)\nas we want. This is because of two things: currying and parametric polymorphism.\nBecause functions in Haskell take exactly one argument and return exactly one,\nany multiple argument function can be represented as ",(0,i.kt)("inlineCode",{parentName:"p"},"a -> b"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"You can find the laws for the applicative functors in this article called\n",(0,i.kt)("a",{parentName:"p",href:"https://wiki.haskell.org/Typeclassopedia#Laws_2"},"Typeclassopedia"),", which\ntalks about various useful type classes and their laws.")),(0,i.kt)("p",null,"Applicative functor is a very important concept and will appear in various\nparser interfaces (not just for command-line arguments, but also JSON\nparsers and general parsers), I/O, concurrency, non-determinism, and more.\nThe reason this library is called optparse-applicative is because\nit uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative")," interface as the main API for\nconstructing parsers."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Exercise"),": create a similar interface for the ",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertDir")," constructor of ",(0,i.kt)("inlineCode",{parentName:"p"},"Options"),"."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'pInputDir :: Parser FilePath\npInputDir =\n  strOption\n    ( long "input"\n      <> short \'i\'\n      <> metavar "DIRECTORY"\n      <> help "Input directory"\n    )\n\npOutputDir :: Parser FilePath\npOutputDir =\n  strOption\n    ( long "output"\n      <> short \'o\'\n      <> metavar "DIRECTORY"\n      <> help "Output directory"\n    )\n\npConvertDir :: Parser Options\npConvertDir =\n  ConvertDir <$> pInputDir <*> pOutputDir\n'))),(0,i.kt)("hr",null),(0,i.kt)("h4",{id:"alternative"},"Alternative"),(0,i.kt)("p",null,"One thing we forgot about is that each input and output for\n",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertSingle")," could also potentially use the standard input and output instead.\nUp until now we only offered one option: reading from or writing to a file\nby specifying the flags ",(0,i.kt)("inlineCode",{parentName:"p"},"--input")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"--output"),".\nHowever, we'd like to make these flags optional, and when they are\nnot specified, use the alternative standard i/o. We can do that by using\nthe function ",(0,i.kt)("inlineCode",{parentName:"p"},"optional")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"Control.Applicative"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"optional :: Alternative f => f a -> f (Maybe a)\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"optional")," works on types which implement instances of the\n",(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Applicative.html#t:Alternative"},(0,i.kt)("inlineCode",{parentName:"a"},"Alternative"))," type class:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"class Applicative f => Alternative f where\n  (<|>) :: f a -> f a -> f a\n  empty :: f a\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Alternative")," looks very similar to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid")," type class,\nbut it works on applicative functors. This type class isn't\nvery common and is mostly used for parsing libraries as far as I know.\nIt provides us with an interface to combine two ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),"s -\nif the first one fails to parse, try the other.\nIt also provides other useful functions such as ",(0,i.kt)("inlineCode",{parentName:"p"},"optional"),",\nwhich will help us with our case:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"pSingleInput :: Parser SingleInput\npSingleInput =\n  fromMaybe Stdin <$> optional pInputFile\n\npSingleOutput :: Parser SingleOutput\npSingleOutput =\n  fromMaybe Stdout <$> optional pOutputFile\n")),(0,i.kt)("p",null,"Note that with ",(0,i.kt)("inlineCode",{parentName:"p"},"fromMaybe :: a -> Maybe a -> a")," we can extract\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," out of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," by supplying a value for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing")," case."),(0,i.kt)("p",null,"Now we can use these more appropriate functions in ",(0,i.kt)("inlineCode",{parentName:"p"},"pConvertSingle")," instead:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"pConvertSingle :: Parser Options\npConvertSingle =\n  ConvertSingle <$> pSingleInput <*> pSingleOutput\n")),(0,i.kt)("h4",{id:"commands-and-subparsers"},"Commands and subparsers"),(0,i.kt)("p",null,"We currently have two possible operations in our interface,\nconvert a single source, or convert a directory. A nice interface for\nselecting the right operation would be via commands.\nIf the user would like to convert a single source, they can use\n",(0,i.kt)("inlineCode",{parentName:"p"},"convert"),", for a directory, ",(0,i.kt)("inlineCode",{parentName:"p"},"convert-dir"),"."),(0,i.kt)("p",null,"We can create a parser with commands with the ",(0,i.kt)("inlineCode",{parentName:"p"},"subparser")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"command"),"\nfunctions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"subparser :: Mod CommandFields a -> Parser a\n\ncommand :: String -> ParserInfo a -> Mod CommandFields a\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"subparser")," takes ",(0,i.kt)("em",{parentName:"p"},"command modifiers")," (which can be constructed\nwith the ",(0,i.kt)("inlineCode",{parentName:"p"},"command")," function) as input, and produces a ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),".\n",(0,i.kt)("inlineCode",{parentName:"p"},"command"),' takes the command name (in our case "convert" or "convert-dir")\nand a ',(0,i.kt)("inlineCode",{parentName:"p"},"ParserInfo a"),", and produces a command modifier. As we've seen\nbefore these modifiers have a ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid")," instance and they can be\ncomposed, meaning that we can append multiple commands to serve as alternatives."),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"ParserInfo a")," can be constructed with the ",(0,i.kt)("inlineCode",{parentName:"p"},"info")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"info :: Parser a -> InfoMod a -> ParserInfo a\n")),(0,i.kt)("p",null,"This function wraps a ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser")," with some additional information\nsuch as a helper message, description, and more, so that the program\nitself and each sub command can print some additional information."),(0,i.kt)("p",null,"Let's see how to construct a ",(0,i.kt)("inlineCode",{parentName:"p"},"ParserInfo"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'pConvertSingleInfo :: ParserInfo Options\npConvertSingleInfo =\n  info\n    (helper <*> pConvertSingle)\n    (progDesc "Convert a single markup source to html")\n')),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"helper")," adds a helper output screen in case the parser fails."),(0,i.kt)("p",null,"Let's also build a command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'pConvertSingleCommand :: Mod CommandFields Options\npConvertSingleCommand =\n  command "convert" pConvertSingleInfo\n')),(0,i.kt)("p",null,"Try creating a ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser Options")," combining the two options with ",(0,i.kt)("inlineCode",{parentName:"p"},"subparser"),"."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'pOptions :: Parser Options\npOptions =\n  subparser\n    ( command\n      "convert"\n      ( info\n        (helper <*> pConvertSingle)\n        (progDesc "Convert a single markup source to html")\n      )\n      <> command\n      "convert-dir"\n      ( info\n        (helper <*> pConvertDir)\n        (progDesc "Convert a directory of markup files to html")\n      )\n    )\n'))),(0,i.kt)("h4",{id:"parserinfo"},"ParserInfo"),(0,i.kt)("p",null,"Since we finished building a parser, we should wrap it up in a ",(0,i.kt)("inlineCode",{parentName:"p"},"ParserInfo"),"\nand add some information to it to make it ready to run:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'opts :: ParserInfo Options\nopts =\n  info (helper <*> pOptions)\n    ( fullDesc\n      <> header "hs-blog-gen - a static blog generator"\n      <> progDesc "Convert markup files or directories to html"\n    )\n')),(0,i.kt)("h3",{id:"running-a-parser"},"Running a parser"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"optparse-applicative")," provides a non-",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," interface to parse arguments,\nbut the most convenient way to use it is to let it take care of fetching\nprogram arguments, try to parse them, and throw errors and help messages in case\nit fails. This can be done with the function ",(0,i.kt)("inlineCode",{parentName:"p"},"execParser :: ParserInfo a -> IO a"),"."),(0,i.kt)("p",null,"We can place all this options parsing stuff in a new module\nand then import it from ",(0,i.kt)("inlineCode",{parentName:"p"},"app/Main.hs"),". Let's do that.\nHere's what we have up until now:"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"app/OptParse.hs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'-- | Command-line options parsing\n\nmodule OptParse\n  ( Options(..)\n  , SingleInput(..)\n  , SingleOutput(..)\n  , parse\n  )\n  where\n\nimport Data.Maybe (fromMaybe)\nimport Options.Applicative\n\n------------------------------------------------\n-- * Our command-line options model\n\n-- | Model\ndata Options\n  = ConvertSingle SingleInput SingleOutput\n  | ConvertDir FilePath FilePath\n  deriving Show\n\n-- | A single input source\ndata SingleInput\n  = Stdin\n  | InputFile FilePath\n  deriving Show\n\n-- | A single output sink\ndata SingleOutput\n  = Stdout\n  | OutputFile FilePath\n  deriving Show\n\n------------------------------------------------\n-- * Parser\n\n-- | Parse command-line options\nparse :: IO Options\nparse = execParser opts\n\nopts :: ParserInfo Options\nopts =\n  info (pOptions <**> helper)\n    ( fullDesc\n      <> header "hs-blog-gen - a static blog generator"\n      <> progDesc "Convert markup files or directories to html"\n    )\n\n-- | Parser for all options\npOptions :: Parser Options\npOptions =\n  subparser\n    ( command\n      "convert"\n      ( info\n        (helper <*> pConvertSingle)\n        (progDesc "Convert a single markup source to html")\n      )\n      <> command\n      "convert-dir"\n      ( info\n        (helper <*> pConvertDir)\n        (progDesc "Convert a directory of markup files to html")\n      )\n    )\n\n------------------------------------------------\n-- * Single source to sink conversion parser\n\n-- | Parser for single source to sink option\npConvertSingle :: Parser Options\npConvertSingle =\n  ConvertSingle <$> pSingleInput <*> pSingleOutput\n\n-- | Parser for single input source\npSingleInput :: Parser SingleInput\npSingleInput =\n  fromMaybe Stdin <$> optional pInputFile\n\n-- | Parser for single output sink\npSingleOutput :: Parser SingleOutput\npSingleOutput =\n  fromMaybe Stdout <$> optional pOutputFile\n\n-- | Input file parser\npInputFile :: Parser SingleInput\npInputFile = fmap InputFile parser\n  where\n    parser =\n      strOption\n        ( long "input"\n          <> short \'i\'\n          <> metavar "FILE"\n          <> help "Input file"\n        )\n\n-- | Output file parser\npOutputFile :: Parser SingleOutput\npOutputFile = OutputFile <$> parser\n  where\n    parser =\n      strOption\n        ( long "output"\n          <> short \'o\'\n          <> metavar "FILE"\n          <> help "Output file"\n        )\n\n------------------------------------------------\n-- * Directory conversion parser\n\npConvertDir :: Parser Options\npConvertDir =\n  ConvertDir <$> pInputDir <*> pOutputDir\n\n-- | Parser for input directory\npInputDir :: Parser FilePath\npInputDir =\n  strOption\n    ( long "input"\n      <> short \'i\'\n      <> metavar "DIRECTORY"\n      <> help "Input directory"\n    )\n\n-- | Parser for output directory\npOutputDir :: Parser FilePath\npOutputDir =\n  strOption\n    ( long "output"\n      <> short \'o\'\n      <> metavar "DIRECTORY"\n      <> help "Output directory"\n    )\n'))),(0,i.kt)("h3",{id:"pattern-matching-on-options"},"Pattern matching on Options"),(0,i.kt)("p",null,"After running the command-line arguments parser, we can pattern match\non our model and call the right functions. Currently, our program\ndoes not expose this kind of API. So let's go to our ",(0,i.kt)("inlineCode",{parentName:"p"},"src/HsBlog.hs"),"\nmodule and change the API. We can delete ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," from that file and\nadd two new functions instead:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"convertSingle :: Html.Title -> Handle -> Handle -> IO ()\n\nconvertDirectory :: FilePath -> FilePath -> IO ()\n")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/System-IO.html#t:Handle"},(0,i.kt)("inlineCode",{parentName:"a"},"Handle")),"\nis an I/O abstraction over file system objects, including ",(0,i.kt)("inlineCode",{parentName:"p"},"stdin")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"stdout"),".\nBefore, we used ",(0,i.kt)("inlineCode",{parentName:"p"},"writeFile")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"getContents")," - these functions either\nget a ",(0,i.kt)("inlineCode",{parentName:"p"},"FilePath")," to open and work on, or they assume the ",(0,i.kt)("inlineCode",{parentName:"p"},"Handle")," is the standard I/O.\nWe can use the explicit versions that take a ",(0,i.kt)("inlineCode",{parentName:"p"},"Handle")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"System.IO")," instead:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"convertSingle :: Html.Title -> Handle -> Handle -> IO ()\nconvertSingle title input output = do\n  content <- hGetContents input\n  hPutStrLn output (process title content)\n")),(0,i.kt)("p",null,"We will leave ",(0,i.kt)("inlineCode",{parentName:"p"},"convertDirectory")," unimplemented for now and implement it in the next chapter."),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"app/Main.hs"),", we will need to pattern match on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Options")," and\nprepare to call the right functions from ",(0,i.kt)("inlineCode",{parentName:"p"},"HsBlog"),"."),(0,i.kt)("p",null,"Let's look at our full ",(0,i.kt)("inlineCode",{parentName:"p"},"app/Main.hs")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"src/HsBlog.hs"),":"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"app/Main.hs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'-- | Entry point for the hs-blog-gen program\n\nmodule Main where\n\nimport OptParse\nimport qualified HsBlog\n\nimport System.Exit (exitFailure)\nimport System.Directory (doesFileExist)\nimport System.IO\n\nmain :: IO ()\nmain = do\n  options <- parse\n  case options of\n    ConvertDir input output ->\n      HsBlog.convertDirectory input output\n\n    ConvertSingle input output -> do\n      (title, inputHandle) <-\n        case input of\n          Stdin ->\n            pure ("", stdin)\n          InputFile file ->\n            (,) file <$> openFile file ReadMode\n\n      outputHandle <-\n        case output of\n          Stdout -> pure stdout\n          OutputFile file -> do\n            exists <- doesFileExist file\n            shouldOpenFile <-\n              if exists\n                then confirm\n                else pure True\n            if shouldOpenFile\n              then\n                openFile file WriteMode\n              else\n                exitFailure\n\n      HsBlog.convertSingle title inputHandle outputHandle\n      hClose inputHandle\n      hClose outputHandle\n\n------------------------------------------------\n-- * Utilities\n\n-- | Confirm user action\nconfirm :: IO Bool\nconfirm =\n  putStrLn "Are you sure? (y/n)" *>\n    getLine >>= \\answer ->\n      case answer of\n        "y" -> pure True\n        "n" -> pure False\n        _ -> putStrLn "Invalid response. use y or n" *>\n          confirm\n'))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"src/HsBlog.hs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'-- HsBlog.hs\nmodule HsBlog\n  ( convertSingle\n  , convertDirectory\n  , process\n  )\n  where\n\nimport qualified HsBlog.Markup as Markup\nimport qualified HsBlog.Html as Html\nimport HsBlog.Convert (convert)\n\nimport System.IO\n\nconvertSingle :: Html.Title -> Handle -> Handle -> IO ()\nconvertSingle title input output = do\n  content <- hGetContents input\n  hPutStrLn output (process title content)\n\nconvertDirectory :: FilePath -> FilePath -> IO ()\nconvertDirectory = error "Not implemented"\n\nprocess :: Html.Title -> String -> String\nprocess title = Html.render . convert title . Markup.parse\n'))),(0,i.kt)("p",null,"We need to make a few small changes to the ",(0,i.kt)("inlineCode",{parentName:"p"},".cabal")," file."),(0,i.kt)("p",null,"First, we need to add the dependency ",(0,i.kt)("inlineCode",{parentName:"p"},"directory")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"executable"),",\nbecause we use the library ",(0,i.kt)("inlineCode",{parentName:"p"},"System.Directory")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"Main"),"."),(0,i.kt)("p",null,"Second, we need to list ",(0,i.kt)("inlineCode",{parentName:"p"},"OptParse")," in the list of modules in\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"executable"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"}," executable hs-blog-gen\n   import: common-settings\n   hs-source-dirs: app\n   main-is: Main.hs\n+  other-modules:\n+    OptParse\n   build-depends:\n       base\n+    , directory\n     , optparse-applicative\n     , hs-blog\n   ghc-options:\n     -O\n")),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"We've learned about a new fancy library called ",(0,i.kt)("inlineCode",{parentName:"p"},"optparse-applicative"),"\nand used it to create a fancier command-line interface in a declarative way.\nSee the result of running ",(0,i.kt)("inlineCode",{parentName:"p"},"hs-blog-gen --help")," (or the equivalent\n",(0,i.kt)("inlineCode",{parentName:"p"},"cabal"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"stack")," commands we discussed in the last chapter):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"hs-blog-gen - a static blog generator\n\nUsage: hs-blog-gen COMMAND\n  Convert markup files or directories to html\n\nAvailable options:\n  -h,--help                Show this help text\n\nAvailable commands:\n  convert                  Convert a single markup source to html\n  convert-dir              Convert a directory of markup files to html\n")),(0,i.kt)("p",null,"Along the way we've learned two powerful new abstractions, ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative"),", as well as revisited an abstraction\ncalled ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid"),". With this library we've seen another example\nof the usefulness of these abstractions for constructing APIs and EDSLs."),(0,i.kt)("p",null,"We will continue to meet these abstractions in the rest of the book."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Bonus exercise"),": Add another flag named ",(0,i.kt)("inlineCode",{parentName:"p"},"--replace")," to indicate that\nif the output file or directory already exists, it's okay to replace them."),(0,i.kt)("hr",null),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"You can view the git commit of\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/commit/d0d76aad632fe3abd8701e44db5ba687e0c7ac96"},"the changes we've made"),"\nand the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/tree/d0d76aad632fe3abd8701e44db5ba687e0c7ac96"},"code up until now"),".")))}d.isMDXComponent=!0}}]);