"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[643],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>d});var r=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,l=function(e,t){if(null==e)return{};var n,r,l={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var u=r.createContext({}),c=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=c(e.components);return r.createElement(u.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},g=r.forwardRef((function(e,t){var n=e.components,l=e.mdxType,a=e.originalType,u=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),p=c(n),g=l,d=p["".concat(u,".").concat(g)]||p[g]||m[g]||a;return n?r.createElement(d,i(i({ref:t},s),{},{components:n})):r.createElement(d,i({ref:t},s))}));function d(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var a=n.length,i=new Array(a);i[0]=g;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o[p]="string"==typeof e?e:l,i[1]=o;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}g.displayName="MDXCreateElement"},7303:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var r=n(7462),l=(n(7294),n(3905));const a={},i="Handling errors and multiple files",o={unversionedId:"errors_and_files/index",id:"errors_and_files/index",title:"Handling errors and multiple files",description:"We have left an unimplemented function last chapter,",source:"@site/docs/06-errors_and_files/index.md",sourceDirName:"06-errors_and_files",slug:"/errors_and_files/",permalink:"/learn-haskell-blog-generator/errors_and_files/",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/06-errors_and_files/index.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Fancy options parsing",permalink:"/learn-haskell-blog-generator/glue/optparse"},next:{title:"Handling errors with Either",permalink:"/learn-haskell-blog-generator/errors_and_files/either"}},u={},c=[{value:"Links in HTML",id:"links-in-html",level:2},{value:"Creating an index page",id:"creating-an-index-page",level:2},{value:"Processing directories",id:"processing-directories",level:2}],s={toc:c},p="wrapper";function m(e){let{components:t,...n}=e;return(0,l.kt)(p,(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"handling-errors-and-multiple-files"},"Handling errors and multiple files"),(0,l.kt)("p",null,"We have left an unimplemented function last chapter,\nand there are a few more things left for us to do to actually call our program a static blog generator.\nWe still need to process multiple files in a directory and create an index landing page with links to other pages."),(0,l.kt)("h2",{id:"links-in-html"},"Links in HTML"),(0,l.kt)("p",null,"Our HTML EDSL currently does not support links or other content modifiers such as bold and italics.\nWe should add these so we can use them when creating an index."),(0,l.kt)("p",null,"Up until now we've passed ",(0,l.kt)("inlineCode",{parentName:"p"},"String")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"Structure")," creating functions such as ",(0,l.kt)("inlineCode",{parentName:"p"},"p_"),"\nand ",(0,l.kt)("inlineCode",{parentName:"p"},"h_"),". Instead, we could create and pass them a new type, ",(0,l.kt)("inlineCode",{parentName:"p"},"Content"),", which\ncan be regular text, links, images, and so on."),(0,l.kt)("hr",null),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Exercise"),": implement what we've just discussed. Follow the compiler errors and refactor what needs refactoring."),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Solution"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"src/Html/Internal.hs"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'module HsBlog.Html.Internal where\n\nimport Numeric.Natural\n\n-- * Types\n\nnewtype Html\n  = Html String\n\nnewtype Structure\n  = Structure String\n\nnewtype Content\n  = Content String\n\ntype Title\n  = String\n\n-- * EDSL\n\nhtml_ :: Title -> Structure -> Html\nhtml_ title content =\n  Html\n    ( el "html"\n      ( el "head" (el "title" (escape title))\n        <> el "body" (getStructureString content)\n      )\n    )\n\n-- * Structure\n\np_ :: Content -> Structure\np_ = Structure . el "p" . getContentString\n\nh_ :: Natural -> Content -> Structure\nh_ n = Structure . el ("h" <> show n) . getContentString\n\nul_ :: [Structure] -> Structure\nul_ =\n  Structure . el "ul" . concat . map (el "li" . getStructureString)\n\nol_ :: [Structure] -> Structure\nol_ =\n  Structure . el "ol" . concat . map (el "li" . getStructureString)\n\ncode_ :: String -> Structure\ncode_ = Structure . el "pre" . escape\n\ninstance Semigroup Structure where\n  (<>) c1 c2 =\n    Structure (getStructureString c1 <> getStructureString c2)\n\ninstance Monoid Structure where\n  mempty = Structure ""\n\n-- * Content\n\ntxt_ :: String -> Content\ntxt_ = Content . escape\n\nlink_ :: FilePath -> Content -> Content\nlink_ path content =\n  Content $\n    elAttr\n      "a"\n      ("href=\\"" <> escape path <> "\\"")\n      (getContentString content)\n\nimg_ :: FilePath -> Content\nimg_ path =\n  Content $ "<img src=\\"" <> escape path <> "\\">"\n\nb_ :: Content -> Content\nb_ content =\n  Content $ el "b" (getContentString content)\n\ni_ :: Content -> Content\ni_ content =\n  Content $ el "i" (getContentString content)\n\ninstance Semigroup Content where\n  (<>) c1 c2 =\n    Content (getContentString c1 <> getContentString c2)\n\ninstance Monoid Content where\n  mempty = Content ""\n\n-- * Render\n\nrender :: Html -> String\nrender html =\n  case html of\n    Html str -> str\n\n-- * Utilities\n\nel :: String -> String -> String\nel tag content =\n  "<" <> tag <> ">" <> content <> "</" <> tag <> ">"\n\nelAttr :: String -> String -> String -> String\nelAttr tag attrs content =\n  "<" <> tag <> " " <> attrs <> ">" <> content <> "</" <> tag <> ">"\n\ngetStructureString :: Structure -> String\ngetStructureString structure =\n  case structure of\n    Structure str -> str\n\ngetContentString :: Content -> String\ngetContentString content =\n  case content of\n    Content str -> str\n\nescape :: String -> String\nescape =\n  let\n    escapeChar c =\n      case c of\n        \'<\' -> "&lt;"\n        \'>\' -> "&gt;"\n        \'&\' -> "&amp;"\n        \'"\' -> "&quot;"\n        \'\\\'\' -> "&#39;"\n        _ -> [c]\n  in\n    concat . map escapeChar\n\n\n'))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"src/Html.hs"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"module HsBlog.Html\n  ( Html\n  , Title\n  , Structure\n  , html_\n  , p_\n  , h_\n  , ul_\n  , ol_\n  , code_\n  , Content\n  , txt_\n  , img_\n  , link_\n  , b_\n  , i_\n  , render\n  )\n  where\n\nimport HsBlog.Html.Internal\n"))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"src/Convert.hs"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"module HsBlog.Convert where\n\nimport qualified HsBlog.Markup as Markup\nimport qualified HsBlog.Html as Html\n\nconvert :: Html.Title -> Markup.Document -> Html.Html\nconvert title = Html.html_ title . foldMap convertStructure\n\nconvertStructure :: Markup.Structure -> Html.Structure\nconvertStructure structure =\n  case structure of\n    Markup.Heading n txt ->\n      Html.h_ n $ Html.txt_ txt\n\n    Markup.Paragraph p ->\n      Html.p_ $ Html.txt_ p\n\n    Markup.UnorderedList list ->\n      Html.ul_ $ map (Html.p_ . Html.txt_) list\n\n    Markup.OrderedList list ->\n      Html.ol_ $ map (Html.p_ . Html.txt_) list\n\n    Markup.CodeBlock list ->\n      Html.code_ (unlines list)\n")))),(0,l.kt)("hr",null),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"You can view the git commit of\n",(0,l.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/commit/110a19029f0be42eb2ac656f5d38356dbf9c5746"},"the changes we've made"),"\nand the ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/tree/110a19029f0be42eb2ac656f5d38356dbf9c5746"},"code up until now"),".")),(0,l.kt)("h2",{id:"creating-an-index-page"},"Creating an index page"),(0,l.kt)("p",null,"With our extended HTML EDSL, we can now create an index page with links to the other pages."),(0,l.kt)("p",null,"To create an index page, we need a list of files with their ",(0,l.kt)("em",{parentName:"p"},"target destinations"),",\nas well as their ",(0,l.kt)("inlineCode",{parentName:"p"},"Markup")," (so we can extract information to include in our index page,\nsuch as the first heading and paragraph). Our output should be an ",(0,l.kt)("inlineCode",{parentName:"p"},"Html")," page."),(0,l.kt)("hr",null),(0,l.kt)("p",null,"We need to implement the following function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"buildIndex :: [(FilePath, Markup.Document)] -> Html.Html\n")),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Solution"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'buildIndex :: [(FilePath, Markup.Document)] -> Html.Html\nbuildIndex files =\n  let\n    previews =\n      map\n        ( \\(file, doc) ->\n          case doc of\n            Markup.Heading 1 heading : article ->\n              Html.h_ 3 (Html.link_ file (Html.txt_ heading))\n                <> foldMap convertStructure (take 3 article)\n                <> Html.p_ (Html.link_ file (Html.txt_ "..."))\n            _ ->\n              Html.h_ 3 (Html.link_ file (Html.txt_ file))\n        )\n        files\n  in\n    Html.html_\n      "Blog"\n      ( Html.h_ 1 (Html.link_ "index.html" (Html.txt_ "Blog"))\n        <> Html.h_ 2 (Html.txt_ "Posts")\n        <> mconcat previews\n      )\n'))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"processing-directories"},"Processing directories"),(0,l.kt)("p",null,"Our general strategy for processing whole directories is going to be:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Create the output directory"),(0,l.kt)("li",{parentName:"ul"},"Grab all file names in a directory"),(0,l.kt)("li",{parentName:"ul"},"Filter them according to their extension, we want to process ",(0,l.kt)("inlineCode",{parentName:"li"},"txt")," file and\ncopy other files without modification"),(0,l.kt)("li",{parentName:"ul"},"We want to parse each text file, build an index of the result,\nconvert the files to HTML, and write everything to the target directory")),(0,l.kt)("p",null,"While our parsing function can't really fail, trying to read or write a file\nto the file-system can fail in several ways. It would be nice if our\nstatic blog generator was robust enough that it wouldn't fail completely if one\nsingle file gave it some trouble. This is a good opportunity to learn about\nerror handling in Haskell, both in uneffectful code and for I/O code."),(0,l.kt)("p",null,"In the next few chapters we'll survey the landscape of error handling in Haskell\nbefore figuring out the right approach for our use case."))}m.isMDXComponent=!0}}]);