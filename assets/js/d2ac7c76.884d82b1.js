"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[934],{3905:(e,t,n)=>{n.d(t,{Zo:()=>k,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),s=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},k=function(e){var t=s(e.components);return a.createElement(o.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,k=p(e,["components","mdxType","originalType","parentName"]),h=s(n),m=r,u=h["".concat(o,".").concat(m)]||h[m]||c[m]||i;return n?a.createElement(u,l(l({ref:t},k),{},{components:n})):a.createElement(u,l({ref:t},k))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=m;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p[h]="string"==typeof e?e:r,l[1]=p;for(var s=2;s<i;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4652:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>p,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const i={},l="Either\ub97c \ud65c\uc6a9\ud55c \uc5d0\ub7ec \ucc98\ub9ac",p={unversionedId:"errors_and_files/either",id:"errors_and_files/either",title:"Either\ub97c \ud65c\uc6a9\ud55c \uc5d0\ub7ec \ucc98\ub9ac",description:"\ud558\uc2a4\ucf08\uc5d0\uc11c \uc5d0\ub7ec\ub97c \ud45c\ud604\ud558\uace0 \ucc98\ub9ac\ud558\ub294 \ubc29\ubc95\uc740 \uc5ec\ub7ec\uac00\uc9c0\uac00 \uc788\uc2b5\ub2c8\ub2e4.",source:"@site/docs/06-errors_and_files/01-either.md",sourceDirName:"06-errors_and_files",slug:"/errors_and_files/either",permalink:"/learn-haskell-blog-generator/errors_and_files/either",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/06-errors_and_files/01-either.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\uc5d0\ub7ec \ucc98\ub9ac\uc640 \uc5ec\ub7ec \ud30c\uc77c \ub2e4\ub8e8\uae30",permalink:"/learn-haskell-blog-generator/errors_and_files/"},next:{title:"Either with IO?",permalink:"/learn-haskell-blog-generator/errors_and_files/except"}},o={},s=[{value:"Applicative + Traversable",id:"applicative--traversable",level:2},{value:"\uc5d0\ub7ec\uac00 \uc5ec\ub7ec \uac1c\uc778 \uacbd\uc6b0",id:"\uc5d0\ub7ec\uac00-\uc5ec\ub7ec-\uac1c\uc778-\uacbd\uc6b0",level:2},{value:"\ubaa8\ub098\ub515 \uc778\ud130\ud398\uc774\uc2a4",id:"\ubaa8\ub098\ub515-\uc778\ud130\ud398\uc774\uc2a4",level:2},{value:"Do notation?",id:"do-notation",level:3},{value:"Summary",id:"summary",level:2}],k={toc:s},h="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,a.Z)({},k,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"either\ub97c-\ud65c\uc6a9\ud55c-\uc5d0\ub7ec-\ucc98\ub9ac"},"Either\ub97c \ud65c\uc6a9\ud55c \uc5d0\ub7ec \ucc98\ub9ac"),(0,r.kt)("p",null,"\ud558\uc2a4\ucf08\uc5d0\uc11c \uc5d0\ub7ec\ub97c \ud45c\ud604\ud558\uace0 \ucc98\ub9ac\ud558\ub294 \ubc29\ubc95\uc740 \uc5ec\ub7ec\uac00\uc9c0\uac00 \uc788\uc2b5\ub2c8\ub2e4.\n\uc6b0\ub9ac\ub294 \uadf8 \uc911 \ud558\ub098\uc778 ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html"},"Either"),"\ub97c \uc0b4\ud3b4\ubcf4\ub824\uace0 \ud569\ub2c8\ub2e4.\nEither\ub294 \ub2e4\uc74c\uacfc \uac19\uc774 \uc815\uc758\ub418\uc5b4 \uc788\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Either a b\n  = Left a\n  | Right b\n")),(0,r.kt)("p",null,"\uac04\ub2e8\ud558\uac8c \uc124\uba85\ud558\uba74, ",(0,r.kt)("inlineCode",{parentName:"p"},"Either a b")," \ud0c0\uc785\uc758 \uac12\uc740 ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," \ud0c0\uc785\uc758 \uac12\uc774\uac70\ub098 ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," \ud0c0\uc785\uc758 \uac12\uc774\ub77c\uace0 \ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\ub2e4\uc74c \uc0dd\uc131\uc790\ub97c \ud1b5\ud574 \uc5b4\ub5a4 \ud0c0\uc785\uc758 \uac12\uc778\uc9c0 \uad6c\ubd84\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"Left True :: Either Bool b\nRight 'a' :: Either a Char\n")),(0,r.kt)("p",null,"\uc774\ub7ec\ud55c \ud0c0\uc785\uc744 \uc0ac\uc6a9\ud558\uba74, ",(0,r.kt)("inlineCode",{parentName:"p"},"Left")," \uc0dd\uc131\uc790\ub97c \ud1b5\ud574 \uc5d0\ub7ec \uac12\uacfc \ud568\uaed8 \uc2e4\ud328\ub97c \ud45c\ud604\ud560 \uc218 \uc788\uace0, ",(0,r.kt)("inlineCode",{parentName:"p"},"Right")," \uc0dd\uc131\uc790\ub97c \ud1b5\ud574 \uc608\uc0c1\ub418\ub294 \uacb0\uacfc\uacfc \ud568\uaed8 \uc131\uacf5\uc744 \ud45c\ud604\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Either"),"\ub294 \ub2e4\ud615\uc801\uc774\uae30 \ub54c\ubb38\uc5d0, \uc2e4\ud328\uc640 \uc131\uacf5\uc744 \ud45c\ud604\ud558\ub294 \ub370 \ub450 \ud0c0\uc785 \uc5b4\ub290 \uac83\uc744 \uc0ac\uc6a9\ud574\ub3c4 \uc0c1\uad00\uc5c6\uc2b5\ub2c8\ub2e4.\n\ub54c\ub860 \uc2e4\ud328 \ubaa8\ub4dc\ub97c ADT\ub85c \ud45c\ud604\ud558\ub294 \uac83\uc774 \uc720\uc6a9\ud560 \ub54c\uac00 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("p",null,"\uc608\ub97c \ub4e4\uc5b4, ",(0,r.kt)("inlineCode",{parentName:"p"},"Char"),"\ub97c \uc22b\uc790\ub85c \ud30c\uc2f1\ud558\uc5ec ",(0,r.kt)("inlineCode",{parentName:"p"},"Int"),"\ub85c \ubcc0\ud658\ud558\ub824\uace0 \ud569\uc2dc\ub2e4.\n\ubb38\uc790\uac00 \uc22b\uc790\uac00 \uc544\ub2d0 \uacbd\uc6b0 \uc774 \uc5f0\uc0b0\uc740 \uc2e4\ud328\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\uc774\ub7ec\ud55c \uc2e4\ud328\ub97c \ud45c\ud604\ud558\uae30 \uc704\ud574 \ub2e4\uc74c\uacfc \uac19\uc740 \ub370\uc774\ud130 \ud0c0\uc785\uc744 \uc815\uc758\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data ParseDigitError\n  = NotADigit Char\n  deriving Show\n")),(0,r.kt)("p",null,"\uadf8\ub9ac\uace0 \ud30c\uc2f1 \ud568\uc218\ub294 \ub2e4\uc74c\uacfc \uac19\uc740 \ud0c0\uc785\uc744 \uac00\uc9c8 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"parseDigit :: Char -> Either ParseDigitError Int\n")),(0,r.kt)("p",null,"\uc774\uc81c \ud30c\uc2f1\ud568\uc218\ub97c \uad6c\ud604\ud558\uc5ec, \ubb38\uc81c\ub97c \uc124\uba85\ud558\ub294 \uc5d0\ub7ec\ub97c ",(0,r.kt)("inlineCode",{parentName:"p"},"Left"),"\uc5d0 \ub2f4\uace0, \ud30c\uc2f1\uc5d0 \uc131\uacf5\ud55c \uacbd\uc6b0\uc5d0\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"Right"),"\uc5d0 \ub2f4\uc544 \ubc18\ud658\ud558\uba74 \ub429\ub2c8\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"parseDigit :: Char -> Either ParseDigitError Int\nparseDigit c =\n  case c of\n    '0' -> Right 0\n    '1' -> Right 1\n    '2' -> Right 2\n    '3' -> Right 3\n    '4' -> Right 4\n    '5' -> Right 5\n    '6' -> Right 6\n    '7' -> Right 7\n    '8' -> Right 8\n    '9' -> Right 9\n    _ -> Left (NotADigit c)\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Either"),"\ub294 \ub610\ud55c ",(0,r.kt)("inlineCode",{parentName:"p"},"Functor"),"\uc640 ",(0,r.kt)("inlineCode",{parentName:"p"},"Applicative")," \uc778\uc2a4\ud134\uc2a4\uc774\uae30 \ub54c\ubb38\uc5d0, \uc774\ub7ec\ud55c \uc885\ub958\uc758 \uacc4\uc0b0\uc744 \uacb0\ud569\ud558\ub824\uba74 \uba87 \uac00\uc9c0 \uc870\ud569\uae30\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("p",null,"\uc608\ub97c \ub4e4\uc5b4, \uc138 \uac1c\uc758 \ubb38\uc790\ub97c \ud30c\uc2f1\ud558\uace0 \uadf8 \uc911 \ucd5c\ub300 \uac12\uc744 \ucc3e\uc73c\ub824\uba74 applicative \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"max3chars :: Char -> Char -> Char -> Either ParseDigitError Int\nmax3chars x y z =\n  (\\a b c -> max a (max b c))\n    <$> parseDigit x\n    <*> parseDigit y\n    <*> parseDigit z\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Either a"),"\uc758 ",(0,r.kt)("inlineCode",{parentName:"p"},"Functor"),"\uc640 ",(0,r.kt)("inlineCode",{parentName:"p"},"Applicative")," \uc778\ud130\ud398\uc774\uc2a4\ub294 \ud568\uc218\ub97c \ud398\uc774\ub85c\ub4dc \uac12\uc5d0 \uc801\uc6a9\ud558\uace0 \uc5d0\ub7ec \ucc98\ub9ac\ub97c ",(0,r.kt)("strong",{parentName:"p"},"\uc9c0\uc5f0"),"\ud560 \uc218 \uc788\ub3c4\ub85d \ud574\uc90d\ub2c8\ub2e4.\n\uc758\ubbf8\uc801\uc73c\ub85c, ",(0,r.kt)("inlineCode",{parentName:"p"},"Left"),"\ub97c \ubc18\ud658\ud558\ub294 \uccab \ubc88\uc9f8 Either\uac00 \ubc18\ud658 \uac12\uc774 \ub429\ub2c8\ub2e4.\nApplicative \uc778\uc2a4\ud134\uc2a4\uc758 \uad6c\ud604\uc5d0\uc11c \uc774\uac83\uc774 \uc5b4\ub5bb\uac8c \uc791\ub3d9\ud558\ub294\uc9c0 \uc0b4\ud3b4\ubcf4\uaca0\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Applicative (Either e) where\n    pure          = Right\n    Left  e <*> _ = Left e\n    Right f <*> r = fmap f r\n")),(0,r.kt)("p",null,"\uc774\ud6c4\uc5d0 \ub204\uad70\uac00\ub294 \uc2e4\uc81c\ub85c \uacb0\uacfc\ub97c ",(0,r.kt)("strong",{parentName:"p"},"\uac80\uc0ac"),"\ud558\uace0 \uc5d0\ub7ec(Left \uc0dd\uc131\uc790)\uac00 \ubc1c\uc0dd\ud588\ub294\uc9c0, \uc608\uc0c1\ud55c \uac12(Right \uc0dd\uc131\uc790)\uc774 \ubc1c\uc0dd\ud588\ub294\uc9c0 \ud655\uc778\ud558\uace0 \uc2f6\uc744 \uac83\uc785\ub2c8\ub2e4.\n\uc774\ub97c \uc704\ud574 \ud328\ud134 \ub9e4\uce6d\uc744 \ud1b5\ud574 \uacb0\uacfc\ub97c \uac80\uc0ac\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("h2",{id:"applicative--traversable"},"Applicative + Traversable"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Either"),"\uc758 ",(0,r.kt)("inlineCode",{parentName:"p"},"Applicative")," \uc778\ud130\ud398\uc774\uc2a4\ub294 \ub9e4\uc6b0 \uac15\ub825\ud558\uba70, \ub2e4\ub978 \ucd94\uc0c1\ud654\uc778 ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Traversable.html#g:1"},(0,r.kt)("inlineCode",{parentName:"a"},"Traversable")),"\uc640 \uacb0\ud569\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ub098 \uc774\uc9c4 \ud2b8\ub9ac\uc640 \uac19\uc774 \uc67c\ucabd\uc5d0\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc21c\ud68c\ud560 \uc218 \uc788\ub294 \ub370\uc774\ud130 \uad6c\uc870\ub97c \ub9d0\ud569\ub2c8\ub2e4.\n\uc774\ub97c \ud1b5\ud574 ",(0,r.kt)("inlineCode",{parentName:"li"},"Traversable"),"\ub97c \uad6c\ud604\ud558\ub294 \ub370\uc774\ud130 \uad6c\uc870\uc774\uae30\ub9cc \ud558\uba74 \uc784\uc758\uc758 \uac1c\uc218\uc758 ",(0,r.kt)("inlineCode",{parentName:"li"},"Either ParseDigitError Int"),"\uc640 \uac19\uc740 \uac12\ub4e4\uc744 \uacb0\ud569\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.")),(0,r.kt)("p",null,"\uc608\uc81c\ub97c \uc0b4\ud3b4\ubcf4\uaca0\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> :t "1234567"\n"1234567" :: String\n-- String\uc740 Char\uc758 \ub9ac\uc2a4\ud2b8\uc5d0 \ub300\ud55c \ubcc4\uce6d\uc778 \uac83\uc744 \uae30\uc5b5\ud558\uc138\uc694.\nghci> :info String\ntype String :: *\ntype String = [Char]\n      -- Defined in \u2018GHC.Base\u2019\n\nghci> :t map parseDigit "1234567"\nmap parseDigit mystring :: [Either ParseDigitError Int]\nghci> map parseDigit "1234567"\n[Right 1,Right 2,Right 3,Right 4,Right 5,Right 6,Right 7]\n\nghci> :t sequenceA\nsequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)\n-- `t`\ub97c `[]`\ub85c, `f`\ub97c `Either Error`\ub85c \ub300\uccb4\ud574\uc11c \uc0dd\uac01\ud574\ubcfc \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\nghci> sequenceA (map parseDigit mystring)\nRight [1,2,3,4,5,6,7]\n\nghci> map parseDigit "1a2"\n[Right 1,Left (NotADigit \'a\'),Right 2]\nghci> sequenceA (map parseDigit "1a2")\nLeft (NotADigit \'a\')\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"map"),"\uacfc ",(0,r.kt)("inlineCode",{parentName:"p"},"sequenceA"),"\ub97c \uacb0\ud569\ud558\ub294 \ub300\uc2e0 ",(0,r.kt)("inlineCode",{parentName:"p"},"traverse"),"\ub97c \uc0ac\uc6a9\ud560 \uc218\ub3c4 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> :t traverse\ntraverse\n  :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)\nghci> traverse parseDigit "1234567"\nRight [1,2,3,4,5,6,7]\nghci> traverse parseDigit "1a2"\nLeft (NotADigit \'a\')\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Either a")," \ub610\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"IO"),"\ucc98\ub7fc ",(0,r.kt)("inlineCode",{parentName:"p"},"Applicative")," \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud55c \ud0c0\uc785\uacfc ",(0,r.kt)("inlineCode",{parentName:"p"},"[]")," \ub610\ub294\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-Map-Strict.html#t:Map"},(0,r.kt)("inlineCode",{parentName:"a"},"Map k")),"\n(\ub2e4\ub978 \uc5b8\uc5b4\uc5d0\uc11c\ub294 \ub515\uc154\ub108\ub9ac\ub77c\uace0\ub3c4 \ud568 - \ud0a4\uc640 \uac12\uc758 \ub9e4\ud551) \uc640 \uac19\uc774 ",(0,r.kt)("inlineCode",{parentName:"p"},"Traversable")," \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud55c \uc5b4\ub5a0\ud55c \ub450 \ud0c0\uc785\uc5d0 \ub300\ud574\uc11c\ub3c4 ",(0,r.kt)("inlineCode",{parentName:"p"},"traverse"),"\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("p",null,"\uc608\ub97c \ub4e4\uc5b4 ",(0,r.kt)("inlineCode",{parentName:"p"},"IO"),"\uc640 ",(0,r.kt)("inlineCode",{parentName:"p"},"[]"),"\ub97c \uacb0\ud569\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," \ub370\uc774\ud130 \uad6c\uc870\ub294 ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-Map-Strict.html#v:fromList"},(0,r.kt)("inlineCode",{parentName:"a"},"fromList"))," \ud568\uc218\ub97c \uc0ac\uc6a9\ud558\uc5ec \ud29c\ud50c\uc758 \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc0dd\uc131\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\ud29c\ud50c\uc758 \uccab \ubc88\uc9f8 \uac12\uc740 \ud0a4\uc774\uace0 \ub450 \ubc88\uc9f8 \uac12\uc740 \uac12\uc785\ub2c8\ub2e4.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> import qualified Data.Map as M -- \ucee8\ud14c\uc774\ub108 \ud328\ud0a4\uc9c0\uc5d0\uc11c \uac00\uc838\uc635\ub2c8\ub2e4.\n\nghci> file1 = ("output/file1.html", "input/file1.txt")\nghci> file2 = ("output/file2.html", "input/file2.txt")\nghci> file3 = ("output/file3.html", "input/file3.txt")\nghci> files = M.fromList [file1, file2, file3]\nghci> :t files :: M.Map FilePath FilePath -- FilePath\ub294 String\uc758 \ubcc4\uce6d\uc785\ub2c8\ub2e4.\nfiles :: M.Map FilePath FilePath :: M.Map FilePath FilePath\n\nghci> readFiles = traverse readFile\nghci> :t readFiles\nreadFiles :: Traversable t => t FilePath -> IO (t String)\n\nghci> readFiles files\nfromList [("output/file1.html","I\'m the content of file1.txt\\n"),("output/file2.html","I\'m the content of file2.txt\\n"),("output/file3.html","I\'m the content of file3.txt\\n")]\nghci> :t readFiles files\nreadFiles files :: IO (Map String String)\n')),(0,r.kt)("p",null,"\uc704 \ucf54\ub4dc\uc5d0\uc11c ",(0,r.kt)("inlineCode",{parentName:"p"},"readFiles"),"\ub77c\ub294 \ud568\uc218\ub97c \ub9cc\ub4e4\uc5c8\uc2b5\ub2c8\ub2e4.\n\uc774 \ud568\uc218\ub294 ",(0,r.kt)("em",{parentName:"p"},"\ucd9c\ub825 \ud30c\uc77c \uacbd\ub85c"),"\ub97c ",(0,r.kt)("em",{parentName:"p"},"\uc785\ub825 \ud30c\uc77c \uacbd\ub85c"),"\ub85c \ub9e4\ud551\uc744 \uc218\ud589\ud569\ub2c8\ub2e4.\n\uadf8\ub9ac\uace0 \uc785\ub825 \ud30c\uc77c\uc744 \uc77d\uc5b4\uc11c \uadf8 \ub0b4\uc6a9\uc744 \ub9f5\uc5d0 \ubc14\ub85c \uc4f0\ub294 IO \uc5f0\uc0b0\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4!\n\ub098\uc911\uc5d0 \uc720\uc6a9\ud558\uac8c \uc0ac\uc6a9\ud560 \uc218 \uc788\uc744 \uac83\uc785\ub2c8\ub2e4."),(0,r.kt)("h2",{id:"\uc5d0\ub7ec\uac00-\uc5ec\ub7ec-\uac1c\uc778-\uacbd\uc6b0"},"\uc5d0\ub7ec\uac00 \uc5ec\ub7ec \uac1c\uc778 \uacbd\uc6b0"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Either"),"\uc758 kind\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"* -> * -> *"),"(\ub450 \uac1c\uc758 \ud0c0\uc785 \ud30c\ub77c\ubbf8\ud130\ub97c \ubc1b\uc2b5\ub2c8\ub2e4)\uc774\uae30 \ub54c\ubb38\uc5d0 ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),"\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"Functor"),"\ub098 ",(0,r.kt)("inlineCode",{parentName:"p"},"Applicative"),"\uc758 \uc778\uc2a4\ud134\uc2a4\uac00 \ub420 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4.\n\uc774\ub7ec\ud55c \ud0c0\uc785 \ud074\ub798\uc2a4\uc758 \uc778\uc2a4\ud134\uc2a4\ub294 kind\uac00 ",(0,r.kt)("inlineCode",{parentName:"p"},"* -> *"),"\uc774\uc5b4\uc57c \ud569\ub2c8\ub2e4.\n\ub2e4\uc74c \ud0c0\uc785 \ud074\ub798\uc2a4 \ud568\uc218 \uc2dc\uadf8\ub2c8\ucc98\ub97c \uc0b4\ud3b4\ubcf4\uba74:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"fmap :: Functor f => (a -> b) -> f a -> f b\n")),(0,r.kt)("p",null,"\uadf8\ub9ac\uace0 \ud2b9\uc815\ud55c \ud0c0\uc785\uc5d0 \ub300\ud574 \uc774\ub97c \uad6c\ud604\ud558\uace0 \uc2f6\ub2e4\uba74(",(0,r.kt)("inlineCode",{parentName:"p"},"f"),"\uc758 \uc790\ub9ac\uc5d0), ",(0,r.kt)("inlineCode",{parentName:"p"},"f"),"\ub97c \ub300\uc0c1 \ud0c0\uc785\uc73c\ub85c ",(0,r.kt)("em",{parentName:"p"},"\uce58\ud658"),"\ud560 \uc218 \uc788\uc5b4\uc57c \ud569\ub2c8\ub2e4.\n",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),"\ub97c \uc0ac\uc6a9\ud558\ub824\uace0 \ud558\uba74 \ub2e4\uc74c\uacfc \uac19\uc740 \uc2dc\uadf8\ub2c8\ucc98\ub97c \uc5bb\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"fmap :: (a -> b) -> Either a -> Either b\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Either a"),"\uc640 ",(0,r.kt)("inlineCode",{parentName:"p"},"Either b"),"\ub294 \ub458 \ub2e4 ",(0,r.kt)("em",{parentName:"p"},"\uad6c\uccb4\ud654\ub41c \ud0c0\uc785"),"\uc774 \uc544\ub2c8\uae30 \ub54c\ubb38\uc5d0 \uc774\ub294 \ud0c0\uc785 \uc624\ub958\uac00 \ubc1c\uc0dd\ud569\ub2c8\ub2e4.\n\uac19\uc740 \uc774\uc720\ub85c ",(0,r.kt)("inlineCode",{parentName:"p"},"f"),"\ub97c ",(0,r.kt)("inlineCode",{parentName:"p"},"Int"),"\ub85c \uce58\ud658\ud558\ub824\uace0 \ud558\uba74 \ub2e4\uc74c\uacfc \uac19\uc740 \uc2dc\uadf8\ub2c8\ucc98\ub97c \uc5bb\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"fmap :: (a -> b) -> Int a -> Int b\n")),(0,r.kt)("p",null,"\uc774 \ub610\ud55c \ud0c0\uc785 \uc624\ub958\uac00 \ubc1c\uc0dd\ud569\ub2c8\ub2e4."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Either"),"\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc9c0\ub9cc, ",(0,r.kt)("inlineCode",{parentName:"p"},"Either e"),"\uc758 kind\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"* -> *"),"\uc774\uae30 \ub54c\ubb38\uc5d0 \uc0ac\uc6a9\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\ub2e4\uc74c \uc2dc\uadf8\ub2c8\ucc98\uc5d0\uc11c ",(0,r.kt)("inlineCode",{parentName:"p"},"f"),"\ub97c ",(0,r.kt)("inlineCode",{parentName:"p"},"Either e"),"\ub85c \uce58\ud658\ud574\ubd05\uc2dc\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"liftA2 :: Applicative => (a -> b -> c) -> f a -> f b -> f c\n")),(0,r.kt)("p",null,"\ub2e4\uc74c\uacfc \uac19\uc740 \uacb0\uacfc\ub97c \uc5bb\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"liftA2 :: (a -> b -> c) -> Either e a -> Either e b -> Either e c\n")),(0,r.kt)("p",null,"\uc774\ub97c \ud1b5\ud574 \uc54c \uc218 \uc788\ub294 \uac83\uc740 ",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"em"},"Left")," \uc0dd\uc131\uc790\uc758 \ud0c0\uc785\uc774 \uac19\uc740 \ub450 \uac1c\uc758 ",(0,r.kt)("inlineCode",{parentName:"em"},"Either"),"\ub97c \uacb0\ud569\ud560 \ub54c\ub9cc applicative \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4\ub294 \uac83"),"\uc785\ub2c8\ub2e4."),(0,r.kt)("p",null,"\uadf8\ub807\ub2e4\uba74 \ub450 \uac1c\uc758 ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),"\ub97c \uacb0\ud569\ud560 \ub54c ",(0,r.kt)("inlineCode",{parentName:"p"},"Left")," \uc0dd\uc131\uc790\uc758 \ud0c0\uc785\uc774 \ub2e4\ub974\ub2e4\uba74 \uc5b4\ub5bb\uac8c \ud574\uc57c \ud560\uae4c\uc694?\n\uba87 \uac00\uc9c0 \ubc29\ubc95\uc774 \uc788\uc9c0\ub9cc \uac00\uc7a5 \uc801\ubc95\ud55c \ubc29\ubc95\uc740 \ub2e4\uc74c\uacfc \uac19\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"\uac19\uc740 \uc5d0\ub7ec \ud0c0\uc785\uc744 \ubc18\ud658\ud558\ub3c4\ub85d \ub9cc\ub4ed\ub2c8\ub2e4. \ubaa8\ub4e0 \uc5d0\ub7ec\ub97c \ud558\ub098\uc758 \ud0c0\uc785\uc73c\ub85c \ud1b5\ud569\ud558\ub294 ADT\ub97c \uc791\uc131\ud569\ub2c8\ub2e4.\n\uc774\ub294 \uc77c\ubd80 \uacbd\uc6b0\uc5d0\ub294 \uc791\ub3d9\ud558\uc9c0\ub9cc \ud56d\uc0c1 \uc774\uc0c1\uc801\uc778 \uac83\uc740 \uc544\ub2d9\ub2c8\ub2e4.\n\uc608\ub97c \ub4e4\uc5b4 ",(0,r.kt)("inlineCode",{parentName:"li"},"parseDigit"),"\uc758 \uc785\ub825\uc774 \ube48 \ubb38\uc790\uc5f4\uc77c \uc218 \uc788\ub294 \uacbd\uc6b0\ub97c \uc0ac\uc6a9\uc790\uac00 \uc9c1\uc811 \ucc98\ub9ac\ud558\uac8c \ub9cc\ub4e4\uc5b4\uc11c\ub294 \uc548 \ub429\ub2c8\ub2e4."),(0,r.kt)("li",{parentName:"ol"},"\uac01 \ud0c0\uc785\uc5d0 \ub300\ud574 \ud2b9\uc218\ud55c \uc5d0\ub7ec \ud0c0\uc785\uc744 \uc0ac\uc6a9\ud569\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \uc774\ub4e4\uc744 \uacb0\ud569\ud560 \ub54c\ub294 \uc77c\ubc18\uc801\uc778 \uc5d0\ub7ec \ud0c0\uc785\uc73c\ub85c \ub9e4\ud551\ud569\ub2c8\ub2e4.\n\uc774\ub294 ",(0,r.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Bifunctor.html#v:first"},(0,r.kt)("inlineCode",{parentName:"a"},"first"))," \ud568\uc218\ub97c \uc0ac\uc6a9\ud558\uc5ec \uc218\ud589\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n",(0,r.kt)("inlineCode",{parentName:"li"},"first")," \ud568\uc218\ub294 ",(0,r.kt)("inlineCode",{parentName:"li"},"Bifunctor")," \ud0c0\uc785 \ud074\ub798\uc2a4\uc5d0 \uc815\uc758\ub418\uc5b4 \uc788\uc2b5\ub2c8\ub2e4.")),(0,r.kt)("h2",{id:"\ubaa8\ub098\ub515-\uc778\ud130\ud398\uc774\uc2a4"},"\ubaa8\ub098\ub515 \uc778\ud130\ud398\uc774\uc2a4"),(0,r.kt)("p",null,"The applicative interface allows us to lift a function to work on multiple\n",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," values (or other applicative functor instances such as ",(0,r.kt)("inlineCode",{parentName:"p"},"IO")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Parser"),").\nBut more often than not, we'd like to use a value from one computation\nthat might return an error in another computation that might return an error."),(0,r.kt)("p",null,"For example, a compiler such has GHC operates in stages, such as lexical analysis,\nparsing, type-checking, and so on. Each stage depends on the output of the stage\nbefore it, and each stage might fail. We can write the types for these functions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"tokenize :: String -> Either Error [Token]\n\nparse :: [Token] -> Either Error AST\n\ntypecheck :: AST -> Either Error TypedAST\n")),(0,r.kt)("p",null,"We want to compose these functions so that they work in a chain. The output of ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenize"),"\ngoes to ",(0,r.kt)("inlineCode",{parentName:"p"},"parse"),", and the output of ",(0,r.kt)("inlineCode",{parentName:"p"},"parse")," goes to ",(0,r.kt)("inlineCode",{parentName:"p"},"typecheck"),"."),(0,r.kt)("p",null,"We know that we can lift a function over an ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," (and other functors),\nwe can also lift a function that returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- reminder the type of fmap\nfmap :: Functor f => (a -> b) -> f a -> f b\n-- specialized for `Either Error`\nfmap :: (a -> b) -> Either Error a -> Either Error b\n\n-- here, `a` is [Token] and `b` is `Either Error AST`:\n\n> fmap parse (tokenize string) :: Either Error (Either Error AST)\n")),(0,r.kt)("p",null,"While this code compiles, it isn't great, because we are building\nlayers of ",(0,r.kt)("inlineCode",{parentName:"p"},"Either Error")," and we can't use this trick again with\n",(0,r.kt)("inlineCode",{parentName:"p"},"typecheck"),"! ",(0,r.kt)("inlineCode",{parentName:"p"},"typecheck")," expects an ",(0,r.kt)("inlineCode",{parentName:"p"},"AST"),", but if we try to fmap it\non ",(0,r.kt)("inlineCode",{parentName:"p"},"fmap parse (tokenize string)"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," will be ",(0,r.kt)("inlineCode",{parentName:"p"},"Either Error AST"),"\ninstead."),(0,r.kt)("p",null,"What we would really like is to flatten this structure instead of nesting it.\nIf we look at the kind of values ",(0,r.kt)("inlineCode",{parentName:"p"},"Either Error (Either Error AST)")," could have,\nit looks something like this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Left <error>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Right (Left error)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Right (Right <ast>)"))),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Exercise"),": What if we just used pattern matching for this instead? How would this look like?"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"case tokenize string of\n  Left err ->\n    Left err\n  Right tokens ->\n    case parse tokens of\n      Left err ->\n        Left err\n      Right ast ->\n        typecheck ast\n")),(0,r.kt)("p",null,"If we run into an error in a stage, we return that error and stop. If we succeed, we\nuse the value on the next stage.")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Flattening this structure for ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," is very similar to that last part - the body\nof the ",(0,r.kt)("inlineCode",{parentName:"p"},"Right tokens")," case:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"flatten :: Either e (Either e a) -> Either e a\nflatten e =\n  case e of\n    Left l -> Left l\n    Right x -> x\n")),(0,r.kt)("p",null,"Because we have this function, we can now use it on the output of\n",(0,r.kt)("inlineCode",{parentName:"p"},"fmap parse (tokenize string) :: Either Error (Either Error AST)"),"\nfrom before:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"> flatten (fmap parse (tokenize string)) :: Either Error AST\n")),(0,r.kt)("p",null,"And now we can use this function again to compose with ",(0,r.kt)("inlineCode",{parentName:"p"},"typecheck"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"> flatten (fmap typecheck (flatten (fmap parse (tokenize string)))) :: Either Error TypedAST\n")),(0,r.kt)("p",null,"This ",(0,r.kt)("inlineCode",{parentName:"p"},"flatten")," + ",(0,r.kt)("inlineCode",{parentName:"p"},"fmap")," combination looks like a recurring pattern which\nwe can combine into a function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"flatMap :: (a -> Either e b) -> Either a -> Either b\nflatMap func val = flatten (fmap func val)\n")),(0,r.kt)("p",null,"And now we can write the code this way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"> flatMap typecheck (flatMap parse (tokenize string)) :: Either Error TypedAST\n\n-- Or using backticks syntax to convert the function to infix form:\n> typecheck `flatMap` parse `flatMap` tokenize string\n\n-- Or create a custom infix operator: (=<<) = flatMap\n> typeCheck =<< parse =<< tokenize string\n")),(0,r.kt)("p",null,"This function, ",(0,r.kt)("inlineCode",{parentName:"p"},"flatten")," (and ",(0,r.kt)("inlineCode",{parentName:"p"},"flatMap")," as well), have different names in Haskell.\nThey are called\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Monad.html#v:join"},(0,r.kt)("inlineCode",{parentName:"a"},"join")),"\nand ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Monad.html#v:-61--60--60-"},(0,r.kt)("inlineCode",{parentName:"a"},"=<<")),'\n(pronounced "reverse bind"),\nand they are the essence of another incredibly useful abstraction in Haskell.'),(0,r.kt)("p",null,"If we have a type that can implement:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"Functor")," interface, specifically the ",(0,r.kt)("inlineCode",{parentName:"li"},"fmap")," function"),(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"Applicative")," interface, most importantly the ",(0,r.kt)("inlineCode",{parentName:"li"},"pure")," function"),(0,r.kt)("li",{parentName:"ol"},"This ",(0,r.kt)("inlineCode",{parentName:"li"},"join")," function")),(0,r.kt)("p",null,"They can implement an instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad")," type class."),(0,r.kt)("p",null,'With functors, we were able to "lift" a function to work over the type implementing the functor type class:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"fmap :: (a -> b) -> f a -> f b\n")),(0,r.kt)("p",null,'With applicative functors we were able to "lift" a function of multiple arguments\nover multiple values of a type implementing the applicative functor type class,\nand also lift a value into that type:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"pure :: a -> f a\n\nliftA2 :: (a -> b -> c) -> f a -> f b -> f c\n")),(0,r.kt)("p",null,'With monads we can now flatten (or, "join" in Haskell terminology) types that implement\nthe ',(0,r.kt)("inlineCode",{parentName:"p"},"Monad")," interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'join :: m (m a) -> m a\n\n-- this is =<< with the arguments reversed, pronounced "bind"\n(>>=) :: m a -> (a -> m b) -> m b\n')),(0,r.kt)("p",null,"With ",(0,r.kt)("inlineCode",{parentName:"p"},">>=")," we can write our compilation pipeline from before in a left-to-right\nmanner, which seems to be more popular for monads:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"> tokenize string >>= parse >>= typecheck\n")),(0,r.kt)("p",null,"We have already met this function before when we talked about ",(0,r.kt)("inlineCode",{parentName:"p"},"IO"),". Yes,\n",(0,r.kt)("inlineCode",{parentName:"p"},"IO")," also implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad")," interface. The monadic interface for ",(0,r.kt)("inlineCode",{parentName:"p"},"IO"),"\nhelped us with creating a proper ordering of effects."),(0,r.kt)("p",null,"The essence of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad")," interface is the ",(0,r.kt)("inlineCode",{parentName:"p"},"join"),"/",(0,r.kt)("inlineCode",{parentName:"p"},">>=")," functions, and as we've seen\nwe can implement ",(0,r.kt)("inlineCode",{parentName:"p"},">>=")," in terms of ",(0,r.kt)("inlineCode",{parentName:"p"},"join"),", we can also implement ",(0,r.kt)("inlineCode",{parentName:"p"},"join")," in terms\nof ",(0,r.kt)("inlineCode",{parentName:"p"},">>=")," (try it!)."),(0,r.kt)("p",null,"The monadic interface can mean very different things for different types. For ",(0,r.kt)("inlineCode",{parentName:"p"},"IO")," this\nis ordering of effects, for ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," it is early cutoff,\nfor ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/logict-0.7.1.0"},(0,r.kt)("inlineCode",{parentName:"a"},"Logic"))," this means backtracking computation, etc."),(0,r.kt)("p",null,"Again, don't worry about analogies and metaphors, focus on the API and the\n",(0,r.kt)("a",{parentName:"p",href:"https://wiki.haskell.org/Monad_laws"},"laws"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Hey, did you check the monad laws? left identity, right identity and associativity? We've already\ndiscussed a type class with exactly these laws - the ",(0,r.kt)("inlineCode",{parentName:"p"},"Monoid")," type class. Maybe this is related\nto the famous quote about monads being just monoids in something something...")),(0,r.kt)("h3",{id:"do-notation"},"Do notation?"),(0,r.kt)("p",null,"Remember the ",(0,r.kt)("a",{parentName:"p",href:"/learn-haskell-blog-generator/glue/io#do-notation"},"do notation"),"? Turns out it works for any type that is\nan instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad"),". How cool is that? Instead of writing:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"pipeline :: String -> Either Error TypedAST\npipeline string =\n  tokenize string >>= \\tokens ->\n    parse tokens >>= \\ast ->\n      typecheck ast\n")),(0,r.kt)("p",null,"We can write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"pipeline :: String -> Either Error TypedAST\npipeline string = do\n  tokens <- tokenize string\n  ast <- parse tokens\n  typecheck ast\n")),(0,r.kt)("p",null,"And it will work! Still, in this particular case ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenize string >>= parse >>= typecheck"),"\nis so concise it can only be beaten by using\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Monad.html#v:-62--61--62-"},">=>"),"\nor\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Monad.html#v:-60--61--60-"},"<=<"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c\n(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c\n\n-- compare with function composition:\n(.) ::              (b ->   c) -> (a ->   b) -> a ->   c\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"pipeline  = tokenize >=> parse >=> typecheck\n")),(0,r.kt)("p",null,"or"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"pipeline = typecheck <=< parse <=< tokenize\n")),(0,r.kt)("p",null,"Haskell's ability to create very concise code using abstractions is\ngreat once one is familiar with the abstractions. Knowing the monad abstraction,\nwe are now already familiar with the core composition API of many libraries - for example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/stm"},"Concurrent"),"\nand ",(0,r.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/async"},"asynchronous programming")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://gilmi.me/blog/post/2020/12/05/scotty-bulletin-board"},"Web programming")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"http://hspec.github.io/"},"Testing")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-State-Lazy.html#g:2"},"Emulating stateful computation")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Reader.html#g:2"},"sharing environment between computations")),(0,r.kt)("li",{parentName:"ul"},"and many more.")),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," for error handling is useful for two reasons:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"We encode possible errors using types, and we ",(0,r.kt)("strong",{parentName:"li"},"force users to acknowledge and handle")," them, thus\nmaking our code more resilient to crashes and bad behaviours"),(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"Functor"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Applicative"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"Monad")," interfaces provide us with mechanisms for\n",(0,r.kt)("strong",{parentName:"li"},"composing")," functions that might fail (almost) effortlessly - reducing boilerplate while\nmaintaining strong guarantees about our code, and delaying the need to handle errors until\nit is appropriate")))}c.isMDXComponent=!0}}]);