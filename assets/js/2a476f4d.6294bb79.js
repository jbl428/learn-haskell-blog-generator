"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[499],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>c});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),d=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=d(e.components);return a.createElement(p.Provider,{value:n},e.children)},s="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},k=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),s=d(t),k=r,c=s["".concat(p,".").concat(k)]||s[k]||u[k]||l;return t?a.createElement(c,i(i({ref:n},m),{},{components:t})):a.createElement(c,i({ref:n},m))}));function c(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=k;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[s]="string"==typeof e?e:r,i[1]=o;for(var d=2;d<l;d++)i[d]=t[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}k.displayName="MDXCreateElement"},8265:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var a=t(7462),r=(t(7294),t(3905));const l={},i="\ud658\uacbd \ubcc0\uc218 \uc804\ub2ec\ud558\uae30",o={unversionedId:"environment",id:"environment",title:"\ud658\uacbd \ubcc0\uc218 \uc804\ub2ec\ud558\uae30",description:"\uc774\ubc88 \uc7a5\uc5d0\uc11c\ub294 \ube14\ub85c\uadf8 \uc774\ub984, \uc2a4\ud0c0\uc77c\uc2dc\ud2b8 \uc704\uce58\uc640 \uac19\uc740 \ube14\ub85c\uadf8\uc5d0 \ub300\ud55c \uc77c\ubc18\uc801\uc778 \uc815\ubcf4\ub97c \uc720\uc9c0\ud560 \uc218 \uc788\ub294 \ud658\uacbd\uc744 \ucd94\uac00\ud558\uace0\uc790 \ud569\ub2c8\ub2e4.",source:"@site/docs/07-environment.md",sourceDirName:".",slug:"/environment",permalink:"/learn-haskell-blog-generator/environment",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/07-environment.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\uc694\uc57d",permalink:"/learn-haskell-blog-generator/errors_and_files/summary"},next:{title:"Testing",permalink:"/learn-haskell-blog-generator/testing"}},p={},d=[{value:"\ud658\uacbd",id:"\ud658\uacbd",level:2},{value:"ReaderT",id:"readert",level:3},{value:"How to use Reader",id:"how-to-use-reader",level:3},{value:"Defining a function",id:"defining-a-function",level:4},{value:"Extracting <code>Env</code>",id:"extracting-env",level:3},{value:"Run a <code>Reader</code>",id:"run-a-reader",level:3},{value:"Extra: Transforming <code>Env</code> for a particular call",id:"extra-transforming-env-for-a-particular-call",level:3},{value:"Using <code>Env</code> in our logic code",id:"using-env-in-our-logic-code",level:3},{value:"Summary",id:"summary",level:3}],m={toc:d},s="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(s,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"\ud658\uacbd-\ubcc0\uc218-\uc804\ub2ec\ud558\uae30"},"\ud658\uacbd \ubcc0\uc218 \uc804\ub2ec\ud558\uae30"),(0,r.kt)("p",null,"\uc774\ubc88 \uc7a5\uc5d0\uc11c\ub294 \ube14\ub85c\uadf8 \uc774\ub984, \uc2a4\ud0c0\uc77c\uc2dc\ud2b8 \uc704\uce58\uc640 \uac19\uc740 \ube14\ub85c\uadf8\uc5d0 \ub300\ud55c \uc77c\ubc18\uc801\uc778 \uc815\ubcf4\ub97c \uc720\uc9c0\ud560 \uc218 \uc788\ub294 \ud658\uacbd\uc744 \ucd94\uac00\ud558\uace0\uc790 \ud569\ub2c8\ub2e4."),(0,r.kt)("h2",{id:"\ud658\uacbd"},"\ud658\uacbd"),(0,r.kt)("p",null,"\ud658\uacbd\uc740 \ub808\ucf54\ub4dc \ub370\uc774\ud130 \ud0c0\uc785\uc73c\ub85c \ud45c\ud604\ud560 \uc218 \uc788\uc73c\uba70 \uc0ac\uc6a9\uc790 \uc785\ub825\uc744 \ud1b5\ud574 \uad6c\uc131\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\uc5ec\uae30\uc11c \uc0ac\uc6a9\uc790 \uc785\ub825\uc740 \uba85\ub839\ud589 \uc778\uc790, \uad6c\uc131 \ud30c\uc77c \ub610\ub294 \uadf8 \uc678 \ub2e4\ub978 \uac83\ub4e4\uc774 \ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'module HsBlog.Env where\n\ndata Env\n  = Env\n    { eBlogName :: String\n    , eStylesheetPath :: FilePath\n    }\n  deriving Show\n\ndefaultEnv :: Env\ndefaultEnv = Env "My Blog" "style.css"\n')),(0,r.kt)("p",null,"\uc774\ub7ec\ud55c \ub808\ucf54\ub4dc\ub97c \uc694\uccad\ubc1b\uc740 \uc815\ubcf4\ub85c \ucc44\uc6b4\uc774\ud6c4, \ud544\uc694\ub85c \ud558\ub294 \ud568\uc218\uc758 \uc785\ub825\uc73c\ub85c \uc804\ub2ec\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\uc774\ub294 \uc791\uc740 \ud504\ub85c\uc81d\ud2b8\uc5d0\uc11c\ub294 \uc798 \ub3d9\uc791\ud558\uc9c0\ub9cc, \ud504\ub85c\uc81d\ud2b8\uac00 \ucee4\uc9c0\uace0 \ub9ce\uc740 \uc911\ucca9\ub41c \ud568\uc218\ub4e4\uc774 \uac19\uc740 \uc815\ubcf4\ub97c \ud544\uc694\ub85c \ud560 \ub54c\ub294 \ud658\uacbd\uc744 \uc804\ub2ec\ud558\ub294 \uac83\uc774 \ubc88\uac70\ub85c\uc6b8 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("p",null,"\ud568\uc218\uc758 \uc785\ub825\uc73c\ub85c \ud658\uacbd\uc744 \uc804\ub2ec\ud558\ub294 \ub300\uc2e0, ",(0,r.kt)("inlineCode",{parentName:"p"},"mtl")," (\ub610\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"transformers"),") \ud328\ud0a4\uc9c0\uc5d0\uc11c \uc81c\uacf5\ud558\ub294\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Reader.html#g:2"},(0,r.kt)("inlineCode",{parentName:"a"},"ReaderT")),"\n\ud0c0\uc785\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("h3",{id:"readert"},"ReaderT"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"newtype ReaderT r m a = ReaderT (r -> m a)\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT"),"\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"ExceptT"),"\uc640 \ube44\uc2b7\ud55c ",(0,r.kt)("em",{parentName:"p"},"monad transformer"),"\uc774\uba70\n",(0,r.kt)("inlineCode",{parentName:"p"},"Functor"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Applicative"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad")," \uadf8\ub9ac\uace0 ",(0,r.kt)("inlineCode",{parentName:"p"},"MonadTrans"),"\uc758 \uc778\uc2a4\ud134\uc2a4 \ub610\ud55c \uc81c\uacf5\ud569\ub2c8\ub2e4."),(0,r.kt)("p",null,"\uc815\uc758\uc5d0\uc11c \ubcfc \uc218 \uc788\ub4ef\uc774, ",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT"),"\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," \ud0c0\uc785\uc758 \uac12\uc744 \ubc1b\uc544 ",(0,r.kt)("inlineCode",{parentName:"p"},"m a")," \ud0c0\uc785\uc758 \uac12\uc744 \ubc18\ud658\ud558\ub294 \ud568\uc218\ub97c \uac10\uc2fc ",(0,r.kt)("em",{parentName:"p"},"newtype")," \uc785\ub2c8\ub2e4.\n",(0,r.kt)("inlineCode",{parentName:"p"},"r"),"\uc740 \ubcf4\ud1b5 \uc6b0\ub9ac\uac00 \ud569\uc131\ud558\uace0\uc790 \ud558\ub294 \ud568\uc218\ub4e4 \uc0ac\uc774\uc5d0\uc11c \uacf5\uc720\ud558\uace0\uc790 \ud558\ub294 \ud658\uacbd\uc744 \ub098\ud0c0\ub0c5\ub2c8\ub2e4.\n\uadf8\ub9ac\uace0 ",(0,r.kt)("inlineCode",{parentName:"p"},"m a"),"\ub294 \uc6b0\ub9ac\uac00 \ubc18\ud658\ud558\uace0\uc790 \ud558\ub294 \uacb0\uacfc\ub97c \ub098\ud0c0\ub0c5\ub2c8\ub2e4.\n",(0,r.kt)("inlineCode",{parentName:"p"},"m"),"\uc740 \uc6b0\ub9ac\uac00 \uc775\uc219\ud55c ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad"),"\ub97c \uad6c\ud604\ud558\ub294 \uc5b4\ub5a4 \ud0c0\uc785\uc774\ub4e0 \ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\ubcf4\ud1b5 ",(0,r.kt)("inlineCode",{parentName:"p"},"IO")," \ub610\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"Identity"),"\uc640 \uc798 \uc5b4\uc6b8\ub9ac\ub294\ub370, \ud658\uacbd\uc744 \ud6a8\uacfc\uac00 \uc788\ub294 \ub610\ub294 \ud6a8\uacfc\uac00 \uc5c6\ub294 \uacc4\uc0b0 \uc0ac\uc774\uc5d0\uc11c \uacf5\uc720\ud558\uace0\uc790 \ud560 \ub54c\uc5d0 \ub530\ub77c \ub2e4\ub985\ub2c8\ub2e4."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT"),"\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," \ud0c0\uc785\uc758 \uac12\uc744 ",(0,r.kt)("em",{parentName:"p"},"\uac00\uc9c0\uace0 \uc788\uace0")," ",(0,r.kt)("inlineCode",{parentName:"p"},"Applicative"),"\uacfc ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad")," \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc0ac\uc6a9\ud560 \ub54c \ub2e4\ub978 \ud568\uc218\ub4e4\uc5d0\uac8c ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," \ud0c0\uc785\uc758 \uac12\uc744 \uc804\ub2ec\ud569\ub2c8\ub2e4.\n\ub530\ub77c\uc11c \uc9c1\uc811 ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," \ud0c0\uc785\uc758 \uac12\uc744 \uc804\ub2ec\ud558\uc9c0 \uc54a\uc544\ub3c4 \ub429\ub2c8\ub2e4.\n\ud544\uc694\ud55c \uacbd\uc6b0 \ub2e8\uc21c\ud788 ",(0,r.kt)("inlineCode",{parentName:"p"},"ask"),"\ub97c \uc0ac\uc6a9\ud558\uba74 \ub429\ub2c8\ub2e4."),(0,r.kt)("p",null,"\ube14\ub85c\uadf8\uc758 \uacbd\uc6b0 ",(0,r.kt)("inlineCode",{parentName:"p"},"Env"),"\ub97c \uc804\ub2ec\ud558\ub294 \ub300\uc2e0 \uc6b0\ub9ac\uc758 \ud568\uc218\ub4e4\uc744 ",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT"),"\ub97c \uc0ac\uc6a9\ud558\uac8c \ubcc0\uacbd\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\ud6a8\uacfc\uac00 \uc5c6\uace0 ",(0,r.kt)("inlineCode",{parentName:"p"},"IO"),"\ub97c \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uc73c\uba74 ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," \ub300\uc2e0 ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader Env a"),"\ub97c \ubc18\ud658\ud558\uace0 (\ub610\ub294 \ub354 \uac04\ub2e8\ud55c \ubc84\uc804\uc778 ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader Env a"),"),\n\ud6a8\uacfc\uac00 \uc788\ub294 \uacbd\uc6b0 ",(0,r.kt)("inlineCode",{parentName:"p"},"IO a")," \ub300\uc2e0 ",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT Env IO a"),"\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4."),(0,r.kt)("p",null,"\uc774\uc804\uc5d0 \uc5b8\uae09\ud588\ub4ef\uc774, ",(0,r.kt)("inlineCode",{parentName:"p"},"Functor"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Applicative")," \uadf8\ub9ac\uace0 ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad"),"\ub294 \uc774\ub4e4\uc758 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud55c \ud0c0\uc785\uc774 ",(0,r.kt)("inlineCode",{parentName:"p"},"* -> *")," kind\ub97c \uac00\uc838\uc57c\ud569\ub2c8\ub2e4.\n\uc774\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT r m"),"\uc774 \uc774\ub4e4\uc758 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud558\uace0, \ud568\uc218\ub4e4\uc744 ",(0,r.kt)("inlineCode",{parentName:"p"},"<*>")," \ub610\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},">>="),"\ub85c \ud569\uc131\ud560 \ub54c ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," \ub610\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),"\uc744 \ud0c0\uc785 \uc2dc\uadf8\ub2c8\ucc98\uc5d0\uc11c ",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT r m"),"\uc73c\ub85c \ub300\uccb4\ud55c\ub2e4\ub294 \uac83\uc744 \uc758\ubbf8\ud569\ub2c8\ub2e4."),(0,r.kt)("p",null,"\uc774\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"Either e"),"\uc758 \uacbd\uc6b0 \uac19\uc740 \uc5d0\ub7ec\ud0c0\uc785\uc744 \uac00\uc9c4 \ud568\uc218\ub07c\ub9ac\ub9cc \ud569\uc131\ud560 \uc218 \uc788\uc5c8\ub358 \uac83\uacfc \ube44\uc2b7\ud558\uac8c,\n",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT r m"),"\uc758 \uacbd\uc6b0 \uac19\uc740 ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," \ud0c0\uc785\uacfc \uac19\uc740 ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," \ud0c0\uc785\uc744 \uac00\uc9c4 \ud568\uc218\ub07c\ub9ac\ub9cc \ud569\uc131\ud560 \uc218 \uc788\ub2e4\ub294 \uac83\uc744 \uc758\ubbf8\ud569\ub2c8\ub2e4."),(0,r.kt)("p",null,"\uc6b0\ub9ac\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),"\uc744 ",(0,r.kt)("inlineCode",{parentName:"p"},"Identity"),"\ub85c \ud558\ub294 \ud2b9\uc218\ud654\ub41c ",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT"),"\uc778\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Reader.html#g:2"},(0,r.kt)("inlineCode",{parentName:"a"},"Reader")),"\n\ub97c \uc0ac\uc6a9\ud560 \uc608\uc815\uc778\ub514\u314f.\n",(0,r.kt)("inlineCode",{parentName:"p"},"Control.Monad.Reader"),"\ub294 \ub2e4\uc74c alias\ub97c \uc81c\uacf5\ud569\ub2c8\ub2e4: ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader r a = ReaderT r Identity a"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\ub9cc\uc57d ",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT"),"\uc5d0 \ub300\ud55c \uac1c\ub150\uc774 \uc544\uc9c1 \ud63c\ub780\uc2a4\ub7fd\uace0 ",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT"),"\uac00 \uc5b4\ub5bb\uac8c \ub3d9\uc791\ud558\ub294\uc9c0 \ub354 \uc798 \uc774\ud574\ud558\uace0 \uc2f6\ub2e4\uba74, \ub2e4\uc74c \uc5f0\uc2b5\ubb38\uc81c\ub97c \ud480\uc5b4\ubcf4\uc138\uc694:"),(0,r.kt)("ol",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Applicative")," \ub610\ub294 ",(0,r.kt)("inlineCode",{parentName:"li"},"Monad")," \uc778\ud130\ud398\uc774\uc2a4 \ud568\uc218\ub97c \uc120\ud0dd\ud558\uc138\uc694. \uac1c\uc778\uc801\uc73c\ub85c ",(0,r.kt)("inlineCode",{parentName:"li"},"liftA2"),"\ub97c \ucd94\ucc9c\ud569\ub2c8\ub2e4.\n\uadf8\ub9ac\uace0 ",(0,r.kt)("inlineCode",{parentName:"li"},"f")," (\ub610\ub294 ",(0,r.kt)("inlineCode",{parentName:"li"},"m"),")\ub97c ",(0,r.kt)("inlineCode",{parentName:"li"},"ReaderT")," \ud0c0\uc785\uc778 ",(0,r.kt)("inlineCode",{parentName:"li"},"ReaderT Int IO"),"\uc640 \uac19\uc740 \uad6c\uccb4\uc801\uc778 \ud0c0\uc785\uc73c\ub85c \ub300\uccb4\ud558\uc5ec \ud0c0\uc785 \uc2dc\uadf8\ub2c8\ucc98\ub97c \ud2b9\uc218\ud654\ud558\uc138\uc694."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"ReaderT")," newtype\uc744 \ud480\uc5b4 ",(0,r.kt)("inlineCode",{parentName:"li"},"ReaderT Int IO t"),"\ub97c ",(0,r.kt)("inlineCode",{parentName:"li"},"Int -> IO t"),"\ub85c \ub300\uccb4\ud558\uc138\uc694."),(0,r.kt)("li",{parentName:"ol"},"\uc120\ud0dd\ud55c \ud568\uc218\ub97c \ud2b9\uc218\ud654\ub41c \ud0c0\uc785\uc5d0 \ub300\ud574 \uad6c\ud604\ud558\uc138\uc694.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"liftA2\uc5d0 \ub300\ud55c \uc815\ub2f5"),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"(1)\ubc88 \uc815\ub2f5"),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- \ud2b9\uc218\ud654: `f`\ub97c `ReaderT Env IO`\ub85c \ub300\uccb4\nliftA2 :: (a -> b -> c) -> ReaderT Env IO a -> ReaderT Env IO b -> ReaderT Env IO c\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"(2)\ubc88 \uc815\ub2f5"),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- newtype \ud574\uc81c, `ReaderT Env IO a`\ub97c `Env -> IO a`\ub85c \ub300\uccb4\nliftA2 :: (a -> b -> c) -> (Env -> IO a) -> (Env -> IO b) -> (Env -> IO c)\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"(3)\ubc88 \uc815\ub2f5"),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"specialLiftA2 :: (a -> b -> c) -> (Env -> IO a) -> (Env -> IO b) -> (Env -> IO c)\nspecialLiftA2 combine funcA funcB env =\n  liftA2 combine (funcA env) (funcB env)\n")),(0,r.kt)("p",{parentName:"blockquote"},"\uc774\ub7ec\ud55c ",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT"),"\uc5d0 \ub300\ud55c ",(0,r.kt)("inlineCode",{parentName:"p"},"liftA2"),"\uc758 \uc5ed\ud560\uc740 \ub450 \ud568\uc218\uc5d0 ",(0,r.kt)("inlineCode",{parentName:"p"},"env"),"\ub97c \uc81c\uacf5\ud558\uace0, \ub098\uba38\uc9c0 \uc77c\uc740 \uae30\ubc18 \ud0c0\uc785 ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," (\uc6b0\ub9ac\uc758 \uacbd\uc6b0 ",(0,r.kt)("inlineCode",{parentName:"p"},"IO"),")\uc758 ",(0,r.kt)("inlineCode",{parentName:"p"},"liftA2")," \uad6c\ud604\uc5d0 \uc704\uc784\ud558\ub294 \uac83\uc744 \uc54c \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\uc774\ub7ec\ud55c \ud615\ud0dc\ub294 \ub2e4\uc591\ud55c ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),"\uc5d0 \ub300\ud574 \uae30\ub2a5\uc744 \ucd94\uac00\ud558\ub294 \uac83\ucc98\ub7fc \ubcf4\uc774\uc9c0 \uc54a\ub098\uc694?\n\uc774\uac83\uc774 \ubc14\ub85c monad transformer\uc758 \uc544\uc774\ub514\uc5b4\uc785\ub2c8\ub2e4.")))),(0,r.kt)("h3",{id:"how-to-use-reader"},"How to use Reader"),(0,r.kt)("h4",{id:"defining-a-function"},"Defining a function"),(0,r.kt)("p",null,"Instead of defining a function like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"txtsToRenderedHtml :: Env -> [(FilePath, String)] -> [(FilePath, String)]\n")),(0,r.kt)("p",null,"We define it like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"txtsToRenderedHtml :: [(FilePath, String)] -> Reader Env [(FilePath, String)]\n")),(0,r.kt)("p",null,"Now that our code uses ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader"),", we have to accommodate that in the way we write our functions."),(0,r.kt)("p",null,"Before:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'txtsToRenderedHtml :: Env -> [(FilePath, String)] -> [(FilePath, String)]\ntxtsToRenderedHtml env txtFiles =\n let\n   txtOutputFiles = map toOutputMarkupFile txtFiles\n   index = ("index.html", buildIndex env txtOutputFiles)\n   htmlPages = map (convertFile env) txtOutputFiles\n in\n   map (fmap Html.render) (index : htmlPages)\n')),(0,r.kt)("p",null,"Note how we needed to thread the ",(0,r.kt)("inlineCode",{parentName:"p"},"env")," to the other functions that use it."),(0,r.kt)("p",null,"After:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'txtsToRenderedHtml :: [(FilePath, String)] -> Reader Env [(FilePath, String)]\ntxtsToRenderedHtml txtFiles = do\n  let\n    txtOutputFiles = map toOutputMarkupFile txtFiles\n  index <- (,) "index.html" <$> buildIndex txtOutputFiles\n  htmlPages <- traverse convertFile txtOutputFiles\n  pure $ map (fmap Html.render) (index : htmlPages)\n')),(0,r.kt)("p",null,"Note how we use ",(0,r.kt)("em",{parentName:"p"},"do notation")," now, and ",(0,r.kt)("em",{parentName:"p"},"instead of threading")," ",(0,r.kt)("inlineCode",{parentName:"p"},"env")," around we ",(0,r.kt)("em",{parentName:"p"},"compose"),"\nthe relevant functions, ",(0,r.kt)("inlineCode",{parentName:"p"},"buildIndex")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"convertFile"),", we use the type classes\ninterfaces to compose the functions. Note how we needed to ",(0,r.kt)("inlineCode",{parentName:"p"},"fmap")," over ",(0,r.kt)("inlineCode",{parentName:"p"},"buildIndex"),"\nto add the output file we needed with the tuple, and how we needed to use ",(0,r.kt)("inlineCode",{parentName:"p"},"traverse")," instead\nof ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," to compose the various ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader")," values ",(0,r.kt)("inlineCode",{parentName:"p"},"convertFile")," will produce."),(0,r.kt)("h3",{id:"extracting-env"},"Extracting ",(0,r.kt)("inlineCode",{parentName:"h3"},"Env")),(0,r.kt)("p",null,"When we want to use our ",(0,r.kt)("inlineCode",{parentName:"p"},"Env"),", we need to ",(0,r.kt)("em",{parentName:"p"},"extract")," it from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader"),".\nWe can do it with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ask :: ReaderT r m r\n")),(0,r.kt)("p",null,"Which yanks the ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader")," - we can extract with ",(0,r.kt)("inlineCode",{parentName:"p"},">>=")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"<-")," in do notation.\nSee the comparison:"),(0,r.kt)("p",null,"Before:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"convertFile :: Env -> (FilePath, Markup.Document) -> (FilePath, Html.Html)\nconvertFile env (file, doc) =\n  (file, convert env (takeBaseName file) doc)\n")),(0,r.kt)("p",null,"After:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"convertFile :: (FilePath, Markup.Document) -> Reader Env (FilePath, Html.Html)\nconvertFile (file, doc) = do\n  env <- ask\n  pure (file, convert env (takeBaseName file) doc)\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: we didn't change ",(0,r.kt)("inlineCode",{parentName:"p"},"convert")," to use ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader")," because it is a user facing API for our\nlibrary. By providing a simpler interface we allow more users to use our library -\neven those that aren't yet familiar with monad transformers."),(0,r.kt)("p",{parentName:"blockquote"},"Providing a simple function argument passing interface is preferred in this case.")),(0,r.kt)("h3",{id:"run-a-reader"},"Run a ",(0,r.kt)("inlineCode",{parentName:"h3"},"Reader")),(0,r.kt)("p",null,"Similar to handling the errors with ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),", at some point we need to supply the environment to\na computation that uses ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader"),", and extract the result from the computation.\nWe can do that with the functions ",(0,r.kt)("inlineCode",{parentName:"p"},"runReader")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"runReaderT"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"runReader :: Reader r a -> (r -> a)\n\nrunReaderT :: ReaderT r m a -> (r -> m a)\n")),(0,r.kt)("p",null,"These functions convert a ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT")," to a function that takes ",(0,r.kt)("inlineCode",{parentName:"p"},"r"),".\nThen we can pass the initial environment to that function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'convertDirectory :: Env -> FilePath -> FilePath -> IO ()\nconvertDirectory env inputDir outputDir = do\n  DirContents filesToProcess filesToCopy <- getDirFilesAndContent inputDir\n  createOutputDirectoryOrExit outputDir\n  let\n    outputHtmls = runReader (txtsToRenderedHtml filesToProcess) env\n  copyFiles outputDir filesToCopy\n  writeFiles outputDir outputHtmls\n  putStrLn "Done."\n')),(0,r.kt)("p",null,"See the ",(0,r.kt)("inlineCode",{parentName:"p"},"let outputHtmls"),"part."),(0,r.kt)("h3",{id:"extra-transforming-env-for-a-particular-call"},"Extra: Transforming ",(0,r.kt)("inlineCode",{parentName:"h3"},"Env")," for a particular call"),(0,r.kt)("p",null,"Sometimes we may want to modify the ",(0,r.kt)("inlineCode",{parentName:"p"},"Env")," we pass to a particular function call.\nFor example, we may have a general ",(0,r.kt)("inlineCode",{parentName:"p"},"Env")," type that contains a lot of information, and\nfunctions that only need a part of that information."),(0,r.kt)("p",null,"If the functions we are calling are like ",(0,r.kt)("inlineCode",{parentName:"p"},"convert")," and take the environment as an\nargument instead of a ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader"),", we can just extract the environment\nwith ",(0,r.kt)("inlineCode",{parentName:"p"},"ask"),", apply a function to the extracted environment,\nand pass the result to the function, like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"outer :: Reader BigEnv MyResult\nouter = do\n  env <- ask\n  pure (inner (extractSmallEnv env))\n\ninner :: SmallEnv -> MyResult\ninner = ...\n\nextractSmallEnv :: BigEnv -> SmallEnv\nextractSmallEnv = ...\n")),(0,r.kt)("p",null,"But if ",(0,r.kt)("inlineCode",{parentName:"p"},"inner")," uses a ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader SmallEnv")," instead of argument passing,\nwe can use ",(0,r.kt)("inlineCode",{parentName:"p"},"runReader")," to ",(0,r.kt)("em",{parentName:"p"},"convert ",(0,r.kt)("inlineCode",{parentName:"em"},"inner")," to a normal function"),",\nand use the same idea as above!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"outer :: Reader BigEnv MyResult\nouter = do\n  env <- ask\n  -- Here the type of `runReader inner` is `SmallEnv -> MyResult`\n  pure (runReader inner (extractSmallEnv env))\n\ninner :: Reader SmallEnv MyResult\ninner = ...\n\nextractSmallEnv :: BigEnv -> SmallEnv\nextractSmallEnv = ...\n")),(0,r.kt)("p",null,"This pattern is generalized and captured by a function called\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/transformers-0.6.0.2/docs/Control-Monad-Trans-Reader.html#v:withReaderT"},"withReaderT"),",\nand works even for ",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"withReaderT :: (env2 -> env1) -> ReaderT env1 m a -> ReaderT env2 m a\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"withReaderT")," takes a function that modifies the environment,\nand converts a ",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT env1 m a")," computation to a ",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT env2 m a")," computation\nusing this function."),(0,r.kt)("p",null,"Let's see it concretely with our example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"outer :: Reader BigEnv MyResult\nouter = withReaderT extractSmallEnv inner\n")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Question: what is the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"withReaderT")," when specialized in our case?"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Answer"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"withReaderT\n  :: (BigEnv -> SmallEnv)     -- This is the type of `extractSmallEnv`\n  -> Reader SmallEnv MyResult -- This is the type of `inner`\n  -> Reader BigEnv   MyResult -- This is the type of `outer`\n"))),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Note the order of the environments! We use a function from a ",(0,r.kt)("inlineCode",{parentName:"p"},"BigEnv")," to a ",(0,r.kt)("inlineCode",{parentName:"p"},"SmallEnv"),",\nto convert a ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"SmallEnv")," to a ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"BigEnv"),"!"),(0,r.kt)("p",null,"This is because we are mapping over the ",(0,r.kt)("em",{parentName:"p"},"input")," of a function rather than the ",(0,r.kt)("em",{parentName:"p"},"output"),",\nand is related to topics like variance and covariance, but isn't terribly important\nfor us at the moment."),(0,r.kt)("h3",{id:"using-env-in-our-logic-code"},"Using ",(0,r.kt)("inlineCode",{parentName:"h3"},"Env")," in our logic code"),(0,r.kt)("p",null,"One thing we haven't talked about yet is using our environment in the ",(0,r.kt)("inlineCode",{parentName:"p"},"convert"),"\nfunction to generate the pages we want. And actually, we don't even have the ability to add\nstylesheets to our HTML EDSL at the moment! We need to go back and extend it. Let's do all\nthat now:"),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Since stylesheets go in the ",(0,r.kt)("inlineCode",{parentName:"p"},"head")," element, perhaps it's a good idea to create an additional\n",(0,r.kt)("inlineCode",{parentName:"p"},"newtype")," like ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"head")," information? Things like title, stylesheet,\nand even meta elements can be composed together just like we did for ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure"),"\nto build the ",(0,r.kt)("inlineCode",{parentName:"p"},"head"),"!"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Do it now: extend our HTML library to include headings and add 3 functions:\n",(0,r.kt)("inlineCode",{parentName:"p"},"title_")," for titles, ",(0,r.kt)("inlineCode",{parentName:"p"},"stylesheet_")," for stylesheets, and ",(0,r.kt)("inlineCode",{parentName:"p"},"meta_")," for meta elements\nlike ",(0,r.kt)("a",{parentName:"p",href:"https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/abouts-cards"},"twitter cards"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"src/HsBlog/Html.hs"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- Html.hs\n\nmodule HsBlog.Html\n  ( Html\n  , Head\n  , title_\n  , stylesheet_\n  , meta_\n  , Structure\n  , html_\n  , p_\n  , h_\n  , ul_\n  , ol_\n  , code_\n , Content\n  , txt_\n  , img_\n  , link_\n  , b_\n  , i_\n  , render\n  )\n  where\n\nimport Prelude hiding (head)\nimport HsBlog.Html.Internal\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"src/HsBlog/Html/Internal.hs"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'newtype Head\n  = Head String\n\n-- * EDSL\n\nhtml_ :: Head -> Structure -> Html\nhtml_ (Head head) content =\n  Html\n    ( el "html"\n      ( el "head" head\n        <> el "body" (getStructureString content)\n      )\n    )\n\n-- * Head\n\ntitle_ :: String -> Head\ntitle_ = Head . el "title" . escape\n\nstylesheet_ :: FilePath -> Head\nstylesheet_ path =\n  Head $ "<link rel=\\"stylesheet\\" type=\\"text/css\\" href=\\"" <> escape path <> "\\">"\n\nmeta_ :: String -> String -> Head\nmeta_ name content =\n  Head $ "<meta name=\\"" <> escape name <> "\\" content=\\"" <> escape content <> "\\">"\n\ninstance Semigroup Head where\n  (<>) (Head h1) (Head h2) =\n    Head (h1 <> h2)\n\ninstance Monoid Head where\n  mempty = Head ""\n'))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Fix ",(0,r.kt)("inlineCode",{parentName:"p"},"convert")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"buildIndex")," to use the new API. Note: ",(0,r.kt)("inlineCode",{parentName:"p"},"buildIndex")," should return\n",(0,r.kt)("inlineCode",{parentName:"p"},"Reader"),"!"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"src/HsBlog/Convert.hs"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'import Prelude hiding (head)\nimport HsBlog.Env (Env(..))\n\nconvert :: Env -> String -> Markup.Document -> Html.Html\nconvert env title doc =\n  let\n    head =\n      Html.title_ (eBlogName env <> " - " <> title)\n        <> Html.stylesheet_ (eStylesheetPath env)\n    article =\n      foldMap convertStructure doc\n    websiteTitle =\n      Html.h_ 1 (Html.link_ "index.html" $ Html.txt_ $ eBlogName env)\n    body =\n      websiteTitle <> article\n  in\n    Html.html_ head body\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"src/HsBlog/Directory.hs"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'buildIndex :: [(FilePath, Markup.Document)] -> Reader Env Html.Html\nbuildIndex files = do\n  env <- ask\n  let\n    previews =\n      map\n        ( \\(file, doc) ->\n          case doc of\n            Markup.Head 1 head : article ->\n              Html.h_ 3 (Html.link_ file (Html.txt_ head))\n                <> foldMap convertStructure (take 2 article)\n                <> Html.p_ (Html.link_ file (Html.txt_ "..."))\n            _ ->\n              Html.h_ 3 (Html.link_ file (Html.txt_ file))\n        )\n        files\n  pure $ Html.html_\n      ( Html.title_ (eBlogName env)\n        <> Html.stylesheet_ (eStylesheetPath env)\n      )\n      ( Html.h_ 1 (Html.link_ "index.html" (Html.txt_ "Blog"))\n        <> Html.h_ 2 (Html.txt_ "Posts")\n        <> mconcat previews\n      )\n'))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Create a command-line parser for ",(0,r.kt)("inlineCode",{parentName:"p"},"Env"),", attach it to the ",(0,r.kt)("inlineCode",{parentName:"p"},"convert-dir")," command,\nand pass the result it to the ",(0,r.kt)("inlineCode",{parentName:"p"},"convertDirectory")," function."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"src/HsBlog.hs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import HsBlog.Env (defaultEnv)\n\nconvertSingle :: String -> Handle -> Handle -> IO ()\n\nprocess :: String -> String -> String\nprocess title = Html.render . convert defaultEnv title . Markup.parse\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"app/OptParse.hs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'import HsBlog.Env\n\n------------------------------------------------\n-- * Our command-line options model\n\n-- | Model\ndata Options\n = ConvertSingle SingleInput SingleOutput\n | ConvertDir FilePath FilePath Env\n deriving Show\n\n------------------------------------------------\n-- * Directory conversion parser\n\npConvertDir :: Parser Options\npConvertDir =\n ConvertDir <$> pInputDir <*> pOutputDir <*> pEnv\n\n-- | Parser for blog environment\npEnv :: Parser Env\npEnv =\n Env <$> pBlogName <*> pStylesheet\n\n-- | Blog name parser\npBlogName :: Parser String\npBlogName =\n strOption\n   ( long "name"\n     <> short \'N\'\n     <> metavar "STRING"\n     <> help "Blog name"\n     <> value (eBlogName defaultEnv)\n     <> showDefault\n   )\n\n-- | Stylesheet parser\npStylesheet :: Parser String\npStylesheet =\n strOption\n   ( long "style"\n     <> short \'S\'\n     <> metavar "FILE"\n     <> help "Stylesheet filename"\n     <> value (eStylesheetPath defaultEnv)\n     <> showDefault\n   )\n\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"app/Main.hs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"main :: IO ()\nmain = do\n options <- parse\n case options of\n   ConvertDir input output env ->\n     HsBlog.convertDirectory env input output\n\n   ...\n")))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"summary"},"Summary"),(0,r.kt)("p",null,"Which version do you like better? Manually passing arguments, or using ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader"),"?"),(0,r.kt)("p",null,"To me, it is not clear that the second version with ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader")," is better than the first\nwith explicit argument passing in our particular case."),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ReaderT")," makes our code a little less friendly toward beginners\nthat are not yet familiar with these concepts and techniques, and we don't see\n(in this case) much benefit."),(0,r.kt)("p",null,"As programs grow larger, techniques like using ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader")," become more attractive to use.\nFor our relatively small example, using ",(0,r.kt)("inlineCode",{parentName:"p"},"Reader")," might not be appropriate.\nI've included it in this book because it is an important technique to have in our\narsenal and I wanted to demonstrate it."),(0,r.kt)("p",null,"It is important to weigh the benefits and costs of using advanced techniques,\nand it's often better to try and get away with simpler techniques if we can."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"You can view the git commit of\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/commit/f9fe7179fcf0e6c818f6caa860b52e991432dab2"},"the changes we've made"),"\nand the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/tree/f9fe7179fcf0e6c818f6caa860b52e991432dab2"},"code up until now"),".")))}u.isMDXComponent=!0}}]);