"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[974],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),u=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=u(e.components);return a.createElement(p.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,k=m["".concat(p,".").concat(d)]||m[d]||c[d]||l;return n?a.createElement(k,i(i({ref:t},s),{},{components:n})):a.createElement(k,i({ref:t},s))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=d;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[m]="string"==typeof e?e:r,i[1]=o;for(var u=2;u<l;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9524:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const l={},i="Converting Markup to HTML",o={unversionedId:"glue/markup-to-html",id:"glue/markup-to-html",title:"Converting Markup to HTML",description:"One key part is missing before we can glue everything together, and that is",source:"@site/docs/05-glue/01-markup-to-html.md",sourceDirName:"05-glue",slug:"/glue/markup-to-html",permalink:"/learn-haskell-blog-generator/glue/markup-to-html",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/05-glue/01-markup-to-html.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Gluing things together",permalink:"/learn-haskell-blog-generator/glue/"},next:{title:"Working with IO",permalink:"/learn-haskell-blog-generator/glue/io"}},p={},u=[{value:"Qualified Imports",id:"qualified-imports",level:2},{value:"Converting <code>Markup.Structure</code> to <code>Html.Structure</code>",id:"converting-markupstructure-to-htmlstructure",level:2},{value:"Document -&gt; Html",id:"document---html",level:2},{value:"Monoids",id:"monoids",level:2},{value:"Another abstraction?",id:"another-abstraction",level:2},{value:"Finishing our conversion module",id:"finishing-our-conversion-module",level:2},{value:"Summary",id:"summary",level:2}],s={toc:u},m="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"converting-markup-to-html"},"Converting Markup to HTML"),(0,r.kt)("p",null,"One key part is missing before we can glue everything together, and that is\nto convert our ",(0,r.kt)("inlineCode",{parentName:"p"},"Markup")," data types to ",(0,r.kt)("inlineCode",{parentName:"p"},"Html"),"."),(0,r.kt)("p",null,"We'll start by creating a new module and import both the ",(0,r.kt)("inlineCode",{parentName:"p"},"Markup")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"Html")," modules."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"module Convert where\n\nimport qualified Markup\nimport qualified Html\n")),(0,r.kt)("h2",{id:"qualified-imports"},"Qualified Imports"),(0,r.kt)("p",null,"This time, we've imported the modules qualified. Qualified imports means that\ninstead of exposing the names that we've defined in the imported module to\nthe general module name space, they now have to be prefixed with the module name."),(0,r.kt)("p",null,"For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"parse")," becomes ",(0,r.kt)("inlineCode",{parentName:"p"},"Markup.parse"),".\nIf we would've imported ",(0,r.kt)("inlineCode",{parentName:"p"},"Html.Internal")," qualified, we'd have to write\n",(0,r.kt)("inlineCode",{parentName:"p"},"Html.Internal.el")," which is a bit long."),(0,r.kt)("p",null,"We can also give the module a new name with the ",(0,r.kt)("inlineCode",{parentName:"p"},"as")," keyword:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import qualified Html.Internal as HI\n")),(0,r.kt)("p",null,"And write ",(0,r.kt)("inlineCode",{parentName:"p"},"HI.el")," instead."),(0,r.kt)("p",null,"I like using qualified imports because readers do not have to guess where a\nname comes from. Some modules are even designed to be imported qualified.\nFor example, the APIs of many container types such as maps, sets, and vectors, are very similar.\nIf we want to use multiple containers in a single module we pretty much have\nto use qualified imports so that when we write a function such as ",(0,r.kt)("inlineCode",{parentName:"p"},"singleton"),",\nwhich creates a container with a single value, GHC will know which ",(0,r.kt)("inlineCode",{parentName:"p"},"singleton"),"\nfunction we are referring to."),(0,r.kt)("p",null,"Some people prefer to use import lists instead of qualified imports,\nbecause qualified names can be a bit verbose and noisy.\nI will often prefer qualified imports to import lists, but feel free to\ntry both solutions and see which fits you better.\nFor more information about imports,\nsee this ",(0,r.kt)("a",{parentName:"p",href:"https://wiki.haskell.org/Import"},"wiki article"),"."),(0,r.kt)("h2",{id:"converting-markupstructure-to-htmlstructure"},"Converting ",(0,r.kt)("inlineCode",{parentName:"h2"},"Markup.Structure")," to ",(0,r.kt)("inlineCode",{parentName:"h2"},"Html.Structure")),(0,r.kt)("p",null,"Converting a markup structure to an HTML structure is mostly straightforward\nat this point, we need to pattern match on the markup structure and use\nthe relevant HTML API."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"convertStructure :: Markup.Structure -> Html.Structure\nconvertStructure structure =\n  case structure of\n    Markup.Heading 1 txt ->\n      Html.h1_ txt\n\n    Markup.Paragraph p ->\n      Html.p_ p\n\n    Markup.UnorderedList list ->\n      Html.ul_ $ map Html.p_ list\n\n    Markup.OrderedList list ->\n      Html.ol_ $ map Html.p_ list\n\n    Markup.CodeBlock list ->\n      Html.code_ (unlines list)\n")),(0,r.kt)("p",null,"Notice that running this code with ",(0,r.kt)("inlineCode",{parentName:"p"},"-Wall")," will reveal that the pattern matching\nis ",(0,r.kt)("em",{parentName:"p"},"non-exhaustive"),". This is because we don't currently have a way to build\nheadings that are not ",(0,r.kt)("inlineCode",{parentName:"p"},"h1"),". There are a few ways to handle this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Ignore the warning - this will likely fail at runtime one day and the user will be sad"),(0,r.kt)("li",{parentName:"ul"},"Pattern match other cases and add a nice error with the ",(0,r.kt)("inlineCode",{parentName:"li"},"error")," function - it has\nthe same disadvantage above, but will also no longer notify of the unhandled\ncases at compile time"),(0,r.kt)("li",{parentName:"ul"},"Pattern match and do the wrong thing - user is still sad"),(0,r.kt)("li",{parentName:"ul"},"Encode errors in the type system using ",(0,r.kt)("inlineCode",{parentName:"li"},"Either"),", we'll see how to do this in later\nchapters"),(0,r.kt)("li",{parentName:"ul"},"Restrict the input - change ",(0,r.kt)("inlineCode",{parentName:"li"},"Markup.Heading")," to not include a number but rather\nspecific supported headings. This is a reasonable approach"),(0,r.kt)("li",{parentName:"ul"},"Implement an HTML function supporting arbitrary headings. Should be straightforward\nto do")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Exercise: Implement ",(0,r.kt)("inlineCode",{parentName:"p"},"h_ :: Natural -> String -> Structure"),"\nwhich we'll use to define arbitrary headings (such as ",(0,r.kt)("inlineCode",{parentName:"p"},"<h1>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"<h2>"),", and so on)."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'import Numeric.Natural\n\nh_ :: Natural -> String -> Structure\nh_ n = Structure . el ("h" <> show n) . escape\n')),(0,r.kt)("p",null,"Don't forget to export it from ",(0,r.kt)("inlineCode",{parentName:"p"},"Html.hs"),"!")),(0,r.kt)("p",null,"Exercise: Fix ",(0,r.kt)("inlineCode",{parentName:"p"},"convertStructure")," using ",(0,r.kt)("inlineCode",{parentName:"p"},"h_"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"convertStructure :: Markup.Structure -> Html.Structure\nconvertStructure structure =\n  case structure of\n    Markup.Heading n txt ->\n      Html.h_ n txt\n\n    Markup.Paragraph p ->\n      Html.p_ p\n\n    Markup.UnorderedList list ->\n      Html.ul_ $ map Html.p_ list\n\n    Markup.OrderedList list ->\n      Html.ol_ $ map Html.p_ list\n\n    Markup.CodeBlock list ->\n      Html.code_ (unlines list)\n"))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"document---html"},"Document -> Html"),(0,r.kt)("p",null,"In order to create an ",(0,r.kt)("inlineCode",{parentName:"p"},"Html")," document, we need to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"html_")," function.\nThis function expects two things: a ",(0,r.kt)("inlineCode",{parentName:"p"},"Title"),", and a ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure"),"."),(0,r.kt)("p",null,"For a title we could just supply it from outside using the file name."),(0,r.kt)("p",null,"In order to convert our markup ",(0,r.kt)("inlineCode",{parentName:"p"},"Document")," (which is a list of markup ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure"),")\nto an HTML ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure"),", we need to convert each markup ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure")," and then\nconcatenate them together."),(0,r.kt)("p",null,"We already know how to convert each markup ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure"),", we can use the\n",(0,r.kt)("inlineCode",{parentName:"p"},"convertStructure")," function we wrote and ",(0,r.kt)("inlineCode",{parentName:"p"},"map"),". This will provide\nus with the following function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"map convertStructure :: Markup.Document -> [Html.Structure]\n")),(0,r.kt)("p",null,"To concatenate all of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Html.Structure"),", we could try to write a recursive\nfunction. However we will quickly run into an issue\nwith the base case, what to do when the list is empty?"),(0,r.kt)("p",null,"We could just provide dummy ",(0,r.kt)("inlineCode",{parentName:"p"},"Html.Structure")," that represents an empty\nHTML structure."),(0,r.kt)("p",null,"Let's add this to ",(0,r.kt)("inlineCode",{parentName:"p"},"Html.Internal"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'empty_ :: Structure\nempty_ = Structure ""\n')),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Now we can write our recursive function. Try it!"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"concatStructure :: [Structure] -> Structure\nconcatStructure list =\n  case list of\n    [] -> empty_\n    x : xs -> x <> concatStructure xs\n"))),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Remember the ",(0,r.kt)("inlineCode",{parentName:"p"},"<>")," function we implemented as an instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup"),"\ntype class? We mentioned that ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup")," is an ",(0,r.kt)("strong",{parentName:"p"},"abstraction")," for things\nthat implements ",(0,r.kt)("inlineCode",{parentName:"p"},"(<>) :: a -> a -> a"),", where  ",(0,r.kt)("inlineCode",{parentName:"p"},"<>")," is associative\n(",(0,r.kt)("inlineCode",{parentName:"p"},"a <> (b <> c) = (a <> b) <> c"),")."),(0,r.kt)("p",null,"It turns out that having an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup"),' and also having a value that represents\nan "empty" value is a fairly common pattern. For example a string can be concatenated,\nand the empty string can serve as an "empty" value.\nAnd this is actually a well known ',(0,r.kt)("strong",{parentName:"p"},"abstraction")," called ",(0,r.kt)("strong",{parentName:"p"},"monoid"),"."),(0,r.kt)("h2",{id:"monoids"},"Monoids"),(0,r.kt)("p",null,'Actually, "empty" isn\'t a very good description of what we want,\nand isn\'t very useful as an abstraction. Instead, we can describe it as\nan "identity" element, which satisfies the following laws:'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"x <> <identity> = x")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<identity> <> x = x"))),(0,r.kt)("p",null,'In other words, if we try to use this "empty" - this identity value,\nas one argument to ',(0,r.kt)("inlineCode",{parentName:"p"},"<>"),", we will always get the other argument back."),(0,r.kt)("p",null,"For ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),", the empty string, ",(0,r.kt)("inlineCode",{parentName:"p"},'""'),", satisfies this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'"" <> "world" = "world"\n"hello" <> "" = "hello"\n')),(0,r.kt)("p",null,'This is of course true for any value we\'d write and not just "world" and "hello".'),(0,r.kt)("p",null,"Actually, if we move out of the Haskell world for a second, even integers\nwith ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," as the associative binary operations ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," (in place of ",(0,r.kt)("inlineCode",{parentName:"p"},"<>"),")\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," in place of the identity member form a monoid:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"17 + 0 = 17\n0 + 99 = 99\n")),(0,r.kt)("p",null,"So integers together with the ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," operation form a semigroup, and\ntogether with ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," form a monoid."),(0,r.kt)("p",null,"We learn new things from this:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A monoid is a more specific abstraction over semigroup, it builds on it\nby adding a new condition (the existence of an identity member)"),(0,r.kt)("li",{parentName:"ol"},"This abstraction can be useful! We can write a general ",(0,r.kt)("inlineCode",{parentName:"li"},"concatStructure"),"\nthat could work for any monoid")),(0,r.kt)("p",null,"And indeed, there exists a type class in ",(0,r.kt)("inlineCode",{parentName:"p"},"base")," called ",(0,r.kt)("inlineCode",{parentName:"p"},"Monoid")," which has\n",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup")," as a ",(0,r.kt)("strong",{parentName:"p"},"super class"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"class Semigroup a => Monoid a where\n  mempty :: a\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: this is actually a simplified version. The\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#t:Monoid"},"actual"),"\nis a bit more complicated because of backwards compatibility and performance reasons.\n",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup")," was actually introduced in Haskell after ",(0,r.kt)("inlineCode",{parentName:"p"},"Monoid"),"!")),(0,r.kt)("p",null,"We could add an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"Monoid")," for our HTML ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure")," data type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Monoid Structure where\n  mempty = empty_\n")),(0,r.kt)("p",null,"And now, instead of using our own ",(0,r.kt)("inlineCode",{parentName:"p"},"concatStructure"),", we can use the library function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"mconcat :: Monoid a => [a] -> a\n")),(0,r.kt)("p",null,"Which could theoretically be implemented as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"mconcat :: Monoid a => [a] -> a\nmconcat list =\n  case list of\n    [] -> mempty\n    x : xs -> x <> mconcat xs\n")),(0,r.kt)("p",null,"Notice that because ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup")," is a ",(0,r.kt)("em",{parentName:"p"},"super class")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"Monoid"),",\nwe can still use the ",(0,r.kt)("inlineCode",{parentName:"p"},"<>")," function from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup")," class\nwithout adding the ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup a")," constraint to the left side of ",(0,r.kt)("inlineCode",{parentName:"p"},"=>"),".\nBy adding the ",(0,r.kt)("inlineCode",{parentName:"p"},"Monoid a")," constraint we implicitly add a ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup a"),"\nconstraint as well!"),(0,r.kt)("p",null,"This ",(0,r.kt)("inlineCode",{parentName:"p"},"mconcat")," function is very similar to the ",(0,r.kt)("inlineCode",{parentName:"p"},"concatStructure")," function,\nbut this one works for any ",(0,r.kt)("inlineCode",{parentName:"p"},"Monoid"),", including ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure"),"!\nAbstractions help us identify common patterns and ",(0,r.kt)("strong",{parentName:"p"},"reuse")," code!"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Side note: integers with ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," aren't actually an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"Monoid")," in Haskell.\nThis is because integers can also form a monoid with ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"1"),"! But ",(0,r.kt)("strong",{parentName:"p"},"there can only\nbe one instance per type"),". Instead, two other ",(0,r.kt)("inlineCode",{parentName:"p"},"newtype"),"s exist that provide that\nfunctionality, ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Monoid.html#t:Sum"},"Sum"),"\nand ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Monoid.html#t:Product"},"Product"),".\nSee how they can be used in ",(0,r.kt)("inlineCode",{parentName:"p"},"ghci"),":"),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> import Data.Monoid\nghci> Product 2 <> Product 3 -- note, Product is a data constructor\nProduct {getProduct = 6}\nghci> getProduct (Product 2 <> Product 3)\n6\nghci> getProduct $ mconcat $ map Product [1..5]\n120\n"))),(0,r.kt)("h2",{id:"another-abstraction"},"Another abstraction?"),(0,r.kt)("p",null,"We've used ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," and then ",(0,r.kt)("inlineCode",{parentName:"p"},"mconcat")," twice now. Surely there has to be a function\nthat unifies this pattern. And indeed, it is called\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Foldable.html#v:foldMap"},(0,r.kt)("inlineCode",{parentName:"a"},"foldMap")),',\nand it works not only for lists, but also for any data structure that can be "folded",\nor "reduced", into a summary value. This abstraction and type class is called ',(0,r.kt)("strong",{parentName:"p"},"Foldable"),"."),(0,r.kt)("p",null,"For a simpler understanding of ",(0,r.kt)("inlineCode",{parentName:"p"},"Foldable"),", we can look at ",(0,r.kt)("inlineCode",{parentName:"p"},"fold"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"fold :: (Foldable t, Monoid m) => t m -> m\n\n-- compare with\nmconcat :: Monoid m            => [m] -> m\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"mconcat")," is just a specialized version of ",(0,r.kt)("inlineCode",{parentName:"p"},"fold")," for lists.\nAnd ",(0,r.kt)("inlineCode",{parentName:"p"},"fold")," can be a used for any pair of a data structure that implements\n",(0,r.kt)("inlineCode",{parentName:"p"},"Foldable")," and a payload type that implements ",(0,r.kt)("inlineCode",{parentName:"p"},"Monoid"),". This\ncould be ",(0,r.kt)("inlineCode",{parentName:"p"},"[]")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"Product Int"),", or\nyour new shiny binary tree with ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," as the payload type. But note that\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"Foldable")," type must be of ",(0,r.kt)("em",{parentName:"p"},"kind")," ",(0,r.kt)("inlineCode",{parentName:"p"},"* -> *"),". So for example ",(0,r.kt)("inlineCode",{parentName:"p"},"Html"),"\ncannot be a ",(0,r.kt)("inlineCode",{parentName:"p"},"Foldable"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"foldMap")," is a function that allows us to apply a function to the\npayload type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Foldable")," type right before combining them\nwith the ",(0,r.kt)("inlineCode",{parentName:"p"},"<>")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m\n\n-- compare to a specialized version with:\n-- - t ~ []\n-- - m ~ Html.Structure\n-- - a ~ Markup.Structure\nfoldMap\n  :: (Markup.Structure -> Html.Structure)\n  -> [Markup.Structure]\n  -> Html.Structure\n")),(0,r.kt)("p",null,'True to its name, it really "maps" before it "folds". You might pause here\nand think "this \'map\' we are talking about isn\'t specific for lists, maybe\nthat\'s another abstraction?", yes. It is actually a very important and\nfundamental abstraction called ',(0,r.kt)("inlineCode",{parentName:"p"},"Functor"),".\nBut I think we had enough abstractions for this chapter.\nWe'll cover it in a later chapter!"),(0,r.kt)("h2",{id:"finishing-our-conversion-module"},"Finishing our conversion module"),(0,r.kt)("p",null,"Let's finish our code by writing ",(0,r.kt)("inlineCode",{parentName:"p"},"convert"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"convert :: Html.Title -> Markup.Document -> Html.Html\nconvert title = Html.html_ title . foldMap convertStructure\n")),(0,r.kt)("p",null,"Now we have a full implementation and are able to convert markup documents\nto HTML:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- Convert.hs\nmodule Convert where\n\nimport qualified Markup\nimport qualified Html\n\nconvert :: Html.Title -> Markup.Document -> Html.Html\nconvert title = Html.html_ title . foldMap convertStructure\n\nconvertStructure :: Markup.Structure -> Html.Structure\nconvertStructure structure =\n  case structure of\n    Markup.Heading n txt ->\n      Html.h_ n txt\n\n    Markup.Paragraph p ->\n      Html.p_ p\n\n    Markup.UnorderedList list ->\n      Html.ul_ $ map Html.p_ list\n\n    Markup.OrderedList list ->\n      Html.ol_ $ map Html.p_ list\n\n    Markup.CodeBlock list ->\n      Html.code_ (unlines list)\n")),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"We learned about:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Qualified imports"),(0,r.kt)("li",{parentName:"ul"},"Ways to handle errors"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"Monoid")," type class and abstraction"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"Foldable")," type class and abstraction")),(0,r.kt)("p",null,"Next, we are going to glue our functionality together and learn about\nI/O in Haskell!"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"You can view the git commit of\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/commit/ad34f2264e9114f2d7436ff472c78da47055fcfe"},"the changes we've made"),"\nand the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/tree/ad34f2264e9114f2d7436ff472c78da47055fcfe"},"code up until now"),".")))}c.isMDXComponent=!0}}]);