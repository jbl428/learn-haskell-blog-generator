"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[802],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>k});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=s(t),c=r,k=u["".concat(p,".").concat(c)]||u[c]||d[c]||l;return t?a.createElement(k,i(i({ref:n},m),{},{components:t})):a.createElement(k,i({ref:n},m))}));function k(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=c;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[u]="string"==typeof e?e:r,i[1]=o;for(var s=2;s<l;s++)i[s]=t[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},2447:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var a=t(7462),r=(t(7294),t(3905));const l={},i="\ud558\uc2a4\ucf08 \ub370\uc774\ud130 \ud0c0\uc785\uc73c\ub85c \ub9c8\ud06c\uc5c5 \uc5b8\uc5b4 \ud45c\ud604\ud558\uae30",o={unversionedId:"markup/data-type",id:"markup/data-type",title:"\ud558\uc2a4\ucf08 \ub370\uc774\ud130 \ud0c0\uc785\uc73c\ub85c \ub9c8\ud06c\uc5c5 \uc5b8\uc5b4 \ud45c\ud604\ud558\uae30",description:"\ud558\uc2a4\ucf08(\uadf8\ub9ac\uace0 \ub2e4\ub978 ML-\uacc4\uc5f4\uc758 \uc5b8\uc5b4\ub4e4)\uacfc \ub300\ubd80\ubd84\uc758 \uc8fc\ub958 \uc5b8\uc5b4\ub4e4 \uac04\uc758 \uac00\uc7a5 \ud070 \ucc28\uc774\uc810\uc740 \ub370\uc774\ud130\ub97c \uc815\ud655\ud558\uace0 \uac04\uacb0\ud558\uac8c \ud45c\ud604\ud560 \uc218 \uc788\ub2e4\ub294 \uc810\uc785\ub2c8\ub2e4.",source:"@site/docs/04-markup/01-data-type.md",sourceDirName:"04-markup",slug:"/markup/data-type",permalink:"/learn-haskell-blog-generator/markup/data-type",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/04-markup/01-data-type.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\uc0ac\uc6a9\uc790 \uc815\uc758 \ub9c8\ud06c\uc5c5 \uc5b8\uc5b4",permalink:"/learn-haskell-blog-generator/markup/"},next:{title:"Parsing markup part 01 (Recursion)",permalink:"/learn-haskell-blog-generator/markup/parsing-01"}},p={},s=[{value:"Exercises",id:"exercises",level:3},{value:"Translating directly?",id:"translating-directly",level:2}],m={toc:s},u="wrapper";function d(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"\ud558\uc2a4\ucf08-\ub370\uc774\ud130-\ud0c0\uc785\uc73c\ub85c-\ub9c8\ud06c\uc5c5-\uc5b8\uc5b4-\ud45c\ud604\ud558\uae30"},"\ud558\uc2a4\ucf08 \ub370\uc774\ud130 \ud0c0\uc785\uc73c\ub85c \ub9c8\ud06c\uc5c5 \uc5b8\uc5b4 \ud45c\ud604\ud558\uae30"),(0,r.kt)("p",null,"\ud558\uc2a4\ucf08(\uadf8\ub9ac\uace0 \ub2e4\ub978 ML-\uacc4\uc5f4\uc758 \uc5b8\uc5b4\ub4e4)\uacfc \ub300\ubd80\ubd84\uc758 \uc8fc\ub958 \uc5b8\uc5b4\ub4e4 \uac04\uc758 \uac00\uc7a5 \ud070 \ucc28\uc774\uc810\uc740 \ub370\uc774\ud130\ub97c \uc815\ud655\ud558\uace0 \uac04\uacb0\ud558\uac8c \ud45c\ud604\ud560 \uc218 \uc788\ub2e4\ub294 \uc810\uc785\ub2c8\ub2e4."),(0,r.kt)("p",null,"\uadf8\ub807\ub2e4\uba74 \ud558\uc2a4\ucf08\uc744 \uc0ac\uc6a9\ud558\uc5ec \ub9c8\ud06c\uc5c5 \uc5b8\uc5b4\ub97c \uc5b4\ub5bb\uac8c \ud45c\ud604\ud560 \uc218 \uc788\uc744\uae4c\uc694?"),(0,r.kt)("p",null,"\uc774\uc804 HTML \uc0dd\uc131 \ub77c\uc774\ube0c\ub7ec\ub9ac\uc5d0\uc11c\ub294 HTML \ubb38\uc11c, \uad6c\uc870, \uc81c\ubaa9\uc744 \uad6c\ubd84\ud558\uae30 \uc704\ud574 ",(0,r.kt)("inlineCode",{parentName:"p"},"newtype"),"\uc744 \uc0ac\uc6a9\ud588\uc2b5\ub2c8\ub2e4.\n\ud558\uc9c0\ub9cc \ub370\uc774\ud130\ub97c \ubd84\uc11d\ud558\uc9c0 \uc54a\ub294 \uc774\uc0c1, \ubb38\ub2e8\uacfc \uc81c\ubaa9\uacfc \uac19\uc740 \ub2e4\ub978 \uad6c\uc870\ub97c \uad6c\ubd84\ud560 \ud544\uc694\ub294 \uc5c6\uc5c8\uc2b5\ub2c8\ub2e4."),(0,r.kt)("p",null,"\uc774\ub7ec\ud55c \uacbd\uc6b0, \ub3d9\uc77c\ud55c \uad6c\uc870\uc758 \ubaa9\ub85d\uc744 \uac00\uc9c0\uba74\uc11c \uac01 \uad6c\uc870\uc5d0\ub294 \uba87 \uac00\uc9c0 \ud2b9\uc815 \uc635\uc158(\ubb38\ub2e8, \uc81c\ubaa9, \ubaa9\ub85d \ub4f1)\uc744 \uac00\uc9c0\ub294 \ud615\ud0dc\ub97c \uc0dd\uac01\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\uc6b0\ub9ac\ub294 \uac01 \uad6c\uc870\uac00 \uc5b4\ub5a4 \ud56d\ubaa9\uc778\uc9c0\ub9cc \uc54c\uba74 \ub3d9\uc77c\ud55c HTML\ub85c \uc27d\uac8c \ubcc0\ud658\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("p",null,"\uc774\ub97c \uc704\ud574 ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," \uc815\uc758\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n",(0,r.kt)("inlineCode",{parentName:"p"},"data"),"\ub294 \uc5ec\ub7ec \ud0c0\uc785\uc744 \uadf8\ub8f9\ud654\ud558\uc5ec \ub300\uccb4 \uad6c\uc870\ub97c \uac00\uc9c0\ub3c4\ub85d \ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc744 \uc81c\uacf5\ud569\ub2c8\ub2e4.\n",(0,r.kt)("inlineCode",{parentName:"p"},"data"),"\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"struct"),"\uc640 ",(0,r.kt)("inlineCode",{parentName:"p"},"enum"),"\uc758 \uc870\ud569\uc73c\ub85c \uc0dd\uac01\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"data")," \uc120\uc5b8\uc740 \ub2e4\uc74c\uacfc \uac19\uc774 \uc0dd\uacbc\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data <\ud0c0\uc785 \uc774\ub984> <\ud0c0\uc785 \ub9e4\uac1c\ubcc0\uc218>\n  = <\ud0c0\uc785 \uc0dd\uc131\uc7901> <\ud0c0\uc785>\n  | <\ud0c0\uc785 \uc0dd\uc131\uc7902> <\ud0c0\uc785>\n  | ...\n")),(0,r.kt)("p",null,"\uc774\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"newtype"),"\uacfc \ub9e4\uc6b0 \uc720\uc0ac\ud574 \ubcf4\uc774\uc9c0\ub9cc, \ub450 \uac00\uc9c0 \uc911\uc694\ud55c \ucc28\uc774\uc810\uc774 \uc788\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"<types>")," \ubd80\ubd84\uc5d0\uc11c\ub294 \ub9ce\uc740 \ud0c0\uc785(\uc608: ",(0,r.kt)("inlineCode",{parentName:"li"},"Int"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"String"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Bool"),")\uc744 \uc791\uc131\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n",(0,r.kt)("inlineCode",{parentName:"li"},"newtype"),"\uc5d0\uc11c\ub294 \ud558\ub098\ub9cc \uc791\uc131\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"|"),"\ub97c \uc0ac\uc6a9\ud558\uc5ec \uc5ec\ub7ec \uad6c\uc870\ub97c \uac00\uc9c8 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n",(0,r.kt)("inlineCode",{parentName:"li"},"newtype"),"\uc740 \uc624\uc9c1 \ud558\ub098\uc758 \uad6c\uc870\ub9cc \uac00\uc9c8 \uc218 \uc788\uc2b5\ub2c8\ub2e4.")),(0,r.kt)("p",null,"\uc774\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"newtype"),"\uc774 ",(0,r.kt)("strong",{parentName:"p"},"\ud0c0\uc785 \uc548\uc804\ud55c \ubcc4\uce6d"),"\uc744 \uc81c\uacf5\ud558\uae30 \uc704\ud574 \uc0ac\uc6a9\ub418\uace0, ",(0,r.kt)("inlineCode",{parentName:"p"},"data"),"\ub294 \uc0c8\ub85c\uc6b4 ",(0,r.kt)("strong",{parentName:"p"},"\ubcf5\ud569")," \ud0c0\uc785\uc744 \ub9cc\ub4e4\uae30 \uc704\ud574 \uc0ac\uc6a9\ub418\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"data"),"\ub97c \uc0ac\uc6a9\ud558\uc5ec \ub2e4\uc74c\uacfc \uac19\uc740 \uba87 \uac00\uc9c0 \uc608\ub97c \uc0b4\ud3b4\ubcf4\uaca0\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Bool"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Bool\n  = True\n  | False\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"True"),"\uc640 ",(0,r.kt)("inlineCode",{parentName:"p"},"False"),"\ub9cc \uac00\uc9c8 \uc218 \uc788\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"Bool"),"\uc774\ub77c\ub294 \uc0c8\ub85c\uc6b4 \ud0c0\uc785\uc744 \ub9cc\ub4e4\uc5c8\uc2b5\ub2c8\ub2e4."),(0,r.kt)("p",{parentName:"li"},"\uc774 \uacbd\uc6b0 ",(0,r.kt)("em",{parentName:"p"},"\uc0dd\uc131\uc790")," \ubaa9\ub85d\ub9cc \uac00\uc9c0\uace0 \uc788\uc744\ubfd0 \ucd94\uac00\uc801\uc778 \uac12\uc740 \uc5c6\uc2b5\ub2c8\ub2e4.\n\uc774\ub294 \ub2e4\ub978 \uc5b8\uc5b4\uc758 \uc5f4\uac70\ud615(enum)\uacfc \uc720\uc0ac\ud569\ub2c8\ub2e4.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Person"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Person\n  = Person String Int -- \uccab \ubc88\uc9f8 \uc778\uc790\ub294 \uc774\ub984, \ub450 \ubc88\uc9f8 \uc778\uc790\ub294 \ub098\uc774\n")),(0,r.kt)("p",{parentName:"li"},"\uc774\ubc88\uc5d0\ub294 ",(0,r.kt)("inlineCode",{parentName:"p"},"Person"),"\uc774\ub77c\ub294 \uc0c8\ub85c\uc6b4 \ud0c0\uc785\uc744 \ub9cc\ub4e4\uc5c8\uc2b5\ub2c8\ub2e4.\n\uc774 \ud0c0\uc785\uc758 \uac12\uc740 \ub2e4\uc74c\uacfc \uac19\uc774 \uc0dd\uacbc\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"Person <\ubb38\uc790\uc5f4> <\uc815\uc218>\n")),(0,r.kt)("p",{parentName:"li"},"\uc608\ub97c \ub4e4\uba74:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'Person "Gil" 32\n')),(0,r.kt)("p",{parentName:"li"},"\uc774 \uacbd\uc6b0\uc5d0\ub294 \ub2e4\ub978 \uc0dd\uc131\uc790\ub294 \uc5c6\uace0 \uc5ec\ub7ec \ud0c0\uc785\uc744 ",(0,r.kt)("em",{parentName:"p"},"\ud568\uc131"),"\ud558\ub294 \uc0dd\uc131\uc790\ub9cc \uc788\uc2b5\ub2c8\ub2e4.\n\uc774\ub294 \ub2e4\ub978 \uc5b8\uc5b4\uc5d0\uc11c \uad6c\uc870\uccb4(struct)\uc640 \uc720\uc0ac\ud558\uc9c0\ub9cc, \uac01 \ud544\ub4dc\ub97c \uc774\ub984\uc73c\ub85c \uad6c\ubcc4\ud558\ub294 \ub300\uc2e0 \uc704\uce58\ub85c \uad6c\ubd84\ud569\ub2c8\ub2e4."),(0,r.kt)("p",{parentName:"li"},"\uadf8 \ub300\uc2e0, \ud558\uc2a4\ucf08\uc740 ",(0,r.kt)("strong",{parentName:"p"},"records"),"\ub77c\uace0 \ubd88\ub9ac\ub294 \ud544\ub4dc \uc774\ub984\uc744 \uc9c0\uc815\ud558\ub294 ",(0,r.kt)("strong",{parentName:"p"},"\ubb38\ubc95\uc801 \uc124\ud0d5"),"\ub97c \uc81c\uacf5\ud569\ub2c8\ub2e4.\n\uc704 \uc815\uc758\ub294 \ub2e4\uc74c\uacfc \uac19\uc774 \uc791\uc131\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Person\n  = Person\n    { name :: String\n    , age :: Int\n    }\n")),(0,r.kt)("p",{parentName:"li"},"\uc704 \ud0c0\uc785\uc758 \uac12\uc740 \uc774\uc804\uacfc \ub3d9\uc77c\ud558\uac8c \uc791\uc131\ud560 \uc218 \uc788\uac70\ub098,"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'Person "Gil" 32\n')),(0,r.kt)("p",{parentName:"li"},"\ub2e4\uc74c\uacfc \uac19\uc774 \uc791\uc131\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'Person { name = "Gil", age = 32 }\n')),(0,r.kt)("p",{parentName:"li"},"\ud558\uc2a4\ucf08\uc740 \ubcf5\ud569 \ud0c0\uc785\uc5d0\uc11c \ud544\ub4dc\ub97c \ucd94\ucd9c\ud558\uae30 \uc704\ud55c \uc6a9\ub3c4\uc758 \ud568\uc218\ub610\ud55c \uc0dd\uc131\ud569\ub2c8\ub2e4:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"name :: Person -> String\nage :: Person -> Int\n")),(0,r.kt)("p",{parentName:"li"},"\ub2e4\uc74c\uacfc \uac19\uc774 \uc0ac\uc6a9\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> age (Person { name = "Gil", age = 32 })\n32\n')),(0,r.kt)("p",{parentName:"li"},"We even have special syntax for updating specific fields in a record. Of course,\nwe do not update records in place - we generate a new value instead."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> gil = Person { name = "Gil", age = 32 }\nghci> age (gil { age = 33 })\n33\nghci> age gil\n32\n')),(0,r.kt)("p",{parentName:"li"},"Unfortunately, having specialized functions for each field also means that if we\ndefined a different data type with the field ",(0,r.kt)("inlineCode",{parentName:"p"},"age"),", the functions which GHC needs\nto generate will clash."),(0,r.kt)("p",{parentName:"li"},"The easiest way to solve this is to give fields unique names, for example\nby adding a prefix:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Person\n  = Person\n    { pName :: String\n    , pAge :: Int\n    }\n")),(0,r.kt)("p",{parentName:"li"},"Another way is by using extensions to the Haskell language, which we will cover\nin later chapters.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Tuple"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Tuple a b\n  = Tuple a b\n")),(0,r.kt)("p",{parentName:"li"},"This is pretty similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"Person"),", but we can plug any type we want\nfor this definition. For example:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"Tuple \"Clicked\" True :: Tuple String Bool\n\nTuple 'a' 'z' :: Tuple Char Char\n")),(0,r.kt)("p",{parentName:"li"},"This type has special syntax in Haskell:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"(\"Clicked\", True) :: (String, Bool)\n\n('a', 'z') :: (Char, Char)\n")),(0,r.kt)("p",{parentName:"li"},"This ",(0,r.kt)("inlineCode",{parentName:"p"},"Tuple")," definition is polymorphic, we define the structure but are able to\nplug different types into the structure to get concrete types. You can think of ",(0,r.kt)("inlineCode",{parentName:"p"},"Tuple"),"\nas a ",(0,r.kt)("em",{parentName:"p"},"template")," for a data type waiting to be filled, or as a ",(0,r.kt)("strong",{parentName:"p"},"function"),' waiting\nfor types as input in order to return a data type. We can even take a look at the "type"\nsignature of ',(0,r.kt)("inlineCode",{parentName:"p"},"Tuple")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"ghci")," using the ",(0,r.kt)("inlineCode",{parentName:"p"},":kind")," command."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> data Tuple a b = Tuple a b\nghci> :kind Tuple\nTuple :: * -> * -> *\n")),(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("h4",{parentName:"blockquote",id:"quick-detour-kinds"},"Quick detour: Kinds"),(0,r.kt)("p",{parentName:"blockquote"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},":kind"),' command is called as such because the "type" of a type is called a ',(0,r.kt)("strong",{parentName:"p"},"kind"),".\nKinds can be one of two things, either a ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," which means a saturated (or concrete) type,\nsuch as ",(0,r.kt)("inlineCode",{parentName:"p"},"Int")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Person"),", or an ",(0,r.kt)("inlineCode",{parentName:"p"},"->")," of two kinds, which is, as you might have guessed,\na type function, taking kind and returning a kind."),(0,r.kt)("p",{parentName:"blockquote"},"Note that only types that have the kind ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," can have values. So for example while ",(0,r.kt)("inlineCode",{parentName:"p"},"Tuple Int"),"\nis a valid Haskell concept that has the ",(0,r.kt)("em",{parentName:"p"},"kind")," ",(0,r.kt)("inlineCode",{parentName:"p"},"* -> *"),', and we can write code that will\nwork "generically" for all types that have a certain kind (e.g. ',(0,r.kt)("inlineCode",{parentName:"p"},"* -> *"),"), we cannot\nconstruct a value that will have the kind ",(0,r.kt)("inlineCode",{parentName:"p"},"* -> *"),". All values have types, and all\ntypes that have values have the kind ",(0,r.kt)("inlineCode",{parentName:"p"},"*"),"."),(0,r.kt)("p",{parentName:"blockquote"},"We will talk more about kinds later, for now let's focus on types!"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Either"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Either a b\n  = Left a\n  | Right b\n")),(0,r.kt)("p",{parentName:"li"},"Similar to Tuple but instead of having only one constructor, we have\ntwo. This means that we can choose which side we want. Here are a\ncouple of values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Either String Int"),":"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'Left "Hello"\n\nRight 17\n')),(0,r.kt)("p",{parentName:"li"},"This type is useful for modeling errors. Either we succeeded and got\nwhat we wanted (The ",(0,r.kt)("inlineCode",{parentName:"p"},"Right")," constructor with the value), or we didn't\nand got an error instead (The ",(0,r.kt)("inlineCode",{parentName:"p"},"Left")," constructor with a string or a\ncustom error type)."))),(0,r.kt)("p",null,"In our program we use ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," types to model the different kinds of content types\nin our markup language. We tag each structure using the data constructor\nand provide the rest of the information (the paragraph text, the list items, etc.)\nin the ",(0,r.kt)("inlineCode",{parentName:"p"},"<types>")," section of the data declaration for each constructor:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"type Document\n  = [Structure]\n\ndata Structure\n  = Heading Natural String\n  | Paragraph String\n  | UnorderedList [String]\n  | OrderedList [String]\n  | CodeBlock [String]\n")),(0,r.kt)("p",null,"Note: ",(0,r.kt)("inlineCode",{parentName:"p"},"Natural")," is defined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"base")," package but not exported from ",(0,r.kt)("inlineCode",{parentName:"p"},"Prelude"),".\nFind out which module to import ",(0,r.kt)("inlineCode",{parentName:"p"},"Natural")," by using ",(0,r.kt)("a",{parentName:"p",href:"https://hoogle.haskell.org"},"Hoogle"),"."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"exercises"},"Exercises"),(0,r.kt)("p",null,"Represent the following markup documents as values of ",(0,r.kt)("inlineCode",{parentName:"p"},"Document"),":"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-org"},"Hello, world!\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-org"},"* Welcome\n\nTo this tutorial about Haskell.\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-org"},"Remember that multiple lines with no separation\nare grouped together to a single paragraph\nbut list items remain separate.\n\n# Item 1 of a list\n# Item 2 of the same list\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-org"},'* Compiling programs with ghc\n\nRunning ghc invokes the Glasgow Haskell Compiler (GHC),\nand can be used to compile Haskell modules and programs into native\nexecutables and libraries.\n\nCreate a new Haskell source file named hello.hs, and write\nthe following code in it:\n\n> main = putStrLn "Hello, Haskell!"\n\nNow, we can compile the program by invoking ghc with the file name:\n\n> \u279c ghc hello.hs\n> [1 of 1] Compiling Main             ( hello.hs, hello.o )\n> Linking hello ...\n\nGHC created the following files:\n\n- hello.hi - Haskell interface file\n- hello.o - Object file, the output of the compiler before linking\n- hello (or hello.exe on Microsoft Windows) - A native runnable executable.\n\nGHC will produce an executable when the source file satisfies both conditions:\n\n# Defines the main function in the source file\n# Defines the module name to be Main, or does not have a module declaration\n\nOtherwise, it will only produce the .o and .hi files.\n')))),(0,r.kt)("p",null,"Solutions:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution 1"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'example1 :: Document\nexample1 =\n  [ Paragraph "Hello, world!"\n  ]\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution 2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'example2 :: Document\nexample2 =\n  [ Heading 1 "Welcome"\n  , Paragraph "To this tutorial about Haskell."\n  ]\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution 3"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'example3 :: Document\nexample3 =\n  [ Paragraph "Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate."\n  , OrderedList\n    [ "Item 1 of a list"\n    , "Item 2 of the same list"\n    ]\n  ]\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution 4"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'example4 :: Document\nexample4 =\n  [ Heading 1 "Compiling programs with ghc"\n  , Paragraph "Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries."\n  , Paragraph "Create a new Haskell source file named hello.hs, and write the following code in it:"\n  , CodeBlock\n    [ "main = putStrLn \\"Hello, Haskell!\\""\n    ]\n  , Paragraph "Now, we can compile the program by invoking ghc with the file name:"\n  , CodeBlock\n    [ "\u279c ghc hello.hs"\n    , "[1 of 1] Compiling Main             ( hello.hs, hello.o )"\n    , "Linking hello ..."\n    ]\n  , Paragraph "GHC created the following files:"\n  , UnorderedList\n    [ "hello.hi - Haskell interface file"\n    , "hello.o - Object file, the output of the compiler before linking"\n    , "hello (or hello.exe on Microsoft Windows) - A native runnable executable."\n    ]\n  , Paragraph "GHC will produce an executable when the source file satisfies both conditions:"\n  , OrderedList\n    [ "Defines the main function in the source file"\n    , "Defines the module name to be Main, or does not have a module declaration"\n    ]\n  , Paragraph "Otherwise, it will only produce the .o and .hi files."\n  ]\n'))),(0,r.kt)("p",null,"Add a new module named ",(0,r.kt)("inlineCode",{parentName:"p"},"Markup")," and add the data type definition to it.\nNote that in this case we ",(0,r.kt)("em",{parentName:"p"},"do")," want to export the constructors of ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- Markup.hs\n\nmodule Markup\n  ( Document\n  , Structure(..)\n  )\nwhere\n\nimport Numeric.Natural\n\ntype Document\n  = [Structure]\n\ndata Structure\n  = Heading Natural String\n  | Paragraph String\n  | UnorderedList [String]\n  | OrderedList [String]\n  | CodeBlock [String]\n"))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"translating-directly"},"Translating directly?"),(0,r.kt)("p",null,"You might ask \"Why do we even need to represent the markup as a type?\nWhy don't we convert it into HTML as soon as we parse it\ninstead?\". That's a good question and a valid strategy. The reason we\nfirst represent it as a Haskell type is for flexibility and modularity."),(0,r.kt)("p",null,"If the parsing code is coupled with HTML generation, we lose the\nability to pre-process the markup document. For example we might want\nto take only a small part of the document (for summary) and present\nit, or create a table of content from headings. Or maybe we'd like to\nadd other targets and not just HTML - maybe markdown format or a GUI reader?"),(0,r.kt)("p",null,"Parsing to an \"abstract data type\" (ADT) representation (one that does\nnot contain the details of the language, for example '#' for\nordered lists) gives us the freedom to do so much more than just\nconversion to HTML that it's usually worth it in my opinion unless you\nreally need to optimize the process."))}d.isMDXComponent=!0}}]);