"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[749],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=s(n),h=r,d=u["".concat(p,".").concat(h)]||u[h]||m[h]||l;return n?a.createElement(d,i(i({ref:t},c),{},{components:n})):a.createElement(d,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=h;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[u]="string"==typeof e?e:r,i[1]=o;for(var s=2;s<l;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5575:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const l={},i="Escaping characters",o={unversionedId:"html/escaping-characters",id:"html/escaping-characters",title:"Escaping characters",description:"Now that Html has its own source file and module, and creating",source:"@site/docs/03-html/06-escaping-characters.md",sourceDirName:"03-html",slug:"/html/escaping-characters",permalink:"/learn-haskell-blog-generator/html/escaping-characters",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/03-html/06-escaping-characters.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ubaa8\ub4c8\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc798\ubabb\ub41c \uc0ac\uc6a9 \ubc29\uc9c0\ud558\uae30",permalink:"/learn-haskell-blog-generator/html/modules"},next:{title:"Exposing internal functionality (Internal modules)",permalink:"/learn-haskell-blog-generator/html/internal-modules"}},p={},s=[{value:"Linked lists briefly",id:"linked-lists-briefly",level:2},{value:"<code>map</code>",id:"map",level:3},{value:"<code>concat</code>",id:"concat",level:3},{value:"GHCi",id:"ghci",level:2},{value:"Escaping",id:"escaping",level:2}],c={toc:s},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"escaping-characters"},"Escaping characters"),(0,r.kt)("p",null,"Now that ",(0,r.kt)("inlineCode",{parentName:"p"},"Html")," has its own source file and module, and creating\nHTML code can be done only via the functions we exported,\nwe can also handle user input that may contain characters\nthat may conflict with our meta language, HTML,\nsuch as ",(0,r.kt)("inlineCode",{parentName:"p"},"<")," and ",(0,r.kt)("inlineCode",{parentName:"p"},">")," which are used for creating HTML tags."),(0,r.kt)("p",null,"We can convert these characters into different strings that HTML can handle."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-in-html"},"Stack overflow question"),"\nfor a list of characters we need to escape."),(0,r.kt)("p",null,"Let's create a new function called ",(0,r.kt)("inlineCode",{parentName:"p"},"escape"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"escape :: String -> String\nescape =\n  let\n    escapeChar c =\n      case c of\n        '<' -> \"&lt;\"\n        '>' -> \"&gt;\"\n        '&' -> \"&amp;\"\n        '\"' -> \"&quot;\"\n        '\\'' -> \"&#39;\"\n        _ -> [c]\n  in\n    concat . map escapeChar\n")),(0,r.kt)("p",null,"In ",(0,r.kt)("inlineCode",{parentName:"p"},"escape")," we see a few new things:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Let expressions: we can define local names using this syntax:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"let\n  <name> = <expression>\nin\n  <expression>\n")),(0,r.kt)("p",{parentName:"li"},"This will make ",(0,r.kt)("inlineCode",{parentName:"p"},"<name>")," available as a variable ",(0,r.kt)("inlineCode",{parentName:"p"},"in")," the second ",(0,r.kt)("inlineCode",{parentName:"p"},"<expression>"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Pattern matching with multiple patterns: we match on different\ncharacters and convert them to a string. Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"_"),' is a "catch\nall" pattern that will always succeed.')),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Two new functions: ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"concat"),", we'll talk about these more in depth")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"That the syntax highlighting broke a bit for this snippet for some reason. Don't worry about it."))),(0,r.kt)("h2",{id:"linked-lists-briefly"},"Linked lists briefly"),(0,r.kt)("p",null,"Linked lists are very common data structures in Haskell, so common that\nthey have their own special syntax:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The list types are denoted with brackets and inside them is the type of the element. For example:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[Int]")," - a list of integers"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[Char]")," - a list of characters"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[String]")," - a list of strings"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[[String]]")," - a list of a list of strings"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[a]")," - a list of any single type (all elements must be of the same type)"))),(0,r.kt)("li",{parentName:"ol"},"An empty list is written like this: ",(0,r.kt)("inlineCode",{parentName:"li"},"[]")),(0,r.kt)("li",{parentName:"ol"},"Prepending an element to a list is done with the operator ",(0,r.kt)("inlineCode",{parentName:"li"},":")," (pronounced cons) which is right-associative (like ",(0,r.kt)("inlineCode",{parentName:"li"},"->"),").\nFor example: ",(0,r.kt)("inlineCode",{parentName:"li"},"1 : []"),", or ",(0,r.kt)("inlineCode",{parentName:"li"},"1 : 2 : 3 : []"),"."),(0,r.kt)("li",{parentName:"ol"},"The above lists can also be written like this: ",(0,r.kt)("inlineCode",{parentName:"li"},"[1]")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"[1, 2, 3]"),".")),(0,r.kt)("p",null,"Also, Strings are linked lists of characters - String is defined as:\n",(0,r.kt)("inlineCode",{parentName:"p"},"type String = [Char]"),", so we can use them the same way we use lists."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Do note, however, that linked lists, despite their convenience, are often\nnot the right tool for the job. They are not particularly space efficient\nand are slow for appending, random access and more. That also makes ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"\na lot less efficient than what it could be. And I generally recommend using a\ndifferent string type, ",(0,r.kt)("inlineCode",{parentName:"p"},"Text"),", instead, which is available in an external package.\nWe will talk about lists, ",(0,r.kt)("inlineCode",{parentName:"p"},"Text"),", and other data structures in the future!")),(0,r.kt)("p",null,"We can implement our own operations on lists by using pattern matching and recursion.\nAnd we'll touch on this subject later when talking about ADTs."),(0,r.kt)("p",null,"For now, we will use the various functions found in the\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-List.html"},"Data.List")," module.\nSpecifically, ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-List.html#v:map"},"map"),"\nand ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-List.html#v:concat"},"concat"),"."),(0,r.kt)("h3",{id:"map"},(0,r.kt)("inlineCode",{parentName:"h3"},"map")),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," we can apply a function to each of the elements in a list. Its type signature is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"map :: (a -> b) -> [a] -> [b]\n")),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"map not [False, True, False] == [True, False, True]\n")),(0,r.kt)("p",null,"Or as can be seen in our ",(0,r.kt)("inlineCode",{parentName:"p"},"escape")," function, this can help us escape each character:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"map escapeChar ['<','h','1','>'] == [\"&lt;\",\"h\",\"1\",\"&gt;\"]\n")),(0,r.kt)("p",null,"However, note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"escapeChar")," has the type ",(0,r.kt)("inlineCode",{parentName:"p"},"Char -> String"),",\nso the result type of ",(0,r.kt)("inlineCode",{parentName:"p"},"map escapeChar ['<','h','1','>']")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"[String]"),",\nand what we really want is a ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," and not ",(0,r.kt)("inlineCode",{parentName:"p"},"[String]"),"."),(0,r.kt)("p",null,"This is where ",(0,r.kt)("inlineCode",{parentName:"p"},"concat")," enters the picture to help us flatten the list."),(0,r.kt)("h3",{id:"concat"},(0,r.kt)("inlineCode",{parentName:"h3"},"concat")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"concat")," has the type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"concat :: [[a]] -> [a]\n")),(0,r.kt)("p",null,"It flattens a list of list of something into a list of something.\nIn our case it will flatten ",(0,r.kt)("inlineCode",{parentName:"p"},"[String]")," into ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),", remember that\n",(0,r.kt)("inlineCode",{parentName:"p"},"String")," is a ",(0,r.kt)("strong",{parentName:"p"},"type alias")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"[Char]"),", so we actually have\n",(0,r.kt)("inlineCode",{parentName:"p"},"[[Char]] -> [Char]"),"."),(0,r.kt)("h2",{id:"ghci"},"GHCi"),(0,r.kt)("p",null,"One way we can quickly see our code in action is using the interactive development environment ",(0,r.kt)("strong",{parentName:"p"},"GHCi"),".\nRunning ",(0,r.kt)("inlineCode",{parentName:"p"},"ghci"),' will open an interactive prompt where Haskell expressions can be written and\nevaluated. This is called a "Read-Evaluate-Print Loop" (for short - REPL).'),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'ghci> 1 + 1\n2\nghci> putStrLn "Hello, world!"\nHello, world!\n')),(0,r.kt)("p",null,"We can define new names:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ghci> double x = x + x\nghci> double 2\n4\n")),(0,r.kt)("p",null,"We can write multi-line code by surrounding it with ",(0,r.kt)("inlineCode",{parentName:"p"},":{")," and ",(0,r.kt)("inlineCode",{parentName:"p"},":}"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'ghci> :{\n| escape :: String -> String\n| escape =\n|   let\n|     escapeChar c =\n|       case c of\n|         \'<\' -> "&lt;"\n|         \'>\' -> "&gt;"\n|         \'&\' -> "&amp;"\n|         \'"\' -> "&quot;"\n|         \'\\\'\' -> "&#39;"\n|         _ -> [c]\n|   in\n|     concat . map escapeChar\n| :}\n\nghci> escape "<html>"\n"&lt;html&gt;"\n\n')),(0,r.kt)("p",null,"We can import Haskell source files using the ",(0,r.kt)("inlineCode",{parentName:"p"},":load")," command (",(0,r.kt)("inlineCode",{parentName:"p"},":l")," for short):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'ghci> :load Html.hs\n[1 of 1] Compiling Html    ( Html.hs, interpreted )\nOk, one module loaded.\nghci> render (html_ "<title>" (p_ "<body>"))\n"<html><head><title>&lt;title&gt;</title></head><body><p>&lt;body&gt;</p></body></html>"\n')),(0,r.kt)("p",null,"As well as import library modules:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ghci> import Data.Bits\nghci> shiftL 32 1\n64\nghci> clearBit 33 0\n32\n")),(0,r.kt)("p",null,"We can even ask the type of an expression using the ",(0,r.kt)("inlineCode",{parentName:"p"},":type")," command\n(",(0,r.kt)("inlineCode",{parentName:"p"},":t")," for short):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\u03bb> :type escape\nescape :: String -> String\n")),(0,r.kt)("p",null,"To exit ",(0,r.kt)("inlineCode",{parentName:"p"},"ghci"),", use the ",(0,r.kt)("inlineCode",{parentName:"p"},":quit")," command (or ",(0,r.kt)("inlineCode",{parentName:"p"},":q")," for short)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ghci> :quit\nLeaving GHCi.\n")),(0,r.kt)("p",null,"GHCi is a very useful tool for quick experiments and exploration.\nWe've seen a couple of examples of that above - passing the string ",(0,r.kt)("inlineCode",{parentName:"p"},'"<html>"')," to our\n",(0,r.kt)("inlineCode",{parentName:"p"},"escape")," function returns the string ",(0,r.kt)("inlineCode",{parentName:"p"},'"&lt;html&gt;"'),", which can be rendered by\na browser as ",(0,r.kt)("inlineCode",{parentName:"p"},"<html>")," instead of an HTML tag."),(0,r.kt)("p",null,"If you are having a hard time figuring out what a particular function does, consider\ntesting it in GHCi - pass it different inputs, and see if it matches your expectations.\nConcrete examples of running code can aid a lot in understanding it!"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"If you'd like to learn more about GHCi, you can find a more thorough introduction in the\n",(0,r.kt)("a",{parentName:"p",href:"https://downloads.haskell.org/ghc/latest/docs/users_guide/ghci.html"},"GHC user guide"),".")),(0,r.kt)("h2",{id:"escaping"},"Escaping"),(0,r.kt)("hr",null),(0,r.kt)("p",null,"The user of our library can currently only supply strings in a few places:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Page title"),(0,r.kt)("li",{parentName:"ol"},"Paragraphs"),(0,r.kt)("li",{parentName:"ol"},"Headings")),(0,r.kt)("p",null,"We can apply our escape function at these places before doing anything else with it.\nThat way all HTML constructions are safe."),(0,r.kt)("p",null,"Try adding the escaping function in those places."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'html_ :: Title -> Structure -> Html\nhtml_ title content =\n  Html\n    ( el "html"\n      ( el "head" (el "title" (escape title))\n        <> el "body" (getStructureString content)\n      )\n    )\n\np_ :: String -> Structure\np_ = Structure . el "p" . escape\n\nh1_ :: String -> Structure\nh1_ = Structure . el "h1" . escape\n'))),(0,r.kt)("hr",null),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"Our revised Html.hs")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'-- Html.hs\n\nmodule Html\n  ( Html\n  , Title\n  , Structure\n  , html_\n  , p_\n  , h1_\n  , append_\n  , render\n  )\n  where\n\n-- * Types\n\nnewtype Html\n  = Html String\n\nnewtype Structure\n  = Structure String\n\ntype Title\n  = String\n\n-- * EDSL\n\nhtml_ :: Title -> Structure -> Html\nhtml_ title content =\n  Html\n    ( el "html"\n      ( el "head" (el "title" (escape title))\n        <> el "body" (getStructureString content)\n      )\n    )\n\np_ :: String -> Structure\np_ = Structure . el "p" . escape\n\nh1_ :: String -> Structure\nh1_ = Structure . el "h1" . escape\n\nappend_ :: Structure -> Structure -> Structure\nappend_ c1 c2 =\n  Structure (getStructureString c1 <> getStructureString c2)\n\n-- * Render\n\nrender :: Html -> String\nrender html =\n  case html of\n    Html str -> str\n\n-- * Utilities\n\nel :: String -> String -> String\nel tag content =\n  "<" <> tag <> ">" <> content <> "</" <> tag <> ">"\n\ngetStructureString :: Structure -> String\ngetStructureString content =\n  case content of\n    Structure str -> str\n\nescape :: String -> String\nescape =\n  let\n    escapeChar c =\n      case c of\n        \'<\' -> "&lt;"\n        \'>\' -> "&gt;"\n        \'&\' -> "&amp;"\n        \'"\' -> "&quot;"\n        \'\\\'\' -> "&#39;"\n        _ -> [c]\n  in\n    concat . map escapeChar\n'))),(0,r.kt)("p",null,"Try constructing an invalid HTML in ",(0,r.kt)("inlineCode",{parentName:"p"},"hello.hs")," to see if this works or not!"),(0,r.kt)("p",null,"Now we can use our tiny HTML library safely. But what if the user\nwants to use our library with a valid use case we didn't think about, for\nexample adding unordered lists? We are completely blocking them from\nextending our library. We'll talk about this next."))}m.isMDXComponent=!0}}]);