"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[27],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>m});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,o=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=p(n),c=l,m=u["".concat(o,".").concat(c)]||u[c]||d[c]||i;return n?a.createElement(m,r(r({ref:t},h),{},{components:n})):a.createElement(m,r({ref:t},h))}));function m(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,r=new Array(i);r[0]=c;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[u]="string"==typeof e?e:l,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5662:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),l=(n(7294),n(3905));const i={},r="Testing",s={unversionedId:"testing",id:"testing",title:"Testing",description:"We want to add some tests to our blog generator. At the very least",source:"@site/docs/08-testing.md",sourceDirName:".",slug:"/testing",permalink:"/learn-haskell-blog-generator/testing",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/08-testing.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ud658\uacbd \ubcc0\uc218 \uc804\ub2ec\ud558\uae30",permalink:"/learn-haskell-blog-generator/environment"},next:{title:"Generating documentation",permalink:"/learn-haskell-blog-generator/documentation"}},o={},p=[{value:"Initial setup",id:"initial-setup",level:2},{value:"Cabal file additions",id:"cabal-file-additions",level:3},{value:"Hspec discovery",id:"hspec-discovery",level:3},{value:"Writing tests",id:"writing-tests",level:2},{value:"Raw strings",id:"raw-strings",level:3},{value:"Parallel test execution",id:"parallel-test-execution",level:2},{value:"Summary",id:"summary",level:2}],h={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,l.kt)(u,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"testing"},"Testing"),(0,l.kt)("p",null,"We want to add some tests to our blog generator. At the very least\na few regression tests to make sure that if we extend or change our markup parsing code,\nHTML generation code, or translation from markup to HTML code, and make a mistake, we'll\nhave a safety net alerting us of issues."),(0,l.kt)("p",null,"We will use the ",(0,l.kt)("a",{parentName:"p",href:"https://hspec.github.io/"},"Hspec")," testing framework to write our tests.\nThere are other testing frameworks in Haskell, for example\n",(0,l.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/tasty"},"tasty"),", but I like Hspec's documentation,\nso we'll use that."),(0,l.kt)("h2",{id:"initial-setup"},"Initial setup"),(0,l.kt)("h3",{id:"cabal-file-additions"},"Cabal file additions"),(0,l.kt)("p",null,"We're going to define a new section in our ",(0,l.kt)("inlineCode",{parentName:"p"},"hs-blog-gen.cabal")," file for our new test suite.\nThis section is called ",(0,l.kt)("inlineCode",{parentName:"p"},"test-suite")," and it is fairly similar to the ",(0,l.kt)("inlineCode",{parentName:"p"},"library")," and\n",(0,l.kt)("inlineCode",{parentName:"p"},"executable")," sections."),(0,l.kt)("p",null,"The interfaces for how to define a test suite are described in the\n",(0,l.kt)("a",{parentName:"p",href:"https://cabal.readthedocs.io/en/stable/cabal-package.html#test-suites"},"Cabal documentation"),".\nWe are going to use the ",(0,l.kt)("inlineCode",{parentName:"p"},"exitcode-stdio-1.0")," interface. Let's go over the different settings\nand options:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cabal"},"test-suite hs-blog-gen-test\n  import: common-settings\n  type: exitcode-stdio-1.0\n  hs-source-dirs: test\n  main-is: Spec.hs\n\n  -- other-modules:\n  build-depends:\n      base\n    , hspec\n    , hspec-discover\n    , raw-strings-qq\n    , hs-blog\n  ghc-options:\n    -O -threaded -rtsopts -with-rtsopts=-N\n  build-tool-depends:\n    hspec-discover:hspec-discover\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"hs-source-dirs: test")," - The directory of the source files for the test suite"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"main-is: Spec.hs")," - The entry point to the test suite"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"other-modules")," - The modules in our test suite.\nCurrently commented out because we haven't added any yet"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"build-depends")," - The packages we are going to use:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/base"},(0,l.kt)("inlineCode",{parentName:"a"},"base"))," -\nThe standard library for Haskell, as we've used before"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/hspec"},(0,l.kt)("inlineCode",{parentName:"a"},"hspec"))," -\nThe test framework we are going to use"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/hspec-discover"},(0,l.kt)("inlineCode",{parentName:"a"},"hspec-discover"))," -\nAutomatic discovery of Hspec tests"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/raw-strings-qq"},(0,l.kt)("inlineCode",{parentName:"a"},"raw-strings-qq"))," -\nAdditional syntax for writing raw string literals"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"hs-blog")," - Our library"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://cabal.readthedocs.io/en/stable/cabal-package.html#pkg-field-ghc-options"},(0,l.kt)("inlineCode",{parentName:"a"},"ghc-options"))," -\nExtra options and flags for GHC:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://downloads.haskell.org/ghc/latest/docs/html/users_guide/using-optimisation.html#options-optimise"},(0,l.kt)("inlineCode",{parentName:"a"},"-O"))," -\nCompile with optimizations"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--threaded"},(0,l.kt)("inlineCode",{parentName:"a"},"-threaded"))," -\nUse the multi-core runtime instead of single-core runtime. The multi-core\nruntime is generally a bit slower in my experience, but when writing code that actually uses\nmultiple cores (such as a test framework that runs tests in parallel) it can give a good\nperformance boost"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D"},(0,l.kt)("inlineCode",{parentName:"a"},"-rtsopts"))," -\nLet us configure the Haskell runtime system by passing command-line arguments to our application"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9"},(0,l.kt)("inlineCode",{parentName:"a"},"-with-rtsopts=-N"))," -\nSet specific default options for the program at link-time.\nSpecifically, ",(0,l.kt)("a",{parentName:"li",href:"https://downloads.haskell.org/ghc/latest/docs/html/users_guide/using-concurrent.html#rts-flag--N%20%E2%9F%A8x%E2%9F%A9"},(0,l.kt)("inlineCode",{parentName:"a"},"-N")),"\nSets the number of cores to use in our program"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://cabal.readthedocs.io/en/stable/cabal-package.html#pkg-field-build-tool-depends"},(0,l.kt)("inlineCode",{parentName:"a"},"build-tool-depends"))," -\nUse a specific executable from a package dependency in aid of building the package.\nIn this case, we are using the ",(0,l.kt)("inlineCode",{parentName:"li"},"hspec-discover")," executable from the\n",(0,l.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/hspec-discover"},(0,l.kt)("inlineCode",{parentName:"a"},"hspec-discover"))," package, which\ngoes over the source directory for the tests, finds all of the ",(0,l.kt)("inlineCode",{parentName:"li"},"Spec")," files,\nand creates an entry point for the program that will run all the tests it discovered")),(0,l.kt)("h3",{id:"hspec-discovery"},"Hspec discovery"),(0,l.kt)("p",null,"In order for ",(0,l.kt)("inlineCode",{parentName:"p"},"hspec-discover"),' to work, we need to add the following\nto the "main" file of the test suite, for us this is ',(0,l.kt)("inlineCode",{parentName:"p"},"test/Spec.hs"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"{-# OPTIONS_GHC -F -pgmF hspec-discover #-}\n")),(0,l.kt)("p",null,"That's it! ",(0,l.kt)("inlineCode",{parentName:"p"},"hspec-discover")," will automatically define a ",(0,l.kt)("inlineCode",{parentName:"p"},"main")," for us.\nNow we can run the tests using ",(0,l.kt)("inlineCode",{parentName:"p"},"stack test")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"cabal test")," (your choice).\nBecause we haven't defined any tests, our output is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sh"},"Finished in 0.0000 seconds\n0 examples, 0 failures\n")),(0,l.kt)("p",null,"When we add new Hspec tests, ",(0,l.kt)("inlineCode",{parentName:"p"},"hspec-discover")," will find and run them automatically\n(though we will still need add them to the ",(0,l.kt)("inlineCode",{parentName:"p"},"other-modules")," section in the cabal file)."),(0,l.kt)("p",null,"For ",(0,l.kt)("inlineCode",{parentName:"p"},"hspec-discover")," to identify modules as test modules, the modules must follow\na convention:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Their module names must end with ",(0,l.kt)("inlineCode",{parentName:"li"},"Spec")),(0,l.kt)("li",{parentName:"ol"},"They must define a value ",(0,l.kt)("inlineCode",{parentName:"li"},"spec :: Spec")," (which describes the test) and export it\noutside of the module (by adding it to the export list of the module, for example)")),(0,l.kt)("h2",{id:"writing-tests"},"Writing tests"),(0,l.kt)("p",null,"Let's write our first test. We'll create a new module to test\nmarkup parsing. We'll call it ",(0,l.kt)("inlineCode",{parentName:"p"},"MarkupParsingSpec.hs"),". We'll need\nthe following imports as well:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"module MarkupParsingSpec where\n\nimport Test.Hspec\nimport HsBlog.Markup\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Hspec")," provides us with a monadic interface for describing, composing and\nnesting test specifications (",(0,l.kt)("inlineCode",{parentName:"p"},"Spec"),"s)."),(0,l.kt)("p",null,"Using the ",(0,l.kt)("inlineCode",{parentName:"p"},"describe")," function we can\ndescribe a group of tests, using the ",(0,l.kt)("inlineCode",{parentName:"p"},"it")," function we can add a new test,\nand using a function like ",(0,l.kt)("inlineCode",{parentName:"p"},"shouldBe")," we can compare two values and make\nsure they are equal by using their ",(0,l.kt)("inlineCode",{parentName:"p"},"Eq")," instance.\nIf they are, the test will pass, and if not, it will fail with a descriptive error."),(0,l.kt)("p",null,"Let's try it and write a test that obviously fails!"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'spec :: Spec\nspec = do\n  describe "Markup parsing tests" $ do\n    it "empty" $\n      shouldBe\n        (parse "")\n        [Heading 1 "bug"]\n')),(0,l.kt)("p",null,"After adding the module to the ",(0,l.kt)("inlineCode",{parentName:"p"},"other-modules")," list in the cabal file:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"  other-modules:\n    MarkupParsingSpec\n")),(0,l.kt)("p",null,"And running the tests, we get this output:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'MarkupParsing\n  Markup parsing tests\n    empty FAILED [1]\n\nFailures:\n\n  test/MarkupParsingSpec.hs:10:7:\n  1) MarkupParsing, Markup parsing tests, empty\n       expected: [Heading 1 "bug"]\n        but got: []\n\n  To rerun use: --match "/MarkupParsing/Markup parsing tests/empty/"\n\nRandomized with seed 763489823\n\nFinished in 0.0004 seconds\n1 example, 1 failure\n')),(0,l.kt)("p",null,"The output describes which tests are running in a hierarchy tree (module, group and test),\nwhether the tests pass or fail, and if they fail, the output and the expected output."),(0,l.kt)("p",null,"We can fix our test by matching the expected output:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'      shouldBe\n        (parse "")\n        []\n')),(0,l.kt)("p",null,"Now, running the tests will produce:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"MarkupParsing\n  Markup parsing tests\n    empty\n\nFinished in 0.0001 seconds\n1 example, 0 failures\n")),(0,l.kt)("p",null,"We can add a few more tests:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'    it "paragraph" $\n      shouldBe\n        (parse "hello world")\n        [Paragraph "hello world"]\n\n    it "heading 1" $\n      shouldBe\n        (parse "* Heading 1")\n        [Heading 1 "Heading 1"]\n\n    it "code" $\n      shouldBe\n        (parse "> main = putStrLn \\"hello world!\\"")\n        [CodeBlock ["main = putStrLn \\"hello world!\\""]]\n')),(0,l.kt)("p",null,"And run the tests again:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sh"},"MarkupParsing\n  Markup parsing tests\n    Test empty\n    paragraph\n    heading 1\n    code\n\nFinished in 0.0003 seconds\n4 examples, 0 failures\n")),(0,l.kt)("p",null,"This is the gist of writing unit tests with Hspec. It's important to note\nthat we can nest ",(0,l.kt)("inlineCode",{parentName:"p"},"Spec"),"s that are declared with ",(0,l.kt)("inlineCode",{parentName:"p"},"describe")," to create trees,\nand of course refactor and move things to different functions and modules\nto make our test suite better organized."),(0,l.kt)("p",null,"For example, we can write our tests like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'spec :: Spec\nspec = do\n  describe "Markup parsing tests" $ do\n    simple\n\nsimple :: Spec\nsimple = do\n  describe "simple" $ do\n    it "empty" $\n      shouldBe\n        (parse "")\n        []\n\n    it "paragraph" $\n      shouldBe\n        (parse "hello world")\n        [Paragraph "hello world"]\n\n    it "heading 1" $\n      shouldBe\n        (parse "* Heading 1")\n        [Heading 1 "Heading 1"]\n\n    it "code" $\n      shouldBe\n        (parse "> main = putStrLn \\"hello world!\\"")\n        [CodeBlock ["main = putStrLn \\"hello world!\\""]]\n')),(0,l.kt)("p",null,'Also, there are other "expectations" like ',(0,l.kt)("inlineCode",{parentName:"p"},"shouldBe")," that we can use when writing tests.\nThey are described in the ",(0,l.kt)("a",{parentName:"p",href:"https://hspec.github.io/expectations.html"},"Hspec tutorial"),"\nand can be found in the\n",(0,l.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/hspec-expectations-0.8.2/docs/Test-Hspec-Expectations.html"},"haddock documentation")," as well."),(0,l.kt)("h3",{id:"raw-strings"},"Raw strings"),(0,l.kt)("p",null,'If we want to write multi-line strings, or avoid escaping strings like we did in the "code"\ntest, we can use a library called\n',(0,l.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/raw-strings-qq"},"raw-strings-qq"),"\nwhich uses a language extension called\n",(0,l.kt)("a",{parentName:"p",href:"https://downloads.haskell.org/ghc/latest/docs/html/users_guide/exts/template_haskell.html#extension-QuasiQuotes"},(0,l.kt)("inlineCode",{parentName:"a"},"QuasiQuotes")),".\n",(0,l.kt)("inlineCode",{parentName:"p"},"QuasiQuotes")," is a meta-programming extension that provides a mechanism for extending the\nsyntax of Haskell."),(0,l.kt)("p",null,"A quasi-quote has the form ",(0,l.kt)("inlineCode",{parentName:"p"},"[quoter| string |]"),", where the quoter is the name\nof the function providing the syntax we wish to use, and the string is our input."),(0,l.kt)("p",null,"In our case, we use the quoter ",(0,l.kt)("inlineCode",{parentName:"p"},"r"),", which is defined in\n",(0,l.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/raw-strings-qq-1.1/docs/Text-RawString-QQ.html"},"raw-strings-qq"),",\nand write any string we want, with multi-lines and unescaped characters!\nWe could use this to write the tests\n",(0,l.kt)("a",{parentName:"p",href:"/learn-haskell-blog-generator/markup/data-type#exercises"},"we previously wrote"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"{-# language QuasiQuotes #-}\n\n...\n\nimport Text.RawString.QQ\n\n...\n\nexample3 :: String\nexample3 = [r|\nRemember that multiple lines with no separation\nare grouped together to a single paragraph\nbut list items remain separate.\n\n# Item 1 of a list\n# Item 2 of the same list\n|]\n")),(0,l.kt)("p",null,"And add multi-line tests:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'spec :: Spec\nspec = do\n  describe "Markup parsing tests" $ do\n    simple\n    multiline\n\n\nmultiline :: Spec\nmultiline = do\n  describe "Multi-line tests" $ do\n    it "example3" $\n      shouldBe\n        (parse example3)\n        example3Result\n\n\nexample3 :: String\nexample3 = [r|\nRemember that multiple lines with no separation\nare grouped together to a single paragraph\nbut list items remain separate.\n\n# Item 1 of a list\n# Item 2 of the same list\n|]\n\nexample3Result :: Document\nexample3Result =\n  [ Paragraph "Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate."\n  , OrderedList\n    [ "Item 1 of a list"\n    , "Item 2 of the same list"\n    ]\n  ]\n')),(0,l.kt)("p",null,"Running the tests:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"MarkupParsing\n  Markup parsing tests\n    simple\n      Test empty\n      paragraph\n      heading 1\n      code\n    Multi-line tests\n      example3\n\nFinished in 0.0004 seconds\n5 examples, 0 failures\n")),(0,l.kt)("hr",null),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Exercise"),": Add a test for the fourth example described in the\n",(0,l.kt)("a",{parentName:"p",href:"/learn-haskell-blog-generator/markup/data-type#exercises"},"previous exercises"),"."),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Solution"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'multiline :: Spec\nmultiline = do\n  describe "Multi-line tests" $ do\n    it "example3" $\n      shouldBe\n        (parse example3)\n        example3Result\n\n    it "example4" $\n      shouldBe\n        (parse example4)\n        example4Result\n\n\nexample4 :: String\nexample4 = [r|\n* Compiling programs with ghc\n\nRunning ghc invokes the Glasgow Haskell Compiler (GHC),\nand can be used to compile Haskell modules and programs into native\nexecutables and libraries.\n\nCreate a new Haskell source file named hello.hs, and write\nthe following code in it:\n\n> main = putStrLn "Hello, Haskell!"\n\nNow, we can compile the program by invoking ghc with the file name:\n\n> \u279c ghc hello.hs\n> [1 of 1] Compiling Main             ( hello.hs, hello.o )\n> Linking hello ...\n\nGHC created the following files:\n\n- hello.hi - Haskell interface file\n- hello.o - Object file, the output of the compiler before linking\n- hello (or hello.exe on Microsoft Windows) - A native runnable executable.\n\nGHC will produce an executable when the source file satisfies both conditions:\n\n# Defines the main function in the source file\n# Defines the module name to be Main, or does not have a module declaration\n\nOtherwise, it will only produce the .o and .hi files.\n|]\n\nexample4Result :: Document\nexample4Result =\n  [ Heading 1 "Compiling programs with ghc"\n  , Paragraph "Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries."\n  , Paragraph "Create a new Haskell source file named hello.hs, and write the following code in it:"\n  , CodeBlock\n    [ "main = putStrLn \\"Hello, Haskell!\\""\n    ]\n  , Paragraph "Now, we can compile the program by invoking ghc with the file name:"\n  , CodeBlock\n    [ "\u279c ghc hello.hs"\n    , "[1 of 1] Compiling Main             ( hello.hs, hello.o )"\n    , "Linking hello ..."\n    ]\n  , Paragraph "GHC created the following files:"\n  , UnorderedList\n    [ "hello.hi - Haskell interface file"\n    , "hello.o - Object file, the output of the compiler before linking"\n    , "hello (or hello.exe on Microsoft Windows) - A native runnable executable."\n    ]\n  , Paragraph "GHC will produce an executable when the source file satisfies both conditions:"\n  , OrderedList\n    [ "Defines the main function in the source file"\n    , "Defines the module name to be Main, or does not have a module declaration"\n    ]\n  , Paragraph "Otherwise, it will only produce the .o and .hi files."\n  ]\n'))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"parallel-test-execution"},"Parallel test execution"),(0,l.kt)("p",null,"Without further configuration, Hspec will run all\nof our tests on the main thread, sequentially."),(0,l.kt)("p",null,"There are a couple of ways to configure tests to run\nin parallel. One is to manually mark a ",(0,l.kt)("inlineCode",{parentName:"p"},"Spec"),"\nas parallel by passing it to the ",(0,l.kt)("inlineCode",{parentName:"p"},"parallel")," function,\nand another is by creating a /hook/ that will apply\n",(0,l.kt)("inlineCode",{parentName:"p"},"parallel")," to each ",(0,l.kt)("inlineCode",{parentName:"p"},"Spec")," automatically with\n",(0,l.kt)("inlineCode",{parentName:"p"},"hspec-discover"),"."),(0,l.kt)("p",null,"Consult the ",(0,l.kt)("a",{parentName:"p",href:"https://hspec.github.io/parallel-spec-execution.html#running-all-tests-in-parallel-with-hspec-discover"},"Hspec manual"),"\non this topic and try both methods. Remember that\nwe already enabled the threaded runtime and set it to\nuse multiple cores in the cabal file."),(0,l.kt)("h2",{id:"summary"},"Summary"),(0,l.kt)("p",null,"This chapter has been just the tip of the iceberg of the Haskell testing landscape.\nWe haven't talked about\n",(0,l.kt)("a",{parentName:"p",href:"https://www.scs.stanford.edu/16wi-cs240h/slides/testing.html"},"property testing")," or\n",(0,l.kt)("a",{parentName:"p",href:"https://ro-che.info/articles/2017-12-04-golden-tests"},"golden testing"),",\ntesting expected failures, testing IO code, inspection testing, benchmarking, and more.\nThere's just too much to cover!"),(0,l.kt)("p",null,"My hope is that this chapter\nprovided you with the basics of how to start writing tests for your own projects.\nPlease consult the tutorial for your chosen testing framework, and read more about\nthis very important subject on your own."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"You can view the git commit of\n",(0,l.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/commit/da1615b6e0a2a4ff2728528240d790754853bf02"},"the changes we've made"),"\nand the ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/tree/da1615b6e0a2a4ff2728528240d790754853bf02"},"code up until now"),".")))}d.isMDXComponent=!0}}]);