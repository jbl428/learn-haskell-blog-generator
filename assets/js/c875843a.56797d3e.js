"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[385],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=p(t),d=r,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||l;return t?a.createElement(h,i(i({ref:n},u),{},{components:t})):a.createElement(h,i({ref:n},u))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[m]="string"==typeof e?e:r,i[1]=o;for(var p=2;p<l;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},1596:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const l={},i="Parsing markup part 01 (Recursion)",o={unversionedId:"markup/parsing-01",id:"markup/parsing-01",title:"Parsing markup part 01 (Recursion)",description:"Let's have a look at how to parse a multi-lined string of markup text",source:"@site/docs/04-markup/02-parsing-01.md",sourceDirName:"04-markup",slug:"/markup/parsing-01",permalink:"/learn-haskell-blog-generator/markup/parsing-01",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/04-markup/02-parsing-01.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ud558\uc2a4\ucf08 \ub370\uc774\ud130 \ud0c0\uc785\uc73c\ub85c \ub9c8\ud06c\uc5c5 \uc5b8\uc5b4 \ud45c\ud604\ud558\uae30",permalink:"/learn-haskell-blog-generator/markup/data-type"},next:{title:"Displaying the parsing results (type classes)",permalink:"/learn-haskell-blog-generator/markup/displaying-results"}},s={},p=[{value:"Recursion and accumulating information",id:"recursion-and-accumulating-information",level:2},{value:"Evaluation of recursion",id:"evaluation-of-recursion",level:3},{value:"Laziness",id:"laziness",level:4},{value:"General recursion",id:"general-recursion",level:3},{value:"Mutual recursion",id:"mutual-recursion",level:3},{value:"Partial functions",id:"partial-functions",level:2},{value:"Parsing markup?",id:"parsing-markup",level:2}],u={toc:p},m="wrapper";function c(e){let{components:n,...t}=e;return(0,r.kt)(m,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"parsing-markup-part-01-recursion"},"Parsing markup part 01 (Recursion)"),(0,r.kt)("p",null,"Let's have a look at how to parse a multi-lined string of markup text\nwritten by a user and convert it to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Document")," type we defined\nin the previous chapter."),(0,r.kt)("p",null,"Our strategy is to take the string of markup text, and:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Split it to a list where each element represents a separate line, and"),(0,r.kt)("li",{parentName:"ol"},"Go over the list line by line and process it, remembering\ninformation from previous lines if necessary")),(0,r.kt)("p",null,"So the first thing we want to do is to process the string line by line.\nWe can do that by converting the string to a list of string.\nFortunately the Haskell\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:lines"},(0,r.kt)("inlineCode",{parentName:"a"},"Prelude")),"\nmodule from the Haskell standard library\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base"},(0,r.kt)("inlineCode",{parentName:"a"},"base"))," exposes the function\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:lines"},(0,r.kt)("inlineCode",{parentName:"a"},"lines")),"\nthat does exactly what we want. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Prelude")," module is exposed in every\nHaskell file by default so we don't need to import it."),(0,r.kt)("p",null,"For the line processing part, let's start by ignoring all of the markup syntax\nand just group lines together into paragraphs (paragraphs are separated by an empty line),\nand iteratively add new features later in the chapter."),(0,r.kt)("p",null,"A common solution in imperative programs would be to iterate over the lines\nusing some ",(0,r.kt)("em",{parentName:"p"},"loop")," construct and accumulate lines that should be grouped together\ninto some intermediate mutable variable. When we reach an empty line, we insert\nthe content of that variable into another mutable variable that accumulates the\nresults."),(0,r.kt)("p",null,"Our approach in Haskell isn't so different, except that we do not use loops\nor mutable variables. Instead, we use ",(0,r.kt)("strong",{parentName:"p"},"recursion"),"."),(0,r.kt)("h2",{id:"recursion-and-accumulating-information"},"Recursion and accumulating information"),(0,r.kt)("p",null,"Instead of loops, in Haskell we use recursion to model iteration."),(0,r.kt)("p",null,"Consider the following contrived example: let's say that\nwe want to write an algorithm for adding two natural numbers together,\nand we don't have a standard operation to do that (+), but we do\nhave two operations we could use on each number: ",(0,r.kt)("inlineCode",{parentName:"p"},"increment"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"decrement"),"."),(0,r.kt)("p",null,'A solution we could come up with is to slowly "pass" one number\nto the other number iteratively, by incrementing one, and decrementing the other.\nAnd we do that until the number we decrement reaches 0.'),(0,r.kt)("p",null,"For example for ",(0,r.kt)("inlineCode",{parentName:"p"},"3")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"2"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We start with ",(0,r.kt)("inlineCode",{parentName:"li"},"3")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"2"),", and we increment ",(0,r.kt)("inlineCode",{parentName:"li"},"3")," and decrement ",(0,r.kt)("inlineCode",{parentName:"li"},"2")),(0,r.kt)("li",{parentName:"ul"},"On the next step we now have ",(0,r.kt)("inlineCode",{parentName:"li"},"4")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"1"),", we increment ",(0,r.kt)("inlineCode",{parentName:"li"},"4")," and decrement ",(0,r.kt)("inlineCode",{parentName:"li"},"1")),(0,r.kt)("li",{parentName:"ul"},"On the next step we now have ",(0,r.kt)("inlineCode",{parentName:"li"},"5")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"0"),", since the second number is ",(0,r.kt)("inlineCode",{parentName:"li"},"0")," we declare ",(0,r.kt)("inlineCode",{parentName:"li"},"5")," as the result.")),(0,r.kt)("p",null,"This can be written imperatively using a loop:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function add(n, m) {\n  while ((m /= 0)) {\n    n = increment(n);\n    m = decrement(m);\n  }\n  return n;\n}\n")),(0,r.kt)("p",null,"We can write the same algorithm in Haskell without mutation using recursion:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"add n m =\n  if m /= 0\n    then add (increment n) (decrement m)\n    else n\n")),(0,r.kt)("p",null,"In Haskell, in order to ",(0,r.kt)("em",{parentName:"p"},"emulate iteration with mutable state"),", we call the function again\nwith the values we want the variables to have in the next iteration."),(0,r.kt)("h3",{id:"evaluation-of-recursion"},"Evaluation of recursion"),(0,r.kt)("p",null,"Recursion commonly has a bad reputation for being slow and possibly unsafe compared to loops.\nThis is because in imperative languages, calling a function often requires creating\na new call stack."),(0,r.kt)("p",null,"However, functional languages (and Haskell in particular) play by different\nrules and implement a feature called tail call elimination - when the result of a function call\nis the result of the function (this is called tail position), we can just drop the current\nstack frame and then allocate one for the function we call, so we don't require ",(0,r.kt)("inlineCode",{parentName:"p"},"N")," stack frames\nfor ",(0,r.kt)("inlineCode",{parentName:"p"},"N")," iterations."),(0,r.kt)("p",null,"This is of course only one way to do tail call elimination and other\nstrategies exist, such as translating code like our recursive ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," above to the iteration version."),(0,r.kt)("h4",{id:"laziness"},"Laziness"),(0,r.kt)("p",null,"Haskell plays by slightly different rules because it uses a ",(0,r.kt)("em",{parentName:"p"},"lazy evaluation strategy"),"\ninstead of the much more common strict evaluation strategy. An ",(0,r.kt)("em",{parentName:"p"},"evaluation strategy"),'\nrefers to "when do we evaluate a computation". In a strict language the answer is simple:\n',(0,r.kt)("em",{parentName:"p"},"we evaluate the arguments of a function before entering a function"),"."),(0,r.kt)("p",null,"So for example the evaluation of ",(0,r.kt)("inlineCode",{parentName:"p"},"add (increment 3) (decrement 2)")," using strict evaluation\nwill look like this:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Evaluate ",(0,r.kt)("inlineCode",{parentName:"li"},"increment 3")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"4")),(0,r.kt)("li",{parentName:"ol"},"Evaluate ",(0,r.kt)("inlineCode",{parentName:"li"},"decrement 2")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"1")),(0,r.kt)("li",{parentName:"ol"},"Evaluate ",(0,r.kt)("inlineCode",{parentName:"li"},"add 4 1"))),(0,r.kt)("p",null,"Or, alternatively (depending on the language) we reverse (1) and (2) and evaluate the arguments\nfrom right-to-left instead of left-to-right."),(0,r.kt)("p",null,"On the other hand, with lazy evaluation, we ",(0,r.kt)("em",{parentName:"p"},"only evaluate computation when we need it"),", which\nis when it is part of a computation that will have some effect on the\noutside world, for example when writing a computation to standard output or sending it over the network."),(0,r.kt)("p",null,"So unless this computation is required, it won't be evaluated. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'main =\n  if add (increment 2) (decrement 3) == 5\n    then putStrLn "Yes."\n    else putStrLn "No."\n')),(0,r.kt)("p",null,"In the case above, we need the result of ",(0,r.kt)("inlineCode",{parentName:"p"},"add (increment 2) (decrement 3)"),"\nin order to know which message to write,\nso it will be evaluated. But:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'main =\n  let\n    five = add (increment 2) (decrement 3)\n  in\n    putStrLn "Not required"\n')),(0,r.kt)("p",null,"In the case above we don't actually need ",(0,r.kt)("inlineCode",{parentName:"p"},"five"),", so we don't evaluate it!"),(0,r.kt)("p",null,"But then if we know we need ",(0,r.kt)("inlineCode",{parentName:"p"},"add (increment 2) (decrement 3)"),",\ndo we use strict evaluation now? The answer is no - because we might not need\nto evaluate the arguments to complete the computation. For example in this case:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'const a b = a\n\nmain =\n  if const (increment 2) (decrement 3) == 3\n    then putStrLn "Yes."\n    else putStrLn "No."\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"const")," ignores the second argument and returns the first, so we don't actually need\nto calculate ",(0,r.kt)("inlineCode",{parentName:"p"},"decrement 3")," in order to provide an answer to the computation and in\nturn output an answer to the screen."),(0,r.kt)("p",null,"With the lazy evaluation strategy we will evaluate expressions when we need to (when they are required\nin order to do something for the user), and we evaluate from the outside in - first\nwe enter functions, and then we evaluate the arguments when we need to (usually when the thing\nwe want to evaluate appears in some control flow such as the condition of an ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," expression\nor a pattern in pattern matching)."),(0,r.kt)("hr",null),(0,r.kt)("p",null,"I've written a more in-depth blog post about how this works in Haskell:\n",(0,r.kt)("a",{parentName:"p",href:"https://gilmi.me/blog/post/2020/10/01/substitution-and-equational-reasoning"},"Substitution and Equational Reasoning"),"."),(0,r.kt)("p",null,"Please read it and try to evaluate the following program by hand:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'import Prelude hiding (const) -- feel free to ignore this line\n\nincrement n = n + 1\n\ndecrement n = n - 1\n\nconst a b = a\n\nadd n m =\n  if m /= 0\n    then add (increment n) (decrement m)\n    else n\n\nmain =\n  if const (add 3 2) (decrement 3) == 5\n    then putStrLn "Yes."\n    else putStrLn "No."\n')),(0,r.kt)("p",null,"Remember that evaluation always begins from ",(0,r.kt)("inlineCode",{parentName:"p"},"main"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("p",null,"evaluating ",(0,r.kt)("inlineCode",{parentName:"p"},"main")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if const (add 3 2) (decrement 3) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"expanding ",(0,r.kt)("inlineCode",{parentName:"p"},"const")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if add 3 2 == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"expanding ",(0,r.kt)("inlineCode",{parentName:"p"},"add")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if (if 2 /= 0 then add (increment 3) (decrement 2) else 3) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"evaluating the control flow ",(0,r.kt)("inlineCode",{parentName:"p"},"2 /= 0")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if (if True then add (increment 3) (decrement 2) else 3) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"Choosing the ",(0,r.kt)("inlineCode",{parentName:"p"},"then")," branch"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if (add (increment 3) (decrement 2)) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"expanding ",(0,r.kt)("inlineCode",{parentName:"p"},"add")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  ( if decrement 2 /= 0\n    then add\n      (increment (increment 3))\n      (decrement (decrement 2))\n    else (increment 3)\n  ) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"Evaluating ",(0,r.kt)("inlineCode",{parentName:"p"},"decrement 2")," in the control flow (notice how both places change!)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  ( if 1 /= 0\n    then add\n      (increment (increment 3))\n      (decrement 1)\n    else (increment 3)\n  ) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"Evaluating the control flow ",(0,r.kt)("inlineCode",{parentName:"p"},"1 /= 0")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  ( if True\n    then add\n      (increment (increment 3))\n      (decrement 1)\n    else (increment 3)\n  ) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"Choosing the ",(0,r.kt)("inlineCode",{parentName:"p"},"then")," branch"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  ( add\n    (increment (increment 3))\n    (decrement 1)\n  ) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"Expanding ",(0,r.kt)("inlineCode",{parentName:"p"},"add")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  ( if decrement 1 /= 0\n    then add\n      (increment (increment (increment 3)))\n      (decrement (decrement 1))\n    else increment (increment 3)\n  ) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"Evaluating control flow ",(0,r.kt)("inlineCode",{parentName:"p"},"decrement 1")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  ( if 0 /= 0\n    then add\n      (increment (increment (increment 3)))\n      (decrement 0)\n    else increment (increment 3)\n  ) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"Evaluating control flow ",(0,r.kt)("inlineCode",{parentName:"p"},"0 /= 0")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  ( if False\n    then add\n      (increment (increment (increment 3)))\n      (decrement 0)\n    else increment (increment 3)\n  ) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"Choosing the ",(0,r.kt)("inlineCode",{parentName:"p"},"else")," branch"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  (increment (increment 3)) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"Evaluate control flow ",(0,r.kt)("inlineCode",{parentName:"p"},"increment (increment 3)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  (increment 3 + 1) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"Evaluate in control flow ",(0,r.kt)("inlineCode",{parentName:"p"},"increment 3")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  (3 + 1 + 1) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"Evaluate in control flow ",(0,r.kt)("inlineCode",{parentName:"p"},"3 + 1")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  (4 + 1) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"Evaluate in control flow ",(0,r.kt)("inlineCode",{parentName:"p"},"4 + 1")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  5 == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"Evaluate in control flow ",(0,r.kt)("inlineCode",{parentName:"p"},"5 == 5")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  True\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,r.kt)("p",null,"Choosing the ",(0,r.kt)("inlineCode",{parentName:"p"},"then")," branch"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'putStrLn "Yes."\n')),(0,r.kt)("p",null,"Which when run will print ",(0,r.kt)("inlineCode",{parentName:"p"},"Yes.")," to the screen.")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"general-recursion"},"General recursion"),(0,r.kt)("p",null,"In general, when trying to solve problems recursively, it is useful to think\nabout the problem in three parts:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Finding the ",(0,r.kt)("strong",{parentName:"li"},"base case")," (the most simple cases - the ones we already know how to answer)"),(0,r.kt)("li",{parentName:"ol"},"Figuring out how to ",(0,r.kt)("strong",{parentName:"li"},"reduce")," the problem to something simpler (so it gets closer to the base case)"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Mitigating the difference")," between the reduced version and the solution we need to provide")),(0,r.kt)("p",null,"The reduce and mitigate steps together are usually called the ",(0,r.kt)("em",{parentName:"p"},"recursive step"),"."),(0,r.kt)("p",null,"Let's take a look at another example problem: generating a list of a particular size\nwith a specific value in place of every element."),(0,r.kt)("p",null,"In Haskell, this function would have the following signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"replicate :: Int -> a -> [a]\n")),(0,r.kt)("p",null,"Here are a few usage examples of ",(0,r.kt)("inlineCode",{parentName:"p"},"replicate"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> replicate 4 True\n[True,True,True,True]\nghci> replicate 0 True\n[]\nghci> replicate (-13) True\n[]\n")),(0,r.kt)("p",null,"How would we implement this function recursively? How would describe it in three steps above?"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Base case"),": the cases we already know how to generate are the cases where the length\nof the list is zero (or less) - we just return an empty list."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Reduce"),": while we might not know how to generate a list of size ",(0,r.kt)("inlineCode",{parentName:"li"},"N")," (where ",(0,r.kt)("inlineCode",{parentName:"li"},"N")," is positive),\nif we knew the solution for ",(0,r.kt)("inlineCode",{parentName:"li"},"N-1")," we could:"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Mitigate"),": Add another element to the solution for ",(0,r.kt)("inlineCode",{parentName:"li"},"N-1")," using the ",(0,r.kt)("inlineCode",{parentName:"li"},":")," (cons) operator.")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Try to write this in Haskell!"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"replicate :: Int -> a -> [a]\nreplicate n x =\n  if n <= 0    -- recognizing the base case\n    then\n      []       -- the solution for the base case\n    else\n        x : replicate (n - 1) x\n  --   ---  -------------------\n  --    ^           ^\n  --    |           |\n  --    |           +-------- reduction\n  --    |\n  --    +--- mitigation\n"))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"mutual-recursion"},"Mutual recursion"),(0,r.kt)("p",null,"When solving functions recursively we usually call the same function again,\nbut that doesn't have to be the case. It is possible to reduce our problem\nto something simpler that requires an answer from a different function.\nIf, in turn, that function will (or another function in that call chain)\ncall our function again, we have a ",(0,r.kt)("strong",{parentName:"p"},"mutual recursive")," solution."),(0,r.kt)("p",null,"For example, let's write two functions, one that checks whether a natural number\nis even or not, and one that checks whether a number is odd or not\nonly by decrementing it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"even :: Int -> Bool\n\nodd :: Int -> Bool\n")),(0,r.kt)("p",null,"Let's start with ",(0,r.kt)("inlineCode",{parentName:"p"},"even"),", how should we solve this recursively?"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Base case"),": We know the answer for ",(0,r.kt)("inlineCode",{parentName:"li"},"0")," - it is ",(0,r.kt)("inlineCode",{parentName:"li"},"True"),"."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Reduction"),": We might not know the answer for a general ",(0,r.kt)("inlineCode",{parentName:"li"},"N"),", but we could check whether ",(0,r.kt)("inlineCode",{parentName:"li"},"N - 1")," is odd,"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Mitigation"),": if ",(0,r.kt)("inlineCode",{parentName:"li"},"N - 1")," is odd, then ",(0,r.kt)("inlineCode",{parentName:"li"},"N")," is even! if it isn't odd, then ",(0,r.kt)("inlineCode",{parentName:"li"},"N")," isn't even.")),(0,r.kt)("p",null,"What about ",(0,r.kt)("inlineCode",{parentName:"p"},"odd"),"?"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Base case"),": We know the answer for ",(0,r.kt)("inlineCode",{parentName:"li"},"0")," - it is ",(0,r.kt)("inlineCode",{parentName:"li"},"False"),"."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Reduction"),": We might not know the answer for a general ",(0,r.kt)("inlineCode",{parentName:"li"},"N"),", but we could check whether ",(0,r.kt)("inlineCode",{parentName:"li"},"N - 1")," is even,"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Mitigation"),": if ",(0,r.kt)("inlineCode",{parentName:"li"},"N - 1")," is even, then ",(0,r.kt)("inlineCode",{parentName:"li"},"N")," is odd! if it isn't even, then ",(0,r.kt)("inlineCode",{parentName:"li"},"N")," isn't odd.")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Try writing this in Haskell!"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"even :: Int -> Bool\neven n =\n  if n == 0\n    then\n      True\n    else\n      odd (n - 1)\n\nodd :: Int -> Bool\nodd n =\n  if n == 0\n    then\n      False\n    else\n      even (n - 1)\n\n"))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"partial-functions"},"Partial functions"),(0,r.kt)("p",null,"Because we didn't handle the negative numbers cases in the example above,\nour functions will loop forever when a negative value is passed as input.\nA function that does not return a result for some value\n(either by not terminating or by throwing an error) is called ",(0,r.kt)("strong",{parentName:"p"},"a partial function"),"\n(because it only returns a result for a part of the possible inputs)."),(0,r.kt)("p",null,"Partial functions are generally considered ",(0,r.kt)("strong",{parentName:"p"},"bad practice")," because they can have\nundesired behaviour at runtime (a runtime exception or an infinite loop),\nso we want to ",(0,r.kt)("strong",{parentName:"p"},"avoid using")," partial functions\nas well as ",(0,r.kt)("strong",{parentName:"p"},"avoid writing")," partial functions."),(0,r.kt)("p",null,"The best way to avoid writing partial functions is by covering all inputs!\nIn the situation above, it is definitely possible to handle negative numbers\nas well, so we should do that! Or, instead, we could require that our functions\naccept a ",(0,r.kt)("inlineCode",{parentName:"p"},"Natural")," instead of an ",(0,r.kt)("inlineCode",{parentName:"p"},"Int"),", and then the type system would've stopped\nus from using these functions with values that we did not handle."),(0,r.kt)("p",null,"There are cases where we can't possibly cover all inputs, in these cases it is important\nto re-examine the code and see if we could further restrict the inputs using types to\nmitigate these issues."),(0,r.kt)("p",null,"For example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"head :: [a] -> a")," function from ",(0,r.kt)("inlineCode",{parentName:"p"},"Prelude")," promises\nto return the first element (the head) of a list, but we know that lists\ncould possibly be empty, so how can this function deliver on its promise?"),(0,r.kt)("p",null,"Unfortunately, it can't. But there exists a different function that can:\n",(0,r.kt)("inlineCode",{parentName:"p"},"head :: NonEmpty a -> a")," from the\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-List-NonEmpty.html"},(0,r.kt)("inlineCode",{parentName:"a"},"Data.List.NonEmpty")),"\nmodule! The trick here is that this other ",(0,r.kt)("inlineCode",{parentName:"p"},"head")," does not take a general list\nas input, it takes a different type entirely, one that promises to have\nat least one element, and therefore can deliver on its promise!"),(0,r.kt)("p",null,"We could also potentially use smart constructors with ",(0,r.kt)("inlineCode",{parentName:"p"},"newtype")," and enforce some sort\nof restrictions in the type system, as we saw in earlier chapters,\nBut this solution can sometimes be less ergonomic to use."),(0,r.kt)("p",null,"An alternative approach is to use ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," types to encode the absence of a proper result,\nfor example, using ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe"),", as we'll see in a future chapter."),(0,r.kt)("p",null,"Make sure the functions you write return a result for every input,\neither by constraining the input using types, or by encoding the absence of a result using\ntypes."),(0,r.kt)("h2",{id:"parsing-markup"},"Parsing markup?"),(0,r.kt)("p",null,"Let's get back to the task at hand."),(0,r.kt)("p",null,"As stated previously, our strategy for parsing the markup text is:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Split the string to a list where each element is a separate line\n(which we can do with ",(0,r.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:lines"},(0,r.kt)("inlineCode",{parentName:"a"},"lines")),"), and"),(0,r.kt)("li",{parentName:"ol"},"Go over the list line by line and process it, remembering\ninformation from previous lines if necessary")),(0,r.kt)("p",null,"Remember that we want to start by ignoring all of the markup syntax\nand just group lines together into paragraphs (paragraphs are separated by an empty line),\nand iteratively add new features later in the chapter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'parse :: String -> Document\nparse = parseLines [] . lines -- (1)\n\nparseLines :: [String] -> [String] -> Document\nparseLines currentParagraph txts =\n  let\n    paragraph = Paragraph (unlines (reverse currentParagraph)) -- (2), (3)\n  in\n    case txts of -- (4)\n      [] -> [paragraph]\n      currentLine : rest ->\n        if trim currentLine == ""\n          then\n            paragraph : parseLines [] rest -- (5)\n          else\n            parseLines (currentLine : currentParagraph) rest -- (6)\n\ntrim :: String -> String\ntrim = unwords . words\n')),(0,r.kt)("p",null,"Things to note:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"We pass a list that contains the currently grouped paragraph (paragraphs are separated by an empty line)")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Because of laziness, ",(0,r.kt)("inlineCode",{parentName:"p"},"paragraph")," is not computed until it's needed, so we don't have to worry about\nthe performance implications in the case that we are still grouping lines")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Why do we reverse ",(0,r.kt)("inlineCode",{parentName:"p"},"currentParagraph"),"? (See point (6))")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"We saw case expressions used to deconstruct ",(0,r.kt)("inlineCode",{parentName:"p"},"newtype"),"s and ",(0,r.kt)("inlineCode",{parentName:"p"},"Char"),"s,\nbut we can also pattern match on lists and other ADTs as well!\nIn this case we match against two patterns, an empty list (",(0,r.kt)("inlineCode",{parentName:"p"},"[]"),'),\nand a "cons cell" - a list with at least one element (',(0,r.kt)("inlineCode",{parentName:"p"},"currentLine : rest"),').\nIn the body of the "cons" pattern, we bind the first element to the name ',(0,r.kt)("inlineCode",{parentName:"p"},"currentLine"),",\nand the rest of the elements to the name ",(0,r.kt)("inlineCode",{parentName:"p"},"rest"),"."),(0,r.kt)("p",{parentName:"li"},"We will talk about how all of this works really soon!")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"When we run into an empty line we add the accumulated paragraph to the resulting list (A ",(0,r.kt)("inlineCode",{parentName:"p"},"Document")," is a list of structures) and start the function again with the rest of the input.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"We pass the new lines to be grouped in a paragraph ",(0,r.kt)("strong",{parentName:"p"},"in reverse order")," because of\nperformance characteristics - because of the nature of singly-linked lists,\nprepending an element is fast, and appending is slow. Prepending only requires\nus to create a new cons (",(0,r.kt)("inlineCode",{parentName:"p"},":"),") cell to hold a pointer to the value and a pointer to the list,\nbut appending requires us to traverse the list to its end and rebuild the cons cells -\nthe last one will contain the last value of the list and a pointer to the list to append,\nthe next will contain the value before the last value of the list and a pointer to the\nlist which contains the last element and the appended list, and so on."))),(0,r.kt)("p",null,"This code above will group together paragraphs in a structure, but how do we view our result?\nIn the next chapter we will take a short detour and talk about type classes, and how\nthey can help us in this scenario."))}c.isMDXComponent=!0}}]);