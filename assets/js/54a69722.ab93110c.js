"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[891],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,u=a(e,["components","mdxType","originalType","parentName"]),d=s(n),m=i,h=d["".concat(p,".").concat(m)]||d[m]||c[m]||o;return n?r.createElement(h,l(l({ref:t},u),{},{components:n})):r.createElement(h,l({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=m;var a={};for(var p in t)hasOwnProperty.call(t,p)&&(a[p]=t[p]);a.originalType=e,a[d]="string"==typeof e?e:i,l[1]=a;for(var s=2;s<o;s++)l[s]=n[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4866:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>a,toc:()=>s});var r=n(7462),i=(n(7294),n(3905));const o={},l="\ucf54\ub4dc\ub97c \uc791\uc131\ud574\ubd05\uc2dc\ub2e4!",a={unversionedId:"errors_and_files/implementation",id:"errors_and_files/implementation",title:"\ucf54\ub4dc\ub97c \uc791\uc131\ud574\ubd05\uc2dc\ub2e4!",description:"\uc9c0\uae08\uae4c\uc9c0 \ub9ce\uc740 \uc124\uba85\uc744 \ud588\uc2b5\ub2c8\ub2e4. \uc774\uc81c\ub294 \ubc30\uc6b4\uac83\uc744 \ud65c\uc6a9\ud574\ubd05\uc2dc\ub2e4. \ub2e4\uc74c \uc791\uc5c5\uc744 \ud560 \uac83\uc785\ub2c8\ub2e4.",source:"@site/docs/06-errors_and_files/04-implementation.md",sourceDirName:"06-errors_and_files",slug:"/errors_and_files/implementation",permalink:"/learn-haskell-blog-generator/errors_and_files/implementation",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/06-errors_and_files/04-implementation.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\uc608\uc678",permalink:"/learn-haskell-blog-generator/errors_and_files/exceptions"},next:{title:"Summary",permalink:"/learn-haskell-blog-generator/errors_and_files/summary"}},p={},s=[{value:"\uc0c8\ub85c\uc6b4 \ubaa8\ub4c8",id:"\uc0c8\ub85c\uc6b4-\ubaa8\ub4c8",level:2},{value:"\ub514\ub809\ud130\ub9ac \ubcc0\ud658\ud558\uae30",id:"\ub514\ub809\ud130\ub9ac-\ubcc0\ud658\ud558\uae30",level:2},{value:"<code>getDirFilesAndContent</code>",id:"getdirfilesandcontent",level:3},{value:"<code>applyIoOnList</code>",id:"applyioonlist",level:4},{value:"<code>filterAndReportFailures</code>",id:"filterandreportfailures",level:4},{value:"<code>createOutputDirectoryOrExit</code>",id:"createoutputdirectoryorexit",level:3},{value:"<code>txtsToRenderedHtml</code>",id:"txtstorenderedhtml",level:3},{value:"<code>copyFiles</code> and <code>writeFiles</code>",id:"copyfiles-and-writefiles",level:3},{value:"Summary",id:"summary",level:2}],u={toc:s},d="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"\ucf54\ub4dc\ub97c-\uc791\uc131\ud574\ubd05\uc2dc\ub2e4"},"\ucf54\ub4dc\ub97c \uc791\uc131\ud574\ubd05\uc2dc\ub2e4!"),(0,i.kt)("p",null,"\uc9c0\uae08\uae4c\uc9c0 \ub9ce\uc740 \uc124\uba85\uc744 \ud588\uc2b5\ub2c8\ub2e4. \uc774\uc81c\ub294 \ubc30\uc6b4\uac83\uc744 \ud65c\uc6a9\ud574\ubd05\uc2dc\ub2e4. \ub2e4\uc74c \uc791\uc5c5\uc744 \ud560 \uac83\uc785\ub2c8\ub2e4."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\ucd9c\ub825 \ub514\ub809\ud1a0\ub9ac\ub97c \uc0dd\uc131\ud569\ub2c8\ub2e4."),(0,i.kt)("li",{parentName:"ul"},"\ub514\ub809\ud1a0\ub9ac\uc758 \ubaa8\ub4e0 \ud30c\uc77c \uc774\ub984\uc744 \uac00\uc838\uc635\ub2c8\ub2e4."),(0,i.kt)("li",{parentName:"ul"},"\ud655\uc7a5\uc790\uc5d0 \ub530\ub77c \ud544\ud130\ub9c1\ud569\ub2c8\ub2e4."),(0,i.kt)("li",{parentName:"ul"},".txt \ud30c\uc77c\uc744 \ucc98\ub9ac\ud569\ub2c8\ub2e4."),(0,i.kt)("li",{parentName:"ul"},"\ub2e4\ub978 \ud30c\uc77c\uc740 \uc218\uc815\ud558\uc9c0 \uc54a\uace0 \ubcf5\uc0ac\ud569\ub2c8\ub2e4."),(0,i.kt)("li",{parentName:"ul"},"\uac01 \ud14d\uc2a4\ud2b8 \ud30c\uc77c\uc744 \uad6c\ubb38 \ubd84\uc11d\ud558\uace0 \uacb0\uacfc\uc758 \uc0c9\uc778\uc744 \uc791\uc131\ud558\uace0, \ud30c\uc77c\uc744 HTML\ub85c \ubcc0\ud658\ud558\uace0, \ubaa8\ub4e0 \uac83\uc744 \ub300\uc0c1 \ub514\ub809\ud1a0\ub9ac\uc5d0 \uc0dd\uc131\ud569\ub2c8\ub2e4.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"\ucd5c\uc885 \ud615\ud0dc\ub85c \uc81c\uc2dc\ub41c \ucf54\ub4dc\ub294 \ud55c \ubc88\uc5d0 \uc791\uc131\ud55c\uac8c \uc544\ub2d9\ub2c8\ub2e4.\n\ucf54\ub4dc \uc791\uc131, \ub9ac\ud329\ud130\ub9c1, \ud568\uc218 \ubd84\ud560, \ud0c0\uc785 \uc2dc\uadf8\ub2c8\ucc98 \ubcc0\uacbd \ub4f1\uc758 \ubc18\ubcf5 \uacfc\uc815\uc774\uc5c8\uc2b5\ub2c8\ub2e4.\n\ucf54\ub529 \ubb38\uc81c\ub97c \ud574\uacb0\ud560 \ub54c\ub294 \uc791\uace0 \uac04\ub2e8\ud55c \uac83\ubd80\ud130 \uc2dc\uc791\ud558\uace0, \uc791\ub3d9\ud558\uac8c \ub9cc\ub4e4\uace0, \ucf54\ub4dc\uac00 \ub354 \uba85\ud655\ud558\uace0 \ubaa8\ub4c8\ud654\ub418\ub3c4\ub85d \ub9ac\ud329\ud130\ub9c1\ud558\ub294 \uac83\uc774 \uc88b\uc2b5\ub2c8\ub2e4.\n\ud558\uc2a4\ucf08\uc5d0\uc11c\ub294 \uc6b0\ub9ac\uac00 \ucf54\ub4dc\ub97c \ub9ac\ud329\ud130\ub9c1\ud558\uace0 \uc2dc\uac04\uc774 \uc9c0\ub0a8\uc5d0 \ub530\ub77c \uac1c\uc120\ud560 \uc218 \uc788\ub294 \ub2a5\ub825\uc5d0 \uc790\ubd80\uc2ec\uc744 \uac00\uc9c0\uace0 \uc788\uc73c\uba70, \uc0c8\ub85c\uc6b4 \uc18c\ud504\ud2b8\uc6e8\uc5b4\ub97c \uc791\uc131\ud560 \ub54c\ub3c4 \uadf8 \uc6d0\uce59\uc774 \uc720\uc9c0\ub429\ub2c8\ub2e4!")),(0,i.kt)("h2",{id:"\uc0c8\ub85c\uc6b4-\ubaa8\ub4c8"},"\uc0c8\ub85c\uc6b4 \ubaa8\ub4c8"),(0,i.kt)("p",null,"\uba3c\uc800 ",(0,i.kt)("inlineCode",{parentName:"p"},"HsBlog.Directory"),"\ub77c\ub294 \uc0c8\ub85c\uc6b4 \ubaa8\ub4c8\uc744 \ub9cc\ub4e4\uaca0\uc2b5\ub2c8\ub2e4.\n\uc774 \ubaa8\ub4c8\uc740 \ub514\ub809\ud130\ub9ac\uc640 \uc5ec\ub7ec \ud30c\uc77c\uc744 \ucc98\ub9ac\ud560 \uac83\uc785\ub2c8\ub2e4.\n\uc774 \ubaa8\ub4c8\uc5d0\uc11c\ub294 \uc774\uc804\uc5d0 \uc815\uc758\ud55c ",(0,i.kt)("inlineCode",{parentName:"p"},"convertDirectory"),"\uc640 ",(0,i.kt)("inlineCode",{parentName:"p"},"buildIndex")," \ud568\uc218\ub97c \ub0b4\ubcf4\ub0bc \uac83\uc785\ub2c8\ub2e4."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"-- | \uc5ec\ub7ec \ud30c\uc77c\uc744 \ucc98\ub9ac\ud558\uace0 \ub514\ub809\ud1a0\ub9ac\ub97c \ubcc0\ud658\ud569\ub2c8\ub2e4\n\nmodule HsBlog.Directory\n  ( convertDirectory\n  , buildIndex\n  )\n  where\n")),(0,i.kt)("p",null,"\uc774 \ubaa8\ub4c8\uc5d0\uc11c\ub294 \ub514\ub809\ud130\ub9ac, \ud30c\uc77c \ubc0f \ud30c\uc77c \uacbd\ub85c\ub97c \uc870\uc791\ud558\ub294 \ub370 \uc0ac\uc6a9\ud560\n",(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/directory-1.3.7.0/docs/System-Directory.html"},"directory"),"\n\uc640 ",(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/filepath-1.4.2.1/docs/System-FilePath.html"},"filepath"),"\n\ub77c\uc774\ube0c\ub7ec\ub9ac\ub97c \uc0ac\uc6a9\ud569\ub2c8\ub2e4.\n\uc6b0\ub9ac\uac00 \ubc30\uc6b4 \uc0c8\ub85c\uc6b4 \ucd94\uc0c1\ud654\uc778 ",(0,i.kt)("inlineCode",{parentName:"p"},"Traversable"),"\uc640 ",(0,i.kt)("inlineCode",{parentName:"p"},"Monad"),", \uadf8\ub9ac\uace0 \uc774\uc804\uc5d0 \ubc30\uc6b4 \uac1c\ub150\uacfc \ud0c0\uc785\uc778 ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," \ubc0f \uc608\uc678\ub97c \uc0ac\uc6a9\ud560 \uac83\uc785\ub2c8\ub2e4."),(0,i.kt)("p",null,"\uc774\ub97c \uc704\ud574, \uaf64 \ub9ce\uc740 \ubaa8\ub4c8\uc774 \ud544\uc694\ud569\ub2c8\ub2e4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"import qualified HsBlog.Markup as Markup\nimport qualified HsBlog.Html as Html\nimport HsBlog.Convert (convert, convertStructure)\n\nimport Data.List (partition)\nimport Data.Traversable (for)\nimport Control.Monad (void, when)\n\nimport System.IO (hPutStrLn, stderr)\nimport Control.Exception (catch, displayException, SomeException(..))\nimport System.Exit (exitFailure)\nimport System.FilePath\n  ( takeExtension\n  , takeBaseName\n  , (<.>)\n  , (</>)\n  , takeFileName\n  )\nimport System.Directory\n  ( createDirectory\n  , removeDirectoryRecursive\n  , listDirectory\n  , doesDirectoryExist\n  , copyFile\n  )\n")),(0,i.kt)("p",null,"\uc774\ubc88\uc5d0 \uc0ac\uc6a9\ud560 \uac01 \ud568\uc218\ub4e4\uc774 \uc5b4\ub5a4 \uc5ed\ud560\uc744 \ud558\ub294\uc9c0 \ud655\uc2e4\ud558\uc9c0 \uc54a\ub2e4\uba74 ",(0,i.kt)("a",{parentName:"p",href:"https://hoogle.haskell.org/"},"Hoogle"),"\uc744 \ucc38\uace0\ud558\uc138\uc694.\n\ud0c0\uc785 \uc2dc\uadf8\ub2c8\ucc98\uc640 \ubb38\uc11c\ub97c \uc77d\uace0 ",(0,i.kt)("inlineCode",{parentName:"p"},"ghci"),"\uc5d0\uc11c \uc2e4\ud5d8\ud574\ubcf4\uc138\uc694."),(0,i.kt)("h2",{id:"\ub514\ub809\ud130\ub9ac-\ubcc0\ud658\ud558\uae30"},"\ub514\ub809\ud130\ub9ac \ubcc0\ud658\ud558\uae30"),(0,i.kt)("p",null,"\uba3c\uc800 \ub2e4\ub978 \uc791\uc740 \ud568\uc218\ub4e4\uc744 \ucea1\uc220\ud654\ud55c \uace0\ucc28 \ud568\uc218\uc778 ",(0,i.kt)("inlineCode",{parentName:"p"},"convertDirectory"),"\uc758 \uc124\uba85\uc73c\ub85c \uc2dc\uc791\ud558\uaca0\uc2b5\ub2c8\ub2e4.\n",(0,i.kt)("inlineCode",{parentName:"p"},"convertDirectory"),"\ub294 \uaf64 \uba85\ub839\ud615\uc801\uc778 \ubaa8\uc2b5\uc744 \ud558\uace0 \uc788\uc73c\uba70, \uc6b0\ub9ac\uac00 \ud574\uc57c\ud560 \uc791\uc5c5\uc744 \ub2e4\ub978 \ubc29\uc2dd\uc73c\ub85c \uc124\uba85\ud558\ub294 \uac83\ucc98\ub7fc \ubcf4\uc785\ub2c8\ub2e4."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"-- | \ud2b9\uc815 \ub514\ub809\ud130\ub9ac\uc758 \ud30c\uc77c\uc744 \ub2e4\ub978 \ub514\ub809\ud130\ub9ac\ub85c \ubcf5\uc0ac\ud558\uace0, '.txt' \ud30c\uc77c\uc744 '.html' \ud30c\uc77c\ub85c \ubcc0\ud658\ud569\ub2c8\ub2e4.\n-- \uc77d\uae30\ub098 \uc4f0\uae30\uc5d0 \uc2e4\ud328\ud55c \uacbd\uc6b0 stderr\uc5d0 \uae30\ub85d\ud569\ub2c8\ub2e4.\n--\n-- May throw an exception on output directory creation.\nconvertDirectory :: FilePath -> FilePath -> IO ()\nconvertDirectory inputDir outputDir = do\n  DirContents filesToProcess filesToCopy <- getDirFilesAndContent inputDir\n  createOutputDirectoryOrExit outputDir\n  let\n    outputHtmls = txtsToRenderedHtml filesToProcess\n  copyFiles outputDir filesToCopy\n  writeFiles outputDir outputHtmls\n  putStrLn \"Done.\"\n")),(0,i.kt)("p",null,"\uc5ec\uae30\uc11c \uc6b0\ub9ac\ub294 \uac01 ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," \ud568\uc218\uac00 \uc5d0\ub7ec\ub97c \uc801\uc808\ud558\uac8c \ucc98\ub9ac\ud558\uace0, \ud544\uc694\ud560 \ub54c \ud504\ub85c\uc81d\ud2b8\ub97c \uc885\ub8cc\ud55c\ub2e4\uace0 \uac00\uc815\ud588\uc2b5\ub2c8\ub2e4."),(0,i.kt)("p",null,"\uc774\uc81c \ub2e8\uacc4\ubcc4\ub85c \uc0b4\ud3b4\ubcf4\uaca0\uc2b5\ub2c8\ub2e4."),(0,i.kt)("h3",{id:"getdirfilesandcontent"},(0,i.kt)("inlineCode",{parentName:"h3"},"getDirFilesAndContent")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"-- | \uc560\ud50c\ub9ac\ucf00\uc774\uc158\uc5d0 \ud544\uc694\ud55c \ub514\ub809\ud130\ub9ac \ub0b4\uc6a9\ndata DirContents\n  = DirContents\n    { dcFilesToProcess :: [(FilePath, String)]\n      -- ^ \ud30c\uc77c \uacbd\ub85c\uc640 \uadf8 \ub0b4\uc6a9\n    , dcFilesToCopy :: [FilePath]\n      -- ^ Other file paths, to be copied directly\n      -- ^ \ub2e4\ub978 \ud30c\uc77c \uacbd\ub85c, \uc9c1\uc811 \ubcf5\uc0ac\ub420 \uac83\n    }\n\n-- | \ub514\ub809\ud130\ub9ac \ub0b4\uc6a9\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4\ngetDirFilesAndContent :: FilePath -> IO DirContents\n\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"getDirFilesAndContent"),"\ub294 \ucc98\ub9ac\ub97c \uc704\ud55c \uc5f0\uad00\ub3c4\ub2c8 \ud30c\uc77c\ub4e4\uc744 \uc81c\uacf5\ud558\ub294 \uc5ed\ud560\uc744 \ud569\ub2c8\ub2e4. --\n\ub9c8\ud06c\uc5c5\uc73c\ub85c \ubcc0\ud658\ud574\uc57c \ud560 \ud30c\uc77c(\uadf8\ub9ac\uace0 \uadf8\ub4e4\uc758 \ud14d\uc2a4\ud2b8 \ub0b4\uc6a9)\uacfc \uc774\ubbf8\uc9c0\ub098 \uc2a4\ud0c0\uc77c\uc2dc\ud2b8\uc640 \uac19\uc774 \uadf8\ub300\ub85c \ubcf5\uc0ac\ud560 \ub2e4\ub978 \ud30c\uc77c\ub4e4\uc785\ub2c8\ub2e4."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'-- | \ub514\ub809\ud130\ub9ac \ub0b4\uc6a9\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4\ngetDirFilesAndContent :: FilePath -> IO DirContents\ngetDirFilesAndContent inputDir = do\n  files <- map (inputDir </>) <$> listDirectory inputDir\n  let\n    (txtFiles, otherFiles) =\n      partition ((== ".txt") . takeExtension) files\n  txtFilesAndContent <-\n    applyIoOnList readFile txtFiles >>= filterAndReportFailures\n  pure $ DirContents\n    { dcFilesToProcess = txtFilesAndContent\n    , dcFilesToCopy = otherFiles\n    }\n')),(0,i.kt)("p",null,"\uc774 \ud568\uc218\ub294 \ub124 \uac00\uc9c0 \uc911\uc694\ud55c \uc77c\uc744 \ud569\ub2c8\ub2e4:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"\ub514\ub809\ud130\ub9ac \ub0b4\uc758 \ubaa8\ub4e0 \ud30c\uc77c\uc744 \ub098\uc5f4\ud569\ub2c8\ub2e4"),(0,i.kt)("li",{parentName:"ol"},"\ud30c\uc77c\ub4e4\uc744 \ud655\uc7a5\uc790\uc5d0 \ub530\ub77c \ub450 \uadf8\ub8f9\uc73c\ub85c \ub098\ub215\ub2c8\ub2e4"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},".txt")," \ud30c\uc77c\uc758 \ub0b4\uc6a9\uc744 \uc77d\uace0, \ud30c\uc77c\uc744 \uc77d\ub294 \ub370 \uc2e4\ud328\ud55c \uacbd\uc6b0 \ubcf4\uace0\ud569\ub2c8\ub2e4"),(0,i.kt)("li",{parentName:"ol"},"\uacb0\uacfc\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4. \uacb0\uacfc\ub97c \ub354 \uba85\ud655\ud558\uac8c \ud558\uae30 \uc704\ud574 \ub370\uc774\ud130 \ud0c0\uc785\uc744 \uc815\uc758\ud588\uc2b5\ub2c8\ub2e4.")),(0,i.kt)("p",null,"(3)\ubc88\uc740 \ub098\uba38\uc9c0\ubcf4\ub2e4 \uc870\uae08 \ub354 \ubcf5\uc7a1\ud569\ub2c8\ub2e4. \uc774\ub97c \uc0b4\ud3b4\ubcf4\uaca0\uc2b5\ub2c8\ub2e4."),(0,i.kt)("h4",{id:"applyioonlist"},(0,i.kt)("inlineCode",{parentName:"h4"},"applyIoOnList")),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"applyIoOnList"),"\ub294 \ub2e4\uc74c\uacfc \uac19\uc740 \ud0c0\uc785 \uc2dc\uadf8\ub2c8\ucc98\ub97c \uac00\uc9d1\ub2c8\ub2e4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"applyIoOnList :: (a -> IO b) -> [a] -> IO [(a, Either String b)]\n")),(0,i.kt)("p",null,"\uc774 \ud568\uc218\ub294 ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," \ud568\uc218\ub97c \ud2b9\uc815 \uac12\ub4e4\uc758 \ub9ac\uc2a4\ud2b8\uc5d0 \uc801\uc6a9\ud558\uace0, \uc131\uacf5\uacfc \uc2e4\ud328\ub97c \uae30\ub85d\ud569\ub2c8\ub2e4."),(0,i.kt)("p",null,"\ud55c \ubc88 \uad6c\ud604\ud574\ubcf4\uc138\uc694! \uc5b4\ub5a4 \ud568\uc218\ub97c \uc0ac\uc6a9\ud574\uc57c \ud560\uc9c0 \ud78c\ud2b8\uac00 \ud544\uc694\ud558\ub2e4\uba74, \uc774\uc804\uc5d0 \uc791\uc131\ud55c \uac00\uc838\uc624\uae30 \ubaa9\ub85d\uc744 \ucc38\uace0\ud558\uc138\uc694."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"\uc815\ub2f5"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"-- | IO \ud568\uc218\ub97c \uac12\ub4e4\uc758 \ub9ac\uc2a4\ud2b8\uc5d0 \uc801\uc6a9\ud558\uace0, \uc131\uacf5\uacfc \uc2e4\ud328\ub97c \uae30\ub85d\ud569\ub2c8\ub2e4\napplyIoOnList :: (a -> IO b) -> [a] -> IO [(a, Either String b)]\napplyIoOnList action inputs = do\n  for inputs $ \\input -> do\n    maybeResult <-\n      catch\n        (Right <$> action input)\n        ( \\(SomeException e) -> do\n          pure $ Left (displayException e)\n        )\n    pure (input, maybeResult)\n"))),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"applyIoOnList"),"\ub294 \ud2b9\uc815 ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," \ud568\uc218\ub97c(\uc774\ubc88 \uacbd\uc6b0 ",(0,i.kt)("inlineCode",{parentName:"p"},"readFile"),") \ud2b9\uc815 \uac12\ub4e4\uc758 \ub9ac\uc2a4\ud2b8(\uc774\ubc88 \uacbd\uc6b0 ",(0,i.kt)("inlineCode",{parentName:"p"},"FilePath"),")\uc5d0 \uc801\uc6a9\ud558\ub294 \uace0\ucc28 \ud568\uc218\uc785\ub2c8\ub2e4.\n\uac01 \uc694\uc18c\uc5d0 \ub300\ud574, \uc694\uc18c \uadf8 \uc790\uccb4\uc640 ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," \ud568\uc218\ub97c \uc801\uc6a9\ud55c \uacb0\uacfc\ub97c ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),"\ub85c \ubcc0\ud658\ud55c \uac12\uc744 \ud568\uaed8 \ubc18\ud658\ud569\ub2c8\ub2e4.\n\uc5ec\uae30\uc11c ",(0,i.kt)("inlineCode",{parentName:"p"},"Left")," \ud0c0\uc785\uc740 ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),"\uc73c\ub85c, \uc5d0\ub7ec\ub97c \ub098\ud0c0\ub0c5\ub2c8\ub2e4."),(0,i.kt)("p",null,"\uc774 \ud568\uc218\uc758 \ud0c0\uc785 \ub9cc\uc73c\ub85c\ub3c4 \ud568\uc218\uac00 \uc5b4\ub5a4 \uc77c\uc744 \ud560\uc9c0\uc5d0 \ub300\ud574 \ub9ce\uc740 \uac83\uc744 \uc54c \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\ud0c0\uc785\uc774 \ub2e4\ud615\uc801\uc774\uae30 \ub54c\ubb38\uc5d0, ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),"\uc5d0 \ub300\ud574 \ud560 \uc218 \uc788\ub294 \uc77c\uc740 \ud568\uc218\uc5d0 \uc801\uc6a9\ud558\ub294 \uac83 \ubfd0\uc774\uace0, ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),"\ub97c \uc0dd\uc131\ud560 \uc218 \uc788\ub294 \uacf3\uc740 \ud568\uc218\uc758 \uacb0\uacfc\ubfd0\uc785\ub2c8\ub2e4."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"\uc774 \ud568\uc218\ub97c \ucc98\uc74c \uc791\uc131\ud560 \ub54c\ub294 ",(0,i.kt)("inlineCode",{parentName:"p"},"readFile"),"\uc5d0\ub9cc \ud2b9\ud654\ub418\uc5b4 \uc788\uc5c8\uace0, ",(0,i.kt)("inlineCode",{parentName:"p"},"[FilePath]"),"\ub97c \ubc1b\uc544 ",(0,i.kt)("inlineCode",{parentName:"p"},"IO [(FilePath, Either String String)]"),"\ub97c \ubc18\ud658\ud588\uc2b5\ub2c8\ub2e4.\n\ud558\uc9c0\ub9cc \ucd94\ud6c4\uc5d0 \ub2e4\ub978 \uc0ac\uc6a9 \uc0ac\ub840\ub97c \ub9cc\ub098\uac8c \ub418\uc5c8\uace0(",(0,i.kt)("inlineCode",{parentName:"p"},"writeFiles"),"\uc640 ",(0,i.kt)("inlineCode",{parentName:"p"},"copyFiles"),"), ",(0,i.kt)("inlineCode",{parentName:"p"},"action"),", \uc785\ub825 \ud0c0\uc785, \ubc18\ud658 \ud0c0\uc785\uc744 \ubd84\ub9ac\ud588\uc2b5\ub2c8\ub2e4.")),(0,i.kt)("p",null,"\uc774 \ud568\uc218\ub294 \uc5d0\ub7ec\ub97c \ucc98\ub9ac\ud558\uae30 \uc704\ud574 \uc608\uc678\ub97c \uc0ac\uc6a9\ud558\uace0, ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),"\ub97c \uc0ac\uc6a9\ud574 \uc131\uacf5\uacfc \uc2e4\ud328\ub97c \ubaa8\ub450 \ud0c0\uc785 \uc2dc\uc2a4\ud15c\uc5d0 \ud45c\ud604\ud569\ub2c8\ub2e4.\n\uc774\ub97c \ud1b5\ud574 \uc608\uc678 \ucc98\ub9ac\ub97c \ud568\uc218 \ud638\ucd9c\uc790\uc5d0\uac8c \ubbf8\ub8f8\uacfc \ub3d9\uc2dc\uc5d0 \ud638\ucd9c\uc790\uac00 \uc608\uc678 \ucc98\ub9ac\ub97c \uc78a\uc9c0 \uc54a\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4!"),(0,i.kt)("p",null,"\ub2e4\uc74c\uc5d0\ub294, \uc5d0\ub7ec\ub97c \ubcf4\uace0\ud558\uace0 \uc2e4\ud328\ud558\ub294 \ubaa8\ub4e0 \uacbd\uc6b0\ub97c \ud544\ud130\ub9c1\ud558\ub294 \ud568\uc218\ub97c \uc0b4\ud3b4\ubcf4\uaca0\uc2b5\ub2c8\ub2e4."),(0,i.kt)("h4",{id:"filterandreportfailures"},(0,i.kt)("inlineCode",{parentName:"h4"},"filterAndReportFailures")),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"filterAndReportFailures")," has the following type signature:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"filterAndReportFailures :: [(a, Either String b)] -> IO [(a, b)]\n")),(0,i.kt)("p",null,"It filters out unsuccessful operations on files and reports errors to the stderr."),(0,i.kt)("p",null,"Try to implement it!"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Answer"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"-- | Filter out unsuccessful operations on files and report errors to stderr.\nfilterAndReportFailures :: [(a, Either String b)] -> IO [(a, b)]\nfilterAndReportFailures =\n  foldMap $ \\(file, contentOrErr) ->\n    case contentOrErr of\n      Left err -> do\n        hPutStrLn stderr err\n        pure []\n      Right content ->\n        pure [(file, content)]\n")),(0,i.kt)("p",null,"This code may seem a bit surprising - how come we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"foldMap")," here? Reminder,\nthe type of ",(0,i.kt)("inlineCode",{parentName:"p"},"foldMap")," is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m\n")),(0,i.kt)("p",null,"If we specialize this function for our use case, substituting the general type\nwith the types we are using, we learn that ",(0,i.kt)("inlineCode",{parentName:"p"},"IO [(a, b)]")," is a monoid.\nAnd indeed - ",(0,i.kt)("inlineCode",{parentName:"p"},"[a]")," is a monoid for any ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"[]")," (the empty list) as ",(0,i.kt)("inlineCode",{parentName:"p"},"mempty"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"++")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"<>"),", but also ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a")," is a monoid for any ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," that is itself\na monoid with ",(0,i.kt)("inlineCode",{parentName:"p"},"pure mempty")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"mempty")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"liftA2 (<>)")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"<>"),"!"),(0,i.kt)("p",null,"Using these instances, we can ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," over the content, handle errors, and return\nan empty list to filter out a failed case, or a singleton list to keep the result.\nAnd the ",(0,i.kt)("inlineCode",{parentName:"p"},"fold")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"foldMap")," will concatenate the resulting list where we return\nall of the successful cases!"),(0,i.kt)("p",null,"If you've written this in a different way that does the same thing, that's fine too!\nIt's just nice to see how sometimes abstractions can be used to write concise code.")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"These functions are responsible for fetching the right information. Next,\nlet's look at the code for creating a new directory."),(0,i.kt)("h3",{id:"createoutputdirectoryorexit"},(0,i.kt)("inlineCode",{parentName:"h3"},"createOutputDirectoryOrExit")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'-- | Creates an output directory or terminates the program\ncreateOutputDirectoryOrExit :: FilePath -> IO ()\ncreateOutputDirectoryOrExit outputDir =\n  whenIO\n    (not <$> createOutputDirectory outputDir)\n    (hPutStrLn stderr "Cancelled." *> exitFailure)\n\n-- | Creates the output directory.\n--   Returns whether the directory was created or not.\ncreateOutputDirectory :: FilePath -> IO Bool\ncreateOutputDirectory dir = do\n  dirExists <- doesDirectoryExist dir\n  create <-\n    if dirExists\n      then do\n        override <- confirm "Output directory exists. Override?"\n        when override (removeDirectoryRecursive dir)\n        pure override\n      else\n        pure True\n  when create (createDirectory dir)\n  pure create\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"createOutputDirectoryOrExit")," itself is not terribly exciting, it does\nwhat it is named -- it tries to create the output directory, and exits the\nprogram in case it didn't succeed."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"createOutputDirectory")," is the function that actually does the heavy lifting.\nIt checks if the directory already exists, and checks if the user would like to\noverride it. If they do, we remove it and create the new directory; if they don't,\nwe do nothing and report their decision."),(0,i.kt)("h3",{id:"txtstorenderedhtml"},(0,i.kt)("inlineCode",{parentName:"h3"},"txtsToRenderedHtml")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"let\n  outputHtmls = txtsToRenderedHtml filesToProcess\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"In this part of the code we convert files to markup and change the\ninput file paths to their respective output file paths (",(0,i.kt)("inlineCode",{parentName:"p"},".txt")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},".html"),").\nWe then build the index page, and convert everything to HTML."),(0,i.kt)("p",null,"Implement ",(0,i.kt)("inlineCode",{parentName:"p"},"txtsToRenderedHtml"),", which has the following type signature:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"txtsToRenderedHtml :: [(FilePath, String)] -> [(FilePath, String)]\n")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Hint"),(0,i.kt)("p",null,"I implemented this by defining three functions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"txtsToRenderedHtml :: [(FilePath, String)] -> [(FilePath, String)]\n\ntoOutputMarkupFile :: (FilePath, String) -> (FilePath, Markup.Document)\n\nconvertFile :: (FilePath, Markup.Document) -> (FilePath, Html.Html)\n"))),(0,i.kt)("p",null,"."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Answer"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'-- | Convert text files to Markup, build an index, and render as html.\ntxtsToRenderedHtml :: [(FilePath, String)] -> [(FilePath, String)]\ntxtsToRenderedHtml txtFiles =\n  let\n    txtOutputFiles = map toOutputMarkupFile txtFiles\n    index = ("index.html", buildIndex txtOutputFiles)\n  in\n    map (fmap Html.render) (index : map convertFile txtOutputFiles)\n\ntoOutputMarkupFile :: (FilePath, String) -> (FilePath, Markup.Document)\ntoOutputMarkupFile (file, content) =\n  (takeBaseName file <.> "html", Markup.parse content)\n\nconvertFile :: (FilePath, Markup.Document) -> (FilePath, Html.Html)\nconvertFile (file, doc) = (file, convert file doc)\n')),(0,i.kt)("p",null,"One possibly surprising thing about this code could be the ",(0,i.kt)("inlineCode",{parentName:"p"},"map (fmap Html.render)"),"\npart. We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap")," on the tuple because it is a ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," on the second\nargument, just like ",(0,i.kt)("inlineCode",{parentName:"p"},"Either"),"!")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"copyfiles-and-writefiles"},(0,i.kt)("inlineCode",{parentName:"h3"},"copyFiles")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"writeFiles")),(0,i.kt)("p",null,"The only thing left to do is to write the directory\ncontent, after the processing is completed, to the newly created directory:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"-- | Copy files to a directory, recording errors to stderr.\ncopyFiles :: FilePath -> [FilePath] -> IO ()\ncopyFiles outputDir files = do\n  let\n    copyFromTo file = copyFile file (outputDir </> takeFileName file)\n  void $ applyIoOnList copyFromTo files >>= filterAndReportFailures\n")),(0,i.kt)("p",null,"Here we use ",(0,i.kt)("inlineCode",{parentName:"p"},"applyIoOnList")," again to do something a bit more complicated,\ninstead of reading from a file, it copies from the input path to a newly generated\noutput path. Then we pass the result (which has the type ",(0,i.kt)("inlineCode",{parentName:"p"},"[(FilePath, Either String ())]"),")\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"filterAndReportFailures")," to print the errors and filter out the unsuccessful copies.\nBecause we are not really interested in the output of ",(0,i.kt)("inlineCode",{parentName:"p"},"filterAndReportFailures"),",\nwe discard it with ",(0,i.kt)("inlineCode",{parentName:"p"},"void"),", returning ",(0,i.kt)("inlineCode",{parentName:"p"},"()")," as a result instead:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"-- | Write files to a directory, recording errors to stderr.\nwriteFiles :: FilePath -> [(FilePath, String)] -> IO ()\nwriteFiles outputDir files = do\n  let\n    writeFileContent (file, content) =\n      writeFile (outputDir </> file) content\n  void $ applyIoOnList writeFileContent files >>= filterAndReportFailures\n")),(0,i.kt)("p",null,"Once again, this code looks almost exactly like ",(0,i.kt)("inlineCode",{parentName:"p"},"copyFiles"),", but the types are different.\nHaskell's combination of parametric polymorphism + type class for abstractions is really\npowerful, and has helped us reduce quite a bit of code."),(0,i.kt)("hr",null),(0,i.kt)("p",null,"This pattern of using ",(0,i.kt)("inlineCode",{parentName:"p"},"applyIoOnList")," and then ",(0,i.kt)("inlineCode",{parentName:"p"},"filterAndReportFailures"),"\nhappens more than once. It might be a good candidate for refactoring. Try it!\nWhat do you think about the resulting code? Is it easier or more difficult to\nunderstand? Is it more modular or less? What are the pros and cons?"),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"With that, we have completed our ",(0,i.kt)("inlineCode",{parentName:"p"},"HsBlog.Directory")," module that is responsible for converting\na directory safely. Note that the code could probably be simplified quite a bit if we\nwere fine with errors crashing the entire program altogether, but sometimes this is\nthe price we pay for robustness. It is up to you to choose what you can live with\nand what not, but I hope this saga has taught you how to approach error handling\nin Haskell in case you need to."),(0,i.kt)("p",null,"View the full module:"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"HsBlog.Directory"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'-- | Process multiple files and convert directories\n\nmodule HsBlog.Directory\n  ( convertDirectory\n  , buildIndex\n  )\n  where\n\nimport qualified HsBlog.Markup as Markup\nimport qualified HsBlog.Html as Html\nimport HsBlog.Convert (convert, convertStructure)\n\nimport Data.List (partition)\nimport Data.Traversable (for)\nimport Control.Monad (void, when)\n\nimport System.IO (hPutStrLn, stderr)\nimport Control.Exception (catch, displayException, SomeException(..))\nimport System.Exit (exitFailure)\nimport System.FilePath\n  ( takeExtension\n  , takeBaseName\n  , (<.>)\n  , (</>)\n  , takeFileName\n  )\nimport System.Directory\n  ( createDirectory\n  , removeDirectoryRecursive\n  , listDirectory\n  , doesDirectoryExist\n  , copyFile\n  )\n\n-- | Copy files from one directory to another, converting \'.txt\' files to\n--   \'.html\' files in the process. Recording unsuccessful reads and writes to stderr.\n--\n-- May throw an exception on output directory creation.\nconvertDirectory :: FilePath -> FilePath -> IO ()\nconvertDirectory inputDir outputDir = do\n  DirContents filesToProcess filesToCopy <- getDirFilesAndContent inputDir\n  createOutputDirectoryOrExit outputDir\n  let\n    outputHtmls = txtsToRenderedHtml filesToProcess\n  copyFiles outputDir filesToCopy\n  writeFiles outputDir outputHtmls\n  putStrLn "Done."\n\n------------------------------------\n-- * Read directory content\n\n-- | Returns the directory content\ngetDirFilesAndContent :: FilePath -> IO DirContents\ngetDirFilesAndContent inputDir = do\n  files <- map (inputDir </>) <$> listDirectory inputDir\n  let\n    (txtFiles, otherFiles) =\n      partition ((== ".txt") . takeExtension) files\n  txtFilesAndContent <-\n    applyIoOnList readFile txtFiles >>= filterAndReportFailures\n  pure $ DirContents\n    { dcFilesToProcess = txtFilesAndContent\n    , dcFilesToCopy = otherFiles\n    }\n\n-- | The relevant directory content for our application\ndata DirContents\n  = DirContents\n    { dcFilesToProcess :: [(FilePath, String)]\n      -- ^ File paths and their content\n    , dcFilesToCopy :: [FilePath]\n      -- ^ Other file paths, to be copied directly\n    }\n\n------------------------------------\n-- * Build index page\n\nbuildIndex :: [(FilePath, Markup.Document)] -> Html.Html\nbuildIndex files =\n  let\n    previews =\n      map\n        ( \\(file, doc) ->\n          case doc of\n            Markup.Heading 1 heading : article ->\n              Html.h_ 3 (Html.link_ file (Html.txt_ heading))\n                <> foldMap convertStructure (take 2 article)\n                <> Html.p_ (Html.link_ file (Html.txt_ "..."))\n            _ ->\n              Html.h_ 3 (Html.link_ file (Html.txt_ file))\n        )\n        files\n  in\n    Html.html_\n      "Blog"\n      ( Html.h_ 1 (Html.link_ "index.html" (Html.txt_ "Blog"))\n        <> Html.h_ 2 (Html.txt_ "Posts")\n        <> mconcat previews\n      )\n\n------------------------------------\n-- * Conversion\n\n-- | Convert text files to Markup, build an index, and render as html.\ntxtsToRenderedHtml :: [(FilePath, String)] -> [(FilePath, String)]\ntxtsToRenderedHtml txtFiles =\n  let\n    txtOutputFiles = map toOutputMarkupFile txtFiles\n    index = ("index.html", buildIndex txtOutputFiles)\n  in\n    map (fmap Html.render) (index : map convertFile txtOutputFiles)\n\ntoOutputMarkupFile :: (FilePath, String) -> (FilePath, Markup.Document)\ntoOutputMarkupFile (file, content) =\n  (takeBaseName file <.> "html", Markup.parse content)\n\nconvertFile :: (FilePath, Markup.Document) -> (FilePath, Html.Html)\nconvertFile (file, doc) = (file, convert file doc)\n\n------------------------------------\n-- * Output to directory\n\n-- | Creates an output directory or terminates the program\ncreateOutputDirectoryOrExit :: FilePath -> IO ()\ncreateOutputDirectoryOrExit outputDir =\n  whenIO\n    (not <$> createOutputDirectory outputDir)\n    (hPutStrLn stderr "Cancelled." *> exitFailure)\n\n-- | Creates the output directory.\n--   Returns whether the directory was created or not.\ncreateOutputDirectory :: FilePath -> IO Bool\ncreateOutputDirectory dir = do\n  dirExists <- doesDirectoryExist dir\n  create <-\n    if dirExists\n      then do\n        override <- confirm "Output directory exists. Override?"\n        when override (removeDirectoryRecursive dir)\n        pure override\n      else\n        pure True\n  when create (createDirectory dir)\n  pure create\n\n-- | Copy files to a directory, recording errors to stderr.\ncopyFiles :: FilePath -> [FilePath] -> IO ()\ncopyFiles outputDir files = do\n  let\n    copyFromTo file = copyFile file (outputDir </> takeFileName file)\n  void $ applyIoOnList copyFromTo files >>= filterAndReportFailures\n\n-- | Write files to a directory, recording errors to stderr.\nwriteFiles :: FilePath -> [(FilePath, String)] -> IO ()\nwriteFiles outputDir files = do\n  let\n    writeFileContent (file, content) =\n      writeFile (outputDir </> file) content\n  void $ applyIoOnList writeFileContent files >>= filterAndReportFailures\n\n------------------------------------\n-- * IO work and handling errors\n\n-- | Try to apply an IO function on a list of values, document successes and failures\napplyIoOnList :: (a -> IO b) -> [a] -> IO [(a, Either String b)]\napplyIoOnList action inputs = do\n  for inputs $ \\input -> do\n    maybeResult <-\n      catch\n        (Right <$> action input)\n        ( \\(SomeException e) -> do\n          pure $ Left (displayException e)\n        )\n    pure (input, maybeResult)\n\n-- | Filter out unsuccessful operations on files and report errors to stderr.\nfilterAndReportFailures :: [(a, Either String b)] -> IO [(a, b)]\nfilterAndReportFailures =\n  foldMap $ \\(file, contentOrErr) ->\n    case contentOrErr of\n      Left err -> do\n        hPutStrLn stderr err\n        pure []\n      Right content ->\n        pure [(file, content)]\n\n------------------------------------\n-- * Utilities\n\nconfirm :: String -> IO Bool\nconfirm question = do\n  putStrLn (question <> " (y/n)")\n  answer <- getLine\n  case answer of\n    "y" -> pure True\n    "n" -> pure False\n    _ -> do\n      putStrLn "Invalid response. Use y or n."\n      confirm question\n\nwhenIO :: IO Bool -> IO () -> IO ()\nwhenIO cond action = do\n  result <- cond\n  if result\n    then action\n    else pure ()\n'))))}c.isMDXComponent=!0}}]);