"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[554],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,d=u["".concat(s,".").concat(m)]||u[m]||h[m]||i;return n?a.createElement(d,o(o({ref:t},c),{},{components:n})):a.createElement(d,o({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9343:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={},o="Parsing markup part 02 (Pattern matching)",l={unversionedId:"markup/parsing-02",id:"markup/parsing-02",title:"Parsing markup part 02 (Pattern matching)",description:"Maybe",source:"@site/docs/04-markup/04-parsing-02.md",sourceDirName:"04-markup",slug:"/markup/parsing-02",permalink:"/learn-haskell-blog-generator/markup/parsing-02",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/04-markup/04-parsing-02.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ud30c\uc2f1 \uacb0\uacfc \ubcf4\uc5ec\uc8fc\uae30 (\ud0c0\uc785 \ud074\ub798\uc2a4)",permalink:"/learn-haskell-blog-generator/markup/displaying-results"},next:{title:"Gluing things together",permalink:"/learn-haskell-blog-generator/glue/"}},s={},p=[{value:"Maybe",id:"maybe",level:2},{value:"Pattern Matching",id:"pattern-matching",level:2},{value:"Pattern matching on linked lists",id:"pattern-matching-on-linked-lists",level:3},{value:"Parsing with rich context",id:"parsing-with-rich-context",level:2},{value:"How do we know our parser works correctly?",id:"how-do-we-know-our-parser-works-correctly",level:3}],c={toc:p},u="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"parsing-markup-part-02-pattern-matching"},"Parsing markup part 02 (Pattern matching)"),(0,r.kt)("h2",{id:"maybe"},"Maybe"),(0,r.kt)("p",null,"Previously on partial functions, we mentioned that one way to avoid\nwriting partial functions is to encode the absence of a result using ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Maybe a\n  = Nothing\n  | Just a\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Maybe")," is a data type from the standard library (named ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base"},"base"),")\nfor adding an additional value to a type: the absence of a value.\nFor example, ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe Bool")," has three values,\ntwo with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Just")," constructor to represent regular boolean values\n(",(0,r.kt)("inlineCode",{parentName:"p"},"Just True")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Just False"),") and another value, ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing")," to represent\nthe absence of a boolean value."),(0,r.kt)("p",null,"We can use this to encode the result of ",(0,r.kt)("inlineCode",{parentName:"p"},"head"),", a function that promises to return\nthe first element of a list, without creating a partial function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"safeHead :: [a] -> Maybe a\n")),(0,r.kt)("p",null,"This way, when the list is empty, we can return ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing"),", and when it has at least\none element, we can return ",(0,r.kt)("inlineCode",{parentName:"p"},"Just <first element>"),". This function can be found in\nthe ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Maybe.html"},"Data.Maybe"),"\nmodule under the name\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Maybe.html#v:listToMaybe"},"listToMaybe"),"."),(0,r.kt)("p",null,"In order to ",(0,r.kt)("em",{parentName:"p"},"consume")," values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe <something>"),", and other types created with\n",(0,r.kt)("inlineCode",{parentName:"p"},"data"),", we can use pattern matching."),(0,r.kt)("h2",{id:"pattern-matching"},"Pattern Matching"),(0,r.kt)("p",null,"We've already seen pattern matching a few times.\nIt is an incredibly versatile feature of Haskell, we can use it to do two main things:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Deconstruct complex values"),(0,r.kt)("li",{parentName:"ol"},"Control flow")),(0,r.kt)("p",null,"As we've seen when discussing\n",(0,r.kt)("a",{parentName:"p",href:"/learn-haskell-blog-generator/html/safer-construction#using-newtypes"},"newtypes"),",\nwe can use ",(0,r.kt)("strong",{parentName:"p"},"case expressions")," and ",(0,r.kt)("strong",{parentName:"p"},"function definitions")," to deconstruct a ",(0,r.kt)("inlineCode",{parentName:"p"},"newtype"),".\nSame for ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," types as well:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- | A data type representing colors\ndata Color\n  = RGB Word8 Word8 Word8\n\ngetBluePart :: Color -> Word8\ngetBluePart color =\n  case color of\n    RGB _ _ blue -> blue\n")),(0,r.kt)("p",null,"In ",(0,r.kt)("inlineCode",{parentName:"p"},"getBluePart")," we deconstruct a composite value into its part and extract the third component\nrepresenting the blue value in a color represented by red, green and blue components (RGB)."),(0,r.kt)("p",null,"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"blue")," is the name we give to the third component so it will be bound\nto the right of the arrow that comes after the pattern. This is similar to\na function argument. Also note that ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," matches any value ",(0,r.kt)("em",{parentName:"p"},"without")," binding it to a name."),(0,r.kt)("p",null,"We can also try to match a value with more than one pattern:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Brightness\n  = Dark\n  | Bright\n\ndata EightColor\n  = Black\n  | Red\n  | Green\n  | Yellow\n  | Blue\n  | Magenta\n  | Cyan\n  | White\n\ndata AnsiColor\n  = AnsiColor Brightness EightColor\n\nansiColorToVGA :: AnsiColor -> Color\nansiColorToVGA ansicolor =\n  case ansicolor of\n    AnsiColor Dark Black ->\n      RGB 0 0 0\n    AnsiColor Bright Black ->\n      RGB 85 85 85\n    AnsiColor Dark Red ->\n      RGB 170 0 0\n    AnsiColor Bright Red ->\n      RGB 255 85 85\n    -- and so on\n")),(0,r.kt)("p",null,"It's important to notice a few things here:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Patterns can be nested, notice how we deconstructed ",(0,r.kt)("inlineCode",{parentName:"li"},"ansicolor")," on multiple levels"),(0,r.kt)("li",{parentName:"ol"},"We try to match patterns from the top down, it is possible for patterns to overlap with one another and the top one will win"),(0,r.kt)("li",{parentName:"ol"},"If the value we try to match does not match any of the patterns listed, an error will be thrown at runtime")),(0,r.kt)("p",null,"We can ask GHC to notify us when we accidentally write overlapping patterns,\nor when we haven't listed enough patterns to match all possible values,\nby passing the flag ",(0,r.kt)("inlineCode",{parentName:"p"},"-Wall")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"ghc")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"runghc"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"My recommendation is to always use ",(0,r.kt)("inlineCode",{parentName:"strong"},"-Wall")),"!"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"As an aside, while it is possible to use pattern matching in function definitions by defining a function\nmultiple times, ",(0,r.kt)("a",{parentName:"p",href:"https://twitter.com/_gilmi/status/1257225601079029760"},"I personally don't like that feature very much"),"\nand I would encourage you to avoid it,\nbut if you want to use it instead of case expressions, it is possible.")),(0,r.kt)("h3",{id:"pattern-matching-on-linked-lists"},"Pattern matching on linked lists"),(0,r.kt)("p",null,"Because linked lists have their own ",(0,r.kt)("a",{parentName:"p",href:"/learn-haskell-blog-generator/html/escaping-characters#linked-lists-briefly"},"special syntax"),",\nwe also have special syntax for their pattern match.\nWe can use the same special syntax for creating lists when we pattern match on lists,\nreplacing the ",(0,r.kt)("em",{parentName:"p"},"elements")," of the list with patterns. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"safeHead :: [a] -> Maybe a\nsafeHead list =\n  case list of\n    -- Empty list\n    [] -> Nothing\n\n    -- Cons cell pattern, will match any list with at least one element\n    x : _ -> Just x\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"exactlyTwo :: [a] -> Maybe (a, a)\nexactlyTwo list =\n  case list of\n    -- Will match a list with exactly two elements\n    [x, y] -> Just (x, y)\n\n    -- Will match any other pattern\n    _ -> Nothing\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- This will also work\nexactlyTwoVersion2 :: [a] -> Maybe (a, a)\nexactlyTwoVersion2 list =\n  case list of\n    -- Will match a list with exactly two elements\n    x : y : [] -> Just (x, y)\n\n    -- Will match any other pattern\n    _ -> Nothing\n")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Exercises:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Create a function ",(0,r.kt)("inlineCode",{parentName:"li"},"isBright :: AnsiColor -> Bool")," that checks whether a color is bright"),(0,r.kt)("li",{parentName:"ol"},"Use ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit"},"this table")," to write ",(0,r.kt)("inlineCode",{parentName:"li"},"ansiToUbuntu")),(0,r.kt)("li",{parentName:"ol"},"Create a function ",(0,r.kt)("inlineCode",{parentName:"li"},"isEmpty :: [a] -> Bool")," that uses ",(0,r.kt)("inlineCode",{parentName:"li"},"listToMaybe")," to check whether a list is empty"),(0,r.kt)("li",{parentName:"ol"},"Create a function ",(0,r.kt)("inlineCode",{parentName:"li"},"isEmpty :: [a] -> Bool")," that ",(0,r.kt)("em",{parentName:"li"},"doesn't")," use ",(0,r.kt)("inlineCode",{parentName:"li"},"listToMaybe")," to check whether a list is empty")),(0,r.kt)("p",null,"Solutions:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution for (1)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"isBright :: AnsiColor -> Bool\nisBright ansiColor =\n  case ansiColor of\n    AnsiColor Bright _ -> True\n    AnsiColor Dark _ -> False\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution for (2)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ansiToUbuntu :: AnsiColor -> Color\nansiToUbuntu ansiColor =\n  case ansiColor of\n    AnsiColor brightness color ->\n      case brightness of\n        Dark ->\n          case color of\n            Black -> RGB 0 0 0\n            Red -> RGB 194 54 33\n            Green -> RGB 37 188 36\n            Yellow -> RGB 173 173 39\n            Blue -> RGB 73 46 225\n            Magenta -> RGB 211 56 211\n            Cyan -> RGB 51 187 200\n            White -> RGB 203 204 205\n\n        Bright ->\n          case color of\n            Black -> RGB 129 131 131\n            Red -> RGB 252 57 31\n            Green -> RGB 49 231 34\n            Yellow -> RGB 234 236 35\n            Blue -> RGB 88 51 255\n            Magenta -> RGB 249 53 248\n            Cyan -> RGB 20 240 240\n            White -> RGB 233 235 235\n")),(0,r.kt)("p",null,"Since pattern matching goes arbitrarily deep as we saw before, we could instead\npattern match all the way through in one case expression:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ansiToUbuntu :: AnsiColor -> Color\nansiToUbuntu ansiColor =\n  case ansiColor of\n    AnsiColor Dark Black -> RGB 0 0 0\n    AnsiColor Dark Red -> RGB 194 54 33\n    AnsiColor Dark Green -> RGB 37 188 36\n    AnsiColor Dark Yellow -> RGB 173 173 39\n    AnsiColor Dark Blue -> RGB 73 46 225\n    AnsiColor Dark Magenta -> RGB 211 56 211\n    AnsiColor Dark Cyan -> RGB 51 187 200\n    AnsiColor Dark White -> RGB 203 204 205\n    AnsiColor Bright Black -> RGB 129 131 131\n    AnsiColor Bright Red -> RGB 252 57 31\n    AnsiColor Bright Green -> RGB 49 231 34\n    AnsiColor Bright Yellow -> RGB 234 236 35\n    AnsiColor Bright Blue -> RGB 88 51 255\n    AnsiColor Bright Magenta -> RGB 249 53 248\n    AnsiColor Bright Cyan -> RGB 20 240 240\n    AnsiColor Bright White -> RGB 233 235 235\n")),(0,r.kt)("p",null,"But this is a bit too much repetition of ",(0,r.kt)("inlineCode",{parentName:"p"},"AnsiColor"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Dark")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Bright"),"\nto my taste in this case.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution for (3)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"isEmpty :: [a] -> Bool\nisEmpty list =\n  case listToMaybe list of\n    Nothing -> True\n    Just _ -> False\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution for (4)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"isEmpty :: [a] -> Bool\nisEmpty list =\n  case list of\n    [] -> True\n    _ : _ -> False\n"))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"parsing-with-rich-context"},"Parsing with rich context"),(0,r.kt)("p",null,"Previously we wrote a parser that separates documents into different paragraphs.\nWith new features under our belt we can now remember the exact context we are in\n(whether it is a text paragraph, a list, or a code block) and act accordingly!"),(0,r.kt)("p",null,"Let's look again at the parsing code we wrote previously:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'parse :: String -> Document\nparse = parseLines [] . lines\n\nparseLines :: [String] -> [String] -> Document\nparseLines currentParagraph txts =\n  let\n    paragraph = Paragraph (unlines (reverse currentParagraph))\n  in\n    case txts of\n      [] -> [paragraph]\n      currentLine : rest ->\n        if trim currentLine == ""\n          then\n            paragraph : parseLines [] rest\n          else\n            parseLines (currentLine : currentParagraph) rest\n\ntrim :: String -> String\ntrim = unwords . words\n')),(0,r.kt)("p",null,"Previously our context, ",(0,r.kt)("inlineCode",{parentName:"p"},"currentParagraph"),", was used to group adjacent lines in an accumulative list."),(0,r.kt)("p",null,"Next, instead of using a ",(0,r.kt)("inlineCode",{parentName:"p"},"[String]")," type to denote adjacent lines, we can instead use a ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure")," to denote the context."),(0,r.kt)("p",null,"One issue we might have though with representing context with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure")," type,\nis that when we start parsing we don't have any context.\nBut we have learned of a way to represent the absence of a value with ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe"),"! So our new context type can be ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe Structure")," instead."),(0,r.kt)("p",null,"Let's rewrite our code above with our new context type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'parse :: String -> Document\nparse = parseLines Nothing . lines -- (1)\n\nparseLines :: Maybe Structure -> [String] -> Document\nparseLines context txts =\n  case txts of\n    [] -> maybeToList context -- (2)\n    -- Paragraph case\n    currentLine : rest ->\n      let\n        line = trim currentLine\n      in\n        if line == ""\n          then\n            maybe id (:) context (parseLines Nothing rest) -- (3)\n          else\n            case context of\n              Just (Paragraph paragraph) ->\n                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest -- (4)\n              _ ->\n                maybe id (:) context (parseLines (Just (Paragraph line)) rest)\n\ntrim :: String -> String\ntrim = unwords . words\n')),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"We can now pass ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing")," when we don't have a context")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Unsure what ",(0,r.kt)("inlineCode",{parentName:"p"},"maybeToList")," does? ",(0,r.kt)("a",{parentName:"p",href:"https://hoogle.haskell.org"},"Hoogle")," it!")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"We can split this line into two important parts:"),(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"maybe id (:) context")," - prepending the context to the rest of the document"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"parseLines Nothing rest")," - parsing the rest of the document")),(0,r.kt)("p",{parentName:"li"},"Let's focus on the first part.\nWe want to prepend ",(0,r.kt)("inlineCode",{parentName:"p"},"context")," to the rest of the document, but we can't write\n",(0,r.kt)("inlineCode",{parentName:"p"},"context : parseLines Nothing rest")," because ",(0,r.kt)("inlineCode",{parentName:"p"},"context")," has the type ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe Structure"),"\nand not ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure"),", meaning that we ",(0,r.kt)("em",{parentName:"p"},"might")," have a ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure")," but maybe not.\nIf we do have a ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure")," to prepend, we wish to prepend it. If not, we want to return\nthe result of ",(0,r.kt)("inlineCode",{parentName:"p"},"parseLines Nothing rest")," as is. Try writing this using pattern matching!"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"case context of\n  Nothing -> parseLines Nothing rest\n  Just structure -> structure : parseLines Nothing rest\n"))),(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:maybe"},"maybe"),"\nfunction let's us do the same thing in a more compact way. It is a function\nthat works similarly to pattern matching on a ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe"),":\nthe third argument to ",(0,r.kt)("inlineCode",{parentName:"p"},"maybe")," is the value on which we pattern match,\nthe second argument is a function to apply to the value found in a ",(0,r.kt)("inlineCode",{parentName:"p"},"Just")," case,\nand the first argument is the value to return in case the value\nwe pattern match on is ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing"),". A more faithful translation of\n",(0,r.kt)("inlineCode",{parentName:"p"},"maybe id (:) context (parseLines Nothing rest)"),"\nto pattern matching would look like this:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"( case context of\n    Nothing -> id\n    Just structure -> (:) structure\n) (parseLines Nothing rest)\n")),(0,r.kt)("p",{parentName:"li"},"Note how the result of this case expression is a function of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Document -> Document"),",\nhow we partially apply ",(0,r.kt)("inlineCode",{parentName:"p"},"(:)")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"structure")," to create a function that prepends ",(0,r.kt)("inlineCode",{parentName:"p"},"structure"),",\nand how we apply ",(0,r.kt)("inlineCode",{parentName:"p"},"parseLines Nothing rest")," to the case expression.")),(0,r.kt)("p",{parentName:"li"},"This way of encoding pattern matching using functions is fairly common."),(0,r.kt)("p",{parentName:"li"},"Check out the types of ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"(:)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"maybe id (:)")," in GHCi!")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Hey! Didn't we say that appending ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"s/lists is slow (which is what ",(0,r.kt)("inlineCode",{parentName:"p"},"unwords")," does)? Yes, it is.\nBecause in our ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure")," data type, a paragraph is defined as ",(0,r.kt)("inlineCode",{parentName:"p"},"Paragraph String")," and not ",(0,r.kt)("inlineCode",{parentName:"p"},"Paragraph [String]"),",\nwe can't use our trick of building a list of lines and then reverse it in the end."),(0,r.kt)("p",{parentName:"li"},"So what do we do?\nThere are many ways to handle that, one simple way is to create a different type with the right shape:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Context\n  = CtxHeading Natural String\n  | CtxParagraph [String]\n  | CtxUnorderedList [String]\n  | CtxOrderedList [String]\n  | CtxCodeBlock [String]\n")),(0,r.kt)("p",{parentName:"li"},"Since creating new types in Haskell is cheap, this is a very viable solution."),(0,r.kt)("p",{parentName:"li"},"In this case I'm going with the approach of not worrying about it too much,\nbecause it's a very local piece of code that can easily be fixed later if needed."))),(0,r.kt)("p",null,"Let's cover more parsing cases, we want to handle headings and lists as well.\nWe can do that by examining the first characters of a line:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"parse :: String -> Document\nparse = parseLines Nothing . lines\n\nparseLines :: Maybe Structure -> [String] -> Document\nparseLines context txts =\n  case txts of\n    -- done case\n    [] -> maybeToList context\n\n    -- Heading 1 case\n    ('*' : ' ' : line) : rest ->\n      maybe id (:) context (Heading 1 (trim line) : parseLines Nothing rest)\n\n    -- Unordered list case\n    ('-' : ' ' : line) : rest ->\n      case context of\n        Just (UnorderedList list) ->\n          parseLines (Just (UnorderedList (list <> [trim line]))) rest\n\n        _ ->\n          maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest)\n\n    -- Paragraph case\n    currentLine : rest ->\n      let\n        line = trim currentLine\n      in\n        if line == \"\"\n          then\n            maybe id (:) context (parseLines Nothing rest)\n          else\n            case context of\n              Just (Paragraph paragraph) ->\n                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest\n              _ ->\n                maybe id (:) context (parseLines (Just (Paragraph line)) rest)\n\ntrim :: String -> String\ntrim = unwords . words\n")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Exercise: Add the ",(0,r.kt)("inlineCode",{parentName:"p"},"CodeBlock")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"OrderedList")," cases."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Final module"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- Markup.hs\n\nmodule Markup\n  ( Document\n  , Structure(..)\n  , parse\n  )\nwhere\n\nimport Numeric.Natural\nimport Data.Maybe (maybeToList)\n\ntype Document\n  = [Structure]\n\ndata Structure\n  = Heading Natural String\n  | Paragraph String\n  | UnorderedList [String]\n  | OrderedList [String]\n  | CodeBlock [String]\n  deriving (Eq, Show)    -- (1)\n\n\nparse :: String -> Document\nparse = parseLines Nothing . lines\n\nparseLines :: Maybe Structure -> [String] -> Document\nparseLines context txts =\n  case txts of\n    -- done case\n    [] -> maybeToList context\n\n    -- Heading 1 case\n    ('*' : ' ' : line) : rest ->\n      maybe id (:) context (Heading 1 (trim line) : parseLines Nothing rest)\n\n    -- Unordered list case\n    ('-' : ' ' : line) : rest ->\n      case context of\n        Just (UnorderedList list) ->\n          parseLines (Just (UnorderedList (list <> [trim line]))) rest\n\n        _ ->\n          maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest)\n\n    -- Ordered list case\n    ('#' : ' ' : line) : rest ->\n      case context of\n        Just (OrderedList list) ->\n          parseLines (Just (OrderedList (list <> [trim line]))) rest\n\n        _ ->\n          maybe id (:) context (parseLines (Just (OrderedList [trim line])) rest)\n\n    -- Code block case\n    ('>' : ' ' : line) : rest ->\n      case context of\n        Just (CodeBlock code) ->\n          parseLines (Just (CodeBlock (code <> [line]))) rest\n\n        _ ->\n          maybe id (:) context (parseLines (Just (CodeBlock [line])) rest)\n\n    -- Paragraph case\n    currentLine : rest ->\n      let\n        line = trim currentLine\n      in\n        if line == \"\"\n          then\n            maybe id (:) context (parseLines Nothing rest)\n          else\n            case context of\n              Just (Paragraph paragraph) ->\n                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest\n              _ ->\n                maybe id (:) context (parseLines (Just (Paragraph line)) rest)\n\ntrim :: String -> String\ntrim = unwords . words\n"))),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"how-do-we-know-our-parser-works-correctly"},"How do we know our parser works correctly?"),(0,r.kt)("p",null,"In an earlier chapter, we parsed a few examples of our markup language ",(0,r.kt)("a",{parentName:"p",href:"/learn-haskell-blog-generator/markup/data-type#exercises"},"by hand"),".\nNow, we can try to test our parser by comparing our solutions to our parser.\nBy deriving ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," for our ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure"),' data type\n(marked with (1) in "final module" above),\nwe can compare solutions with the ',(0,r.kt)("inlineCode",{parentName:"p"},"==")," (equals) operator."),(0,r.kt)("p",null,"Try it in GHCi! You can read a text file in GHCi using the following syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> txt <- readFile "/tmp/sample.txt"\n')),(0,r.kt)("p",null,"And then compare with the hand written example values from the solutions\n(after adding them to the module and loading them in GHCi):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> parse txt == example4\n")),(0,r.kt)("p",null,"In a later chapter, we'll write automated tests for our parser using a testing framework.\nBut before that, I'd like to glue things together\nso we'll be able to:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Read markup text from a file"),(0,r.kt)("li",{parentName:"ol"},"Parse the text"),(0,r.kt)("li",{parentName:"ol"},"Convert the result to our HTML EDSL"),(0,r.kt)("li",{parentName:"ol"},"Generate HTML code")),(0,r.kt)("p",null,"And also discuss how to work with IO in Haskell while we're at it."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"You can view the git commit of\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/commit/9f951a05d4f78cf59190ee4f3cd8de85e1c33bd1"},"the changes we've made"),"\nand the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/tree/9f951a05d4f78cf59190ee4f3cd8de85e1c33bd1"},"code up until now"),".")))}h.isMDXComponent=!0}}]);