"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[163],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,d=u["".concat(s,".").concat(m)]||u[m]||h[m]||l;return n?a.createElement(d,i(i({ref:t},c),{},{components:n})):a.createElement(d,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:r,i[1]=o;for(var p=2;p<l;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3929:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const l={},i="Displaying the parsing results (type classes)",o={unversionedId:"markup/displaying-results",id:"markup/displaying-results",title:"Displaying the parsing results (type classes)",description:"We want to be able to print a textual representation of values",source:"@site/docs/04-markup/03-displaying-results.md",sourceDirName:"04-markup",slug:"/markup/displaying-results",permalink:"/learn-haskell-blog-generator/markup/displaying-results",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/04-markup/03-displaying-results.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ub9c8\ud06c\uc5c5 \ud30c\uc2f1\ud558\uae30 01 (\uc7ac\uadc0)",permalink:"/learn-haskell-blog-generator/markup/parsing-01"},next:{title:"Parsing markup part 02 (Pattern matching)",permalink:"/learn-haskell-blog-generator/markup/parsing-02"}},s={},p=[{value:"Deriving instances",id:"deriving-instances",level:2},{value:"Laws",id:"laws",level:2}],c={toc:p},u="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"displaying-the-parsing-results-type-classes"},"Displaying the parsing results (type classes)"),(0,r.kt)("p",null,"We want to be able to print a textual representation of values\nof our ",(0,r.kt)("inlineCode",{parentName:"p"},"Document")," type. There are a few ways to do that:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Write our own function of type ",(0,r.kt)("inlineCode",{parentName:"li"},"Document -> String")," which we could then print, or"),(0,r.kt)("li",{parentName:"ol"},"Have Haskell write one for us")),(0,r.kt)("p",null,"Haskell provides us with a mechanism that can automatically generate the implementation of a\n",(0,r.kt)("em",{parentName:"p"},"type class")," function called ",(0,r.kt)("inlineCode",{parentName:"p"},"show"),", that will convert our type to ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,r.kt)("p",null,"The type of the function ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"show :: Show a => a -> String\n")),(0,r.kt)("p",null,"This is something new we haven't seen before. Between ",(0,r.kt)("inlineCode",{parentName:"p"},"::")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"=>"),"\nyou see what is called a ",(0,r.kt)("strong",{parentName:"p"},"type class constraint")," on the type ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),". What\nwe say in this signature, is that the function ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," can work on any\ntype that is a member of the type class ",(0,r.kt)("inlineCode",{parentName:"p"},"Show"),"."),(0,r.kt)("p",null,"Type classes is a feature in Haskell that allows us to declare a common\ninterface for different types. In our case, Haskell's standard library\ndefines the type class ",(0,r.kt)("inlineCode",{parentName:"p"},"Show")," in the following way (this is a simplified\nversion but good enough for our purposes):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"class Show a where\n  show :: a -> String\n")),(0,r.kt)("p",null,"A type class declaration describes a common interface for Haskell types.\n",(0,r.kt)("inlineCode",{parentName:"p"},"show")," is an overloaded function that will work for any type that is an ",(0,r.kt)("em",{parentName:"p"},"instance"),"\nof the type class ",(0,r.kt)("inlineCode",{parentName:"p"},"Show"),".\nWe can define an instance of a type class manually like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'instance Show Bool where\n  show x =\n    case x of\n      True -> "True"\n      False -> "False"\n')),(0,r.kt)("p",null,"Defining an instance means providing an implementation for the interface of a specific type.\nWhen we call the function ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," on a data type, the compiler will search the type's ",(0,r.kt)("inlineCode",{parentName:"p"},"Show")," instance,\nand use the implementation provided in the instance declaration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> show True\n"True"\nghci> show 187\n"187"\nghci> show "Hello"\n"\\"Hello\\""\n')),(0,r.kt)("p",null,"As can be seen above, the ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," function converts a value to its textual representation.\nThat is why ",(0,r.kt)("inlineCode",{parentName:"p"},'"Hello"')," includes the quotes as well. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Show")," type class is usually\nused for debugging purposes."),(0,r.kt)("h2",{id:"deriving-instances"},"Deriving instances"),(0,r.kt)("p",null,"It is also possible to automatically generate implementations of a few selected\ntype classes. Fortunately, ",(0,r.kt)("inlineCode",{parentName:"p"},"Show")," is one of them."),(0,r.kt)("p",null,"If all the types in the definition of our data type already implement\nan instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"Show"),", we can ",(0,r.kt)("em",{parentName:"p"},"automatically derive")," it by adding ",(0,r.kt)("inlineCode",{parentName:"p"},"deriving Show")," at the\nend of the data definition."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Structure\n  = Heading Natural String\n  | Paragraph String\n  | UnorderedList [String]\n  | OrderedList [String]\n  | CodeBlock [String]\n  deriving Show\n")),(0,r.kt)("p",null,"Now we can use the function ",(0,r.kt)("inlineCode",{parentName:"p"},"show :: Show a => a -> String")," for any\ntype that implements an instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Show")," type class. For example, with ",(0,r.kt)("inlineCode",{parentName:"p"},"print"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"print :: Show a => a -> IO ()\nprint = putStrLn . show\n")),(0,r.kt)("p",null,"We can first convert our type to ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," and then write it to the\nstandard output."),(0,r.kt)("p",null,"And because lists also implement ",(0,r.kt)("inlineCode",{parentName:"p"},"Show")," for any element type that has\na ",(0,r.kt)("inlineCode",{parentName:"p"},"Show")," instance, we can now print ",(0,r.kt)("inlineCode",{parentName:"p"},"Document"),"s, because they are just\naliases for ",(0,r.kt)("inlineCode",{parentName:"p"},"[Structure]"),". Try it!"),(0,r.kt)("p",null,"There are many type classes Haskellers use everyday. A couple more are\n",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," for equality and ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord")," for ordering. These are also special type classes\nthat can be derived automatically."),(0,r.kt)("h2",{id:"laws"},"Laws"),(0,r.kt)("p",null,'Type classes often come with "rules" or "laws" that instances should satisfy,\nthe purpose of these laws is to provide ',(0,r.kt)("em",{parentName:"p"},"predictable behaviour")," across\ninstances, so that when we run into a new instance we can be confident\nthat it will behave in an expected way, and we can write code\nthat works generically for all instances of a type class while expecting\nthem to adhere to these rules."),(0,r.kt)("p",null,"As an example, let's look at the ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup")," type class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"class Semigroup a where\n  (<>) :: a -> a -> a\n")),(0,r.kt)("p",null,"This type class provides a common interface for types with an operation ",(0,r.kt)("inlineCode",{parentName:"p"},"<>"),"\nthat can combine two values into one in some way."),(0,r.kt)("p",null,"This type class also mentions that this ",(0,r.kt)("inlineCode",{parentName:"p"},"<>")," operation should be associative,\nmeaning that these two sides should evaluate to the same result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"x <> (y <> z) = (x <> y) <> z\n")),(0,r.kt)("p",null,"An example of a lawful instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup")," is lists with the append operation (",(0,r.kt)("inlineCode",{parentName:"p"},"++"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Semigroup [a] where\n  (<>) = (++)\n")),(0,r.kt)("p",null,'Unfortunately the Haskell type system cannot "prove" that instances\nsatisfy these laws, but as a community we often shun unlawful instances.'),(0,r.kt)("p",null,"Many data types (together with their respective operations) can\nform a ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup"),", and instances\ndon't even have to look similar or have a common analogy/metaphor\n(and this is true for many other type classes as well)."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Type classes are often just ",(0,r.kt)("em",{parentName:"strong"},"interfaces")," with ",(0,r.kt)("em",{parentName:"strong"},"laws"))," (or expected behaviours if you will).\nApproaching them with this mindset can be very liberating!"),(0,r.kt)("p",null,"To put it differently, ",(0,r.kt)("strong",{parentName:"p"},"type classes can be used to create abstractions")," -\ninterfaces with laws/expected behaviours where we don't actually care about the\nconcrete details of the underlying type, just that it ",(0,r.kt)("em",{parentName:"p"},"implements a certain\nAPI and behaves in a certain way"),"."),(0,r.kt)("p",null,"Regarding ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup"),", we have ",(0,r.kt)("a",{parentName:"p",href:"/learn-haskell-blog-generator/html/safer-construction#appending-htmlstructure"},"previously"),"\ncreated a function that looks like ",(0,r.kt)("inlineCode",{parentName:"p"},"<>")," for our ",(0,r.kt)("inlineCode",{parentName:"p"},"Html")," EDSL!\nWe can add a ",(0,r.kt)("inlineCode",{parentName:"p"},"Semigroup")," instance for our ",(0,r.kt)("inlineCode",{parentName:"p"},"Structure")," data type\nand have a nicer API!"),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Exercise: Please do this and remove the ",(0,r.kt)("inlineCode",{parentName:"p"},"append_")," function from the API."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("p",null,"Replace this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"append_ :: Structure -> Structure -> Structure\nappend_ c1 c2 =\n  Structure (getStructureString c1 <> getStructureString c2)\n")),(0,r.kt)("p",null,"With this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Semigroup Structure where\n  (<>) c1 c2 =\n    Structure (getStructureString c1 <> getStructureString c2)\n")),(0,r.kt)("p",null,"And remove the export of ",(0,r.kt)("inlineCode",{parentName:"p"},"append_")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"Html.hs"),". You won't need to further export anything\nas type class instances are exported automatically."),(0,r.kt)("p",null,"You will also need to replace the usage of ",(0,r.kt)("inlineCode",{parentName:"p"},"append_")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"<>")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"hello.hs"),".")),(0,r.kt)("hr",null))}h.isMDXComponent=!0}}]);