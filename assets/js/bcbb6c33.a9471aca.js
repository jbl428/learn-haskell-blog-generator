"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[114],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=s(n),h=r,u=m["".concat(p,".").concat(h)]||m[h]||d[h]||i;return n?a.createElement(u,o(o({ref:t},c),{},{components:n})):a.createElement(u,o({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7241:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const i={},o="Either with IO?",l={unversionedId:"errors_and_files/except",id:"errors_and_files/except",title:"Either with IO?",description:"When we create IO actions that may require I/O we risk running into all kinds of errors.",source:"@site/docs/06-errors_and_files/02-except.md",sourceDirName:"06-errors_and_files",slug:"/errors_and_files/except",permalink:"/learn-haskell-blog-generator/errors_and_files/except",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/06-errors_and_files/02-except.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Either\ub97c \ud65c\uc6a9\ud55c \uc5d0\ub7ec \ucc98\ub9ac",permalink:"/learn-haskell-blog-generator/errors_and_files/either"},next:{title:"Exceptions",permalink:"/learn-haskell-blog-generator/errors_and_files/exceptions"}},p={},s=[{value:"Composing IO + Either using ExceptT",id:"composing-io--either-using-exceptt",level:2}],c={toc:s},m="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"either-with-io"},"Either with IO?"),(0,r.kt)("p",null,"When we create ",(0,r.kt)("inlineCode",{parentName:"p"},"IO")," actions that may require I/O we risk running into all kinds of errors.\nFor example, when we use ",(0,r.kt)("inlineCode",{parentName:"p"},"writeFile"),", we could run out of disk space in the middle of writing,\nor the file might be write protected. While these scenarios aren't super common, they are definitely\npossible."),(0,r.kt)("p",null,"We could've potentially encoded Haskell functions like ",(0,r.kt)("inlineCode",{parentName:"p"},"readFile")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"writeFile")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"IO")," operations\nthat return ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),", for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"readFile :: FilePath -> IO (Either ReadFileError String)\nwriteFile :: FilePath -> String -> IO (Either WriteFileError ())\n")),(0,r.kt)("p",null,"However there are a couple of issues here, the first is that composing ",(0,r.kt)("inlineCode",{parentName:"p"},"IO")," actions\nbecomes more difficult. Previously we could write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'readFile "input.txt" >>= writeFile "output.html"\n')),(0,r.kt)("p",null,"But now the types no longer match - ",(0,r.kt)("inlineCode",{parentName:"p"},"readFile")," will return an ",(0,r.kt)("inlineCode",{parentName:"p"},"Either ReadFileError String")," when executed,\nbut ",(0,r.kt)("inlineCode",{parentName:"p"},"writeFile")," wants to take a ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," as input. We are forced to handle the error\nbefore calling ",(0,r.kt)("inlineCode",{parentName:"p"},"writeFile"),"."),(0,r.kt)("h2",{id:"composing-io--either-using-exceptt"},"Composing IO + Either using ExceptT"),(0,r.kt)("p",null,"One way to handle this is by using ",(0,r.kt)("strong",{parentName:"p"},"monad transformers"),". Monad transformers provide a way\nto stack monad capabilities on top of one another. They are called transformers because\n",(0,r.kt)("strong",{parentName:"p"},"they take a type that has an instance of monad as input, and return a new type that\nimplements the monad interface, stacking a new capability on top of it"),"."),(0,r.kt)("p",null,"For example, if we want to compose values of a type that is equivalent to ",(0,r.kt)("inlineCode",{parentName:"p"},"IO (Either Error a)"),",\nusing the monadic interface (the function ",(0,r.kt)("inlineCode",{parentName:"p"},">>="),"), we can use a monad transformer\ncalled ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Except.html#g:2"},(0,r.kt)("inlineCode",{parentName:"a"},"ExceptT")),"\nand stack it over ",(0,r.kt)("inlineCode",{parentName:"p"},"IO"),".\nLet's see how ",(0,r.kt)("inlineCode",{parentName:"p"},"ExceptT")," is defined:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"newtype ExceptT e m a = ExceptT (m (Either e a))\n")),(0,r.kt)("p",null,"Remember, a ",(0,r.kt)("inlineCode",{parentName:"p"},"newtype")," is a new name for an existing type. And if we substitute\n",(0,r.kt)("inlineCode",{parentName:"p"},"e")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"Error")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"IO")," we get exactly ",(0,r.kt)("inlineCode",{parentName:"p"},"IO (Either Error a)")," as we wanted.\nAnd we can convert an ",(0,r.kt)("inlineCode",{parentName:"p"},"ExceptT Error IO a")," into ",(0,r.kt)("inlineCode",{parentName:"p"},"IO (Either Error a)")," using\nthe function ",(0,r.kt)("inlineCode",{parentName:"p"},"runExceptT"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"runExceptT :: ExceptT e m a -> m (Either e a)\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ExceptT")," implements the monadic interface in a way that combines the capabilities of\n",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),", and whatever ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," it takes. Because ",(0,r.kt)("inlineCode",{parentName:"p"},"ExceptT e m")," has a ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad")," instance,\na specialized version of ",(0,r.kt)("inlineCode",{parentName:"p"},">>=")," would look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- Generalized version\n(>>=) :: Monad m => m a -> (a -> m b) -> m b\n\n-- Specialized version, replace the `m` above with `ExceptT e m`.\n(>>=) :: Monad m => ExceptT e m a -> (a -> ExceptT e m b) -> ExceptT e m b\n")),(0,r.kt)("p",null,"Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," in the specialized version still needs to be an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad"),"."),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Unsure how this works? Try to implement ",(0,r.kt)("inlineCode",{parentName:"p"},">>=")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"IO (Either Error a)"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"bindExceptT :: IO (Either Error a) -> (a -> IO (Either Error b)) -> IO (Either Error b)\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Solution"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"bindExceptT :: IO (Either Error a) -> (a -> IO (Either Error b)) -> IO (Either Error b)\nbindExceptT mx f = do\n  x <- mx -- `x` has the type `Either Error a`\n  case x of\n    Left err -> pure (Left err)\n    Right y -> f y\n")),(0,r.kt)("p",null,"Note that we didn't actually use the implementation details of ",(0,r.kt)("inlineCode",{parentName:"p"},"Error")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"IO"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"Error")," isn't mentioned at all, and for ",(0,r.kt)("inlineCode",{parentName:"p"},"IO")," we only used the monadic interface with\nthe do notation. We could write the same function with a more generalized type signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"bindExceptT :: Monad m => m (Either e a) -> (a -> m (Either e b)) -> m (Either e b)\nbindExceptT mx f = do\n  x <- mx -- `x` has the type `Either e a`\n  case x of\n    Left err -> pure (Left err)\n    Right y -> f y\n")),(0,r.kt)("p",null,"And because ",(0,r.kt)("inlineCode",{parentName:"p"},"newtype ExceptT e m a = ExceptT (m (Either e a))")," we can just\npack and unpack that ",(0,r.kt)("inlineCode",{parentName:"p"},"ExceptT")," constructor and get:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"bindExceptT :: Monad m => ExceptT e m a -> (a -> ExceptT e m b) -> ExceptT e m b\nbindExceptT mx f = ExceptT $ do\n  -- `runExceptT mx` has the type `m (Either e a)`\n  -- `x` has the type `Either e a`\n  x <- runExceptT mx\n  case x of\n    Left err -> pure (Left err)\n    Right y -> runExceptT (f y)\n"))),(0,r.kt)("hr",null),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that when stacking monad transformers, the order in which we stack them matters.\nWith ",(0,r.kt)("inlineCode",{parentName:"p"},"ExceptT Error IO a"),", we have an ",(0,r.kt)("inlineCode",{parentName:"p"},"IO")," operation that when run will return ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),"\nan error or a value.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ExceptT")," can enjoy both worlds - we can return error values using the function ",(0,r.kt)("inlineCode",{parentName:"p"},"throwError"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"throwError :: e -> ExceptT e m a\n")),(0,r.kt)("p",null,'and we can "lift" functions that return a value of the underlying monadic type ',(0,r.kt)("inlineCode",{parentName:"p"},"m")," to return\na value of ",(0,r.kt)("inlineCode",{parentName:"p"},"ExceptT e m a")," instead:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"lift :: m a -> ExceptT e m a\n")),(0,r.kt)("p",null,"for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"getLine :: IO String\n\nlift getLine :: ExceptT e IO String\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Actually, ",(0,r.kt)("inlineCode",{parentName:"p"},"lift")," is also a type class function from ",(0,r.kt)("inlineCode",{parentName:"p"},"MonadTrans"),", the type class\nof monad transformers. So technically ",(0,r.kt)("inlineCode",{parentName:"p"},"lift getLine :: MonadTrans t => t IO String"),",\nbut we are specializing for concreteness.")),(0,r.kt)("p",null,"Now, if we had:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"readFile :: FilePath -> ExceptT IOError IO String\n\nwriteFile :: FilePath -> String -> ExceptT IOError IO ()\n")),(0,r.kt)("p",null,"We could compose them again without issue:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'readFile "input.txt" >>= writeFile "ouptut.html"\n')),(0,r.kt)("p",null,"But remember - the error type ",(0,r.kt)("inlineCode",{parentName:"p"},"e")," (in both the case ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Except"),")\nmust be the same between composed functions! This means that the type representing\nerrors for both ",(0,r.kt)("inlineCode",{parentName:"p"},"readFile")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"writeFile")," must be the same - that would also\nforce anyone using these functions to handle these errors - should a user who\ncalled ",(0,r.kt)("inlineCode",{parentName:"p"},"writeFile"),' be required to handle a "file not found" error? Should a user\nwho called ',(0,r.kt)("inlineCode",{parentName:"p"},"readFile"),' be required to handle an "out of disk space" error?\nThere are many many more possible IO errors! "network unreachable", "out of memory",\n"cancelled thread", we cannot require a user to handle all these errors, or\neven cover them all in a data type.'),(0,r.kt)("p",null,"So what do we do?"),(0,r.kt)("p",null,"We give up on this approach ",(0,r.kt)("strong",{parentName:"p"},"for IO code"),", and use a different one: Exceptions,\nas we'll see in the next chapter."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note - when we stack ",(0,r.kt)("inlineCode",{parentName:"p"},"ExceptT")," on top of a different type called\n",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Functor-Identity.html"},(0,r.kt)("inlineCode",{parentName:"a"},"Identity")),"\nthat also implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad")," interface, we get a type that is exactly like ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),"\ncalled ",(0,r.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/transformers-0.6.0.2/docs/Control-Monad-Trans-Except.html#t:Except"},(0,r.kt)("inlineCode",{parentName:"a"},"Except")),"\n(without the ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," at the end). You might sometimes want to use ",(0,r.kt)("inlineCode",{parentName:"p"},"Except")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),"\nbecause it has a more appropriate name and better API for error handling than ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),".")))}d.isMDXComponent=!0}}]);