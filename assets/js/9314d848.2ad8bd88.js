"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[924],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=p(a),d=r,h=c["".concat(s,".").concat(d)]||c[d]||m[d]||o;return a?n.createElement(h,l(l({ref:t},u),{},{components:a})):n.createElement(h,l({ref:t},u))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,l=new Array(o);l[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:r,l[1]=i;for(var p=2;p<o;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},9105:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const o={},l="Recap",i={unversionedId:"recap",id:"recap",title:"Recap",description:"In this book we've implemented a very simple static blog generator while learning Haskell as we go.",source:"@site/docs/10-recap.md",sourceDirName:".",slug:"/recap",permalink:"/learn-haskell-blog-generator/docs/recap",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/10-recap.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Generating documentation",permalink:"/learn-haskell-blog-generator/docs/documentation"},next:{title:"Where to go next",permalink:"/learn-haskell-blog-generator/docs/next"}},s={},p=[{value:"Thank you!",id:"thank-you",level:2}],u={toc:p},c="wrapper";function m(e){let{components:t,...a}=e;return(0,r.kt)(c,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"recap"},"Recap"),(0,r.kt)("p",null,"In this book we've implemented a very simple static blog generator while learning Haskell as we go."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We've learned about basic Haskell building blocks, such as definitions, functions,\ntypes, modules, recursion, pattern matching, type classes, IO and exceptions."),(0,r.kt)("li",{parentName:"ul"},"We've learned about ",(0,r.kt)("a",{parentName:"li",href:"./03-html/03-edsls.html"},"EDSLs")," and used the ",(0,r.kt)("em",{parentName:"li"},"combinator pattern")," to implement\na composable html generation library."),(0,r.kt)("li",{parentName:"ul"},"We've learned how to leverage types, modules and smart constructors\nto ",(0,r.kt)("a",{parentName:"li",href:"./03-html/04-safer_construction.html"},"make invalid states unrepresentable"),"."),(0,r.kt)("li",{parentName:"ul"},"We've learned how to represent complex data using ",(0,r.kt)("a",{parentName:"li",href:"./04-markup/01-data_type.html"},"ADTs"),"."),(0,r.kt)("li",{parentName:"ul"},"We've learned how to use ",(0,r.kt)("a",{parentName:"li",href:"./04-markup/04-parsing_02.html#pattern-matching"},"pattern matching")," to transform ADTs,\nand how to use ",(0,r.kt)("a",{parentName:"li",href:"./04-markup/02-parsing_01.html#recursion-and-accumulating-information"},"recursion")," to solve problems."),(0,r.kt)("li",{parentName:"ul"},"We've used the ",(0,r.kt)("em",{parentName:"li"},"functional core, imperative shell")," approach to build a program that handles IO and applies\nour domain logic to user inputs."),(0,r.kt)("li",{parentName:"ul"},"We've learned about abstractions such as ",(0,r.kt)("a",{parentName:"li",href:"./05-glue/01-markup_to_html.html#monoids"},"monoids"),",\n",(0,r.kt)("a",{parentName:"li",href:"./05-glue/04-optparse.html#functor"},"functors")," and ",(0,r.kt)("a",{parentName:"li",href:"./06-errors_and_files/01-either.html#monadic-interface"},"monads"),",\nand how they can help us reuse code and convey information about shared interfaces."),(0,r.kt)("li",{parentName:"ul"},"We've learned how to create fancy ",(0,r.kt)("a",{parentName:"li",href:"./05-glue/04-optparse.html"},"command-line interfaces"),", ",(0,r.kt)("a",{parentName:"li",href:"./08-testing.html"},"write tests"),",\nand ",(0,r.kt)("a",{parentName:"li",href:"./09-documentation.html"},"generate documentation"),".")),(0,r.kt)("p",null,"While Haskell is a very big and complex language, and there's always more to be learned,\nI think we've reached an important milestone where\nyou can start building your own Haskell projects and be productive with Haskell!"),(0,r.kt)("p",null,"This is a good time to celebrate and pat yourself on the back for getting this far! Great job, you!"),(0,r.kt)("p",null,"If you'd like to learn even more about Haskell and continue your Haskell journey\nbeyond this book, check out the appendix sections ",(0,r.kt)("a",{parentName:"p",href:"/learn-haskell-blog-generator/docs/next"},"Where to go next")," and the ",(0,r.kt)("a",{parentName:"p",href:"/learn-haskell-blog-generator/docs/faq"},"FAQ"),"."),(0,r.kt)("h2",{id:"thank-you"},"Thank you!"),(0,r.kt)("p",null,"Thank you for reading this book. I hope you enjoyed it and found Haskell interesting."),(0,r.kt)("p",null,"I would very much like to hear your feedback. If you'd like, you could leave your\nfeedback at this book's\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/issues"},"GitHub issue board"),",\nor you could reach me directly on ",(0,r.kt)("a",{parentName:"p",href:"https://fosstodon.org/@suppi"},"mastodon")," or via email.\nYou can find my contact information ",(0,r.kt)("a",{parentName:"p",href:"https://gilmi.me"},"on my website"),"."),(0,r.kt)("p",null,"If you liked this book, do let me know - your kind words mean a lot."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Finally, if you ",(0,r.kt)("em",{parentName:"p"},"really")," liked this book and would like to support future passion projects\nlike it, you can ",(0,r.kt)("a",{parentName:"p",href:"https://ko-fi.com/gilmi"},"support me directly via Ko-fi"),".")),(0,r.kt)("p",null,"Thank you and good luck with your next Haskell project!"))}m.isMDXComponent=!0}}]);