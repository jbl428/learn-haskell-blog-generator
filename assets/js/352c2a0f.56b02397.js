"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[89],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=u(n),d=a,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||l;return n?r.createElement(h,o(o({ref:t},p),{},{components:n})):r.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[m]="string"==typeof e?e:a,o[1]=i;for(var u=2;u<l;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2938:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>i,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const l={},o="Exposing internal functionality (Internal modules)",i={unversionedId:"html/internal-modules",id:"html/internal-modules",title:"Exposing internal functionality (Internal modules)",description:"We have now built a very small but convenient and safe way to write",source:"@site/docs/03-html/07-internal-modules.md",sourceDirName:"03-html",slug:"/html/internal-modules",permalink:"/learn-haskell-blog-generator/html/internal-modules",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/03-html/07-internal-modules.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ubb38\uc790 \uc774\uc2a4\ucf00\uc774\ud504 \ucc98\ub9ac\ud558\uae30",permalink:"/learn-haskell-blog-generator/html/escaping-characters"},next:{title:"Exercises",permalink:"/learn-haskell-blog-generator/html/exercises"}},s={},u=[{value:"Internal modules",id:"internal-modules",level:3},{value:"Let&#39;s make the changes",id:"lets-make-the-changes",level:3},{value:"Summary",id:"summary",level:2}],p={toc:u},m="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"exposing-internal-functionality-internal-modules"},"Exposing internal functionality (Internal modules)"),(0,a.kt)("p",null,"We have now built a very small but convenient and safe way to write\nHTML code in Haskell. This is something that we could (potentially)\npublish as a ",(0,a.kt)("em",{parentName:"p"},"library")," and share with the world by uploading it\nto a package repository such as ",(0,a.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/"},"Hackage"),".\nUsers who are interested in our library could use a package manager\nto include our library in their project and build their own HTML pages\nwith it."),(0,a.kt)("p",null,"It is important to note that users are building their project against\nthe API that we expose to them, and the package manager doesn't generally\nprovide access to the source code, so they can't, for example,\nmodify the ",(0,a.kt)("inlineCode",{parentName:"p"},"Html")," module (that we expose) in their project directly\nwithout jumping through some hoops."),(0,a.kt)("p",null,"Because we wanted our ",(0,a.kt)("inlineCode",{parentName:"p"},"Html")," EDSL to be safe, we ",(0,a.kt)("strong",{parentName:"p"},"hid the internal\nimplementation from the user"),", and the only way to interact with the\nlibrary is via the API we provide."),(0,a.kt)("p",null,"This provides the safety we wanted to provide, but in this case it also\n",(0,a.kt)("em",{parentName:"p"},"blocks")," the user from extending our library ",(0,a.kt)("em",{parentName:"p"},"in their own project")," with\nthings we haven't implemented yet, such as lists or code blocks."),(0,a.kt)("p",null,"When a user runs into trouble with a library (such as missing features)\nthe best course of action usually is to open an issue in the repository or\nsubmit a pull request, but sometimes the user needs things to work ",(0,a.kt)("em",{parentName:"p"},"now"),"."),(0,a.kt)("p",null,"We admit that we are not perfect and can't think of all use cases for our\nlibrary. Sometimes the restrictions we add are too great and may limit\nthe usage of advanced users that know how things work under the hood and\nneed certain functionality in order to use our library."),(0,a.kt)("h3",{id:"internal-modules"},"Internal modules"),(0,a.kt)("p",null,"For that we can expose internal modules to provide some flexibility for\nadvanced users. Internal modules are not a language concept but\nrather a (fairly common) design pattern (or idiom) in Haskell."),(0,a.kt)("p",null,"Internal modules are simply modules named ",(0,a.kt)("inlineCode",{parentName:"p"},"<something>.Internal"),",\nwhich export all of the functionality and implementation details in that module."),(0,a.kt)("p",null,"Instead of writing the implementation in (for example) the ",(0,a.kt)("inlineCode",{parentName:"p"},"Html")," module,\nwe write it in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Html.Internal")," module, which will export everything.\nThen we will import that module in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Html")," module, and write an explicit export list\nto only export the API we'd like to export (as before)."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Internal")," modules are considered unstable and risky to use by convention.\nIf you end up using one yourself when using an external Haskell library,\nmake sure to open a ticket in the library's repository after the storm has passed!"),(0,a.kt)("h3",{id:"lets-make-the-changes"},"Let's make the changes"),(0,a.kt)("p",null,"We will create a new directory named ",(0,a.kt)("inlineCode",{parentName:"p"},"Html")," and inside it a new file\nnamed ",(0,a.kt)("inlineCode",{parentName:"p"},"Internal.hs"),". The name of this module should be ",(0,a.kt)("inlineCode",{parentName:"p"},"Html.Internal"),"."),(0,a.kt)("p",null,"This module will contain all of the code we previously had in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Html"),"\nmodule, but ",(0,a.kt)("strong",{parentName:"p"},"we will change the module declaration in ",(0,a.kt)("inlineCode",{parentName:"strong"},"Html.Internal"),"\nand ",(0,a.kt)("em",{parentName:"strong"},"omit")," the export list"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},"-- Html/Internal.hs\n\nmodule Html.Internal where\n\n...\n")),(0,a.kt)("p",null,"And now in ",(0,a.kt)("inlineCode",{parentName:"p"},"Html.hs"),", we will remove the code that we moved to ",(0,a.kt)("inlineCode",{parentName:"p"},"Html/Internal.hs"),"\nand in its stead we'll import the internal module:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},"-- Html.hs\n\nmodule Html\n  ( Html\n  , Title\n  , Structure\n  , html_\n  , p_\n  , h1_\n  , append_\n  , render\n  )\n  where\n\nimport Html.Internal\n")),(0,a.kt)("p",null,"Now, users of our library can still import ",(0,a.kt)("inlineCode",{parentName:"p"},"Html")," and safely use our library,\nbut if they run into trouble and have a dire need to implement unordered lists\nto work with our library, they could always work with ",(0,a.kt)("inlineCode",{parentName:"p"},"Html.Internal")," instead."),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("b",null,"Our revised Html.hs and Html/Internal.hs")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},"-- Html.hs\n\nmodule Html\n  ( Html\n  , Title\n  , Structure\n  , html_\n  , p_\n  , h1_\n  , append_\n  , render\n  )\n  where\n\nimport Html.Internal\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-haskell"},'-- Html/Internal.hs\n\nmodule Html.Internal where\n\n-- * Types\n\nnewtype Html\n  = Html String\n\nnewtype Structure\n  = Structure String\n\ntype Title\n  = String\n\n-- * EDSL\n\nhtml_ :: Title -> Structure -> Html\nhtml_ title content =\n  Html\n    ( el "html"\n      ( el "head" (el "title" (escape title))\n        <> el "body" (getStructureString content)\n      )\n    )\n\np_ :: String -> Structure\np_ = Structure . el "p" . escape\n\nh1_ :: String -> Structure\nh1_ = Structure . el "h1" . escape\n\nappend_ :: Structure -> Structure -> Structure\nappend_ c1 c2 =\n  Structure (getStructureString c1 <> getStructureString c2)\n\n-- * Render\n\nrender :: Html -> String\nrender html =\n  case html of\n    Html str -> str\n\n-- * Utilities\n\nel :: String -> String -> String\nel tag content =\n  "<" <> tag <> ">" <> content <> "</" <> tag <> ">"\n\ngetStructureString :: Structure -> String\ngetStructureString content =\n  case content of\n    Structure str -> str\n\nescape :: String -> String\nescape =\n  let\n    escapeChar c =\n      case c of\n        \'<\' -> "&lt;"\n        \'>\' -> "&gt;"\n        \'&\' -> "&amp;"\n        \'"\' -> "&quot;"\n        \'\\\'\' -> "&#39;"\n        _ -> [c]\n  in\n    concat . map escapeChar\n'))),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("p",null,"For our particular project, ",(0,a.kt)("inlineCode",{parentName:"p"},"Internal")," modules aren't necessary.\nBecause our project and the source code for the HTML EDSL are\npart of the same project, and we have access to the ",(0,a.kt)("inlineCode",{parentName:"p"},"Html"),"\nmodule directly, we can always go and edit it if we want\n(and we are going to do that throughout the book)."),(0,a.kt)("p",null,"However, if we were planning to release our HTML EDSL as a ",(0,a.kt)("em",{parentName:"p"},"library"),"\nfor other developers to use, it would be nice\nto also expose the internal implementation as an ",(0,a.kt)("inlineCode",{parentName:"p"},"Internal"),"\nmodule. Just so we can save some trouble for potential users!"),(0,a.kt)("p",null,"We will see how to create a package from our source code in a later chapter."))}c.isMDXComponent=!0}}]);