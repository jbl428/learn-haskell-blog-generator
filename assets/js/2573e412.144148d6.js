"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[561],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=s(t),c=i,h=d["".concat(p,".").concat(c)]||d[c]||m[c]||r;return t?a.createElement(h,o(o({ref:n},u),{},{components:t})):a.createElement(h,o({ref:n},u))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=c;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[d]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=t[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},1548:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=t(7462),i=(t(7294),t(3905));const r={},o="Fancy options parsing",l={unversionedId:"glue/optparse",id:"glue/optparse",title:"Fancy options parsing",description:"We'd like to define a nicer interface for our program. While we could manage something",source:"@site/docs/05-glue/04-optparse.md",sourceDirName:"05-glue",slug:"/glue/optparse",permalink:"/learn-haskell-blog-generator/glue/optparse",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/05-glue/04-optparse.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ud504\ub85c\uc81d\ud2b8\uc758 \uba85\uc138\ub97c \uc815\uc758\ud558\uae30",permalink:"/learn-haskell-blog-generator/glue/project"},next:{title:"Handling errors and multiple files",permalink:"/learn-haskell-blog-generator/errors_and_files/"}},p={},s=[{value:"Building a command-line parser",id:"building-a-command-line-parser",level:2},{value:"Define a model",id:"define-a-model",level:3},{value:"Build a parser",id:"build-a-parser",level:3},{value:"Functor",id:"functor",level:4},{value:"Applicative",id:"applicative",level:4},{value:"Alternative",id:"alternative",level:4},{value:"Commands and subparsers",id:"commands-and-subparsers",level:4},{value:"ParserInfo",id:"parserinfo",level:4},{value:"Running a parser",id:"running-a-parser",level:3},{value:"Pattern matching on Options",id:"pattern-matching-on-options",level:3},{value:"Summary",id:"summary",level:2}],u={toc:s},d="wrapper";function m(e){let{components:n,...t}=e;return(0,i.kt)(d,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"fancy-options-parsing"},"Fancy options parsing"),(0,i.kt)("p",null,"We'd like to define a nicer interface for our program. While we could manage something\nourselves with ",(0,i.kt)("inlineCode",{parentName:"p"},"getArgs")," and pattern matching, it is easier to get good results using a library.\nWe are going to use a package called\n",(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/optparse-applicative"},"optparse-applicative"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"optparse-applicative")," provides us with an EDSL (yes, another one) to build\ncommand arguments parsers. Things like commands, switches, and flags can be built\nand composed together to make a parser for command-line arguments without actually\nwriting operations on strings as we did when we wrote our Markup parser, and will\nprovide other benefits such as automatic generation of usage lines, help screens,\nerror reporting, and more."),(0,i.kt)("p",null,"While ",(0,i.kt)("inlineCode",{parentName:"p"},"optparse-applicative"),"'s dependency footprint isn't very large,\nit is likely that a user of our library wouldn't need command-line parsing\nin this particular case, so it makes sense to add this dependency to the ",(0,i.kt)("inlineCode",{parentName:"p"},"executable")," section\n(rather than the ",(0,i.kt)("inlineCode",{parentName:"p"},"library")," section) in the ",(0,i.kt)("inlineCode",{parentName:"p"},".cabal")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"}," executable hs-blog-gen\n   import: common-settings\n   hs-source-dirs: app\n   main-is: Main.hs\n   build-depends:\n       base\n+    , optparse-applicative\n     , hs-blog\n   ghc-options:\n     -O\n")),(0,i.kt)("h2",{id:"building-a-command-line-parser"},"Building a command-line parser"),(0,i.kt)("p",null,"The optparse-applicative package has pretty decent\n",(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/optparse-applicative-0.16.1.0#optparse-applicative"},"documentation"),",\nbut we will cover a few important things to pay attention to in this chapter."),(0,i.kt)("p",null,"In general, there are four important things we need to do:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Define our model - we want to define an ADT that describes the various options\nand commands for our program")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Define a parser that will produce a value of our model type when run")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Run the parser on our program arguments input")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Pattern match on the model and call the right operations according to the options"))),(0,i.kt)("h3",{id:"define-a-model"},"Define a model"),(0,i.kt)("p",null,"Let's envision our command-line interface for a second, what should it\nlook like?"),(0,i.kt)("p",null,"We want to be able to convert a single file or input stream to either a file\nor an output stream, or we want to process a whole directory and create a new directory.\nWe can model it in an ADT like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"data Options\n  = ConvertSingle SingleInput SingleOutput\n  | ConvertDir FilePath FilePath\n  deriving Show\n\ndata SingleInput\n  = Stdin\n  | InputFile FilePath\n  deriving Show\n\ndata SingleOutput\n  = Stdout\n  | OutputFile FilePath\n  deriving Show\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that we could technically also use ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe FilePath")," to encode both ",(0,i.kt)("inlineCode",{parentName:"p"},"SingleInput"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"SingleOutput"),", but then we would have to remember what ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing")," means\nin each context. By creating a new type with properly named constructors\nfor each option we make it easier for readers of the code to understand\nthe meaning of our code.")),(0,i.kt)("p",null,"In terms of interface, we could decide that when a user would like to convert\na single input source, they would use the ",(0,i.kt)("inlineCode",{parentName:"p"},"convert")," command, and supply the optional flags\n",(0,i.kt)("inlineCode",{parentName:"p"},"--input FILEPATH")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"--output FILEPATH")," to read or write from a file.\nWhen the user does not supply one or both flags, we will read or write from\nthe standard input/output accordingly."),(0,i.kt)("p",null,"If the user would like to convert a directory, they can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"convert-dir"),"\ncommand and supply the two mandatory flags ",(0,i.kt)("inlineCode",{parentName:"p"},"--input FILEPATH")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"--output FILEPATH"),"."),(0,i.kt)("h3",{id:"build-a-parser"},"Build a parser"),(0,i.kt)("p",null,"This is the most interesting part of the process. How do we build a parser\nthat fits our model?"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"optparse-applicative")," library introduces a new type called ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),".\n",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),", similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),", has the kind ",(0,i.kt)("inlineCode",{parentName:"p"},"* -> *")," - when it\nis supplied with a saturated (or concrete) type such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Bool")," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"Options"),", it can become a saturated type (one that has values)."),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser a")," represents a specification of a command-line options parser\nthat produces a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," when the command-line arguments are\nsuccessfully parsed.\nThis is similar to how ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a")," represents a description of a program\nthat can produce a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),". The main difference between these\ntwo types is that while we can't convert an ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a")," to an ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),"\n(we just chain IO operations and have the Haskell runtime execute them),\nwe ",(0,i.kt)("em",{parentName:"p"},"can")," convert a ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser a")," to a function that takes a list of strings\nrepresenting the program arguments and produces an ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," if it manages\nto parse the arguments."),(0,i.kt)("p",null,"As we've seen with the previous EDSLs, this library uses the ",(0,i.kt)("em",{parentName:"p"},"combinator pattern"),"\nas well. We need to consider the basic primitives for building\na parser, and the methods of composing small parsers into bigger\nparsers."),(0,i.kt)("p",null,"Let's see an example for a small parser:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'inp :: Parser FilePath\ninp =\n  strOption\n    ( long "input"\n      <> short \'i\'\n      <> metavar "FILE"\n      <> help "Input file"\n    )\n\nout :: Parser FilePath\nout =\n  strOption\n    ( long "output"\n      <> short \'o\'\n      <> metavar "FILE"\n      <> help "Output file"\n    )\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"strOption")," is a parser builder. It is a function that takes a combined\n",(0,i.kt)("em",{parentName:"p"},"option modifiers")," as an argument, and returns a parser that will parse a string.\nWe can specify the type to be ",(0,i.kt)("inlineCode",{parentName:"p"},"FilePath")," because ",(0,i.kt)("inlineCode",{parentName:"p"},"FilePath")," is an\nalias to ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),". The parser builder describes how to parse the value,\nand the modifiers describe its properties, such as the flag name,\nthe shorthand of the flag name, and how it would be described in the usage\nand help messages."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Actually ",(0,i.kt)("inlineCode",{parentName:"p"},"strOption")," can return any string type\nthat implements the interface ",(0,i.kt)("inlineCode",{parentName:"p"},"IsString"),". There are a few such types,\nfor example ",(0,i.kt)("inlineCode",{parentName:"p"},"Text"),", a much more efficient Unicode text type from the ",(0,i.kt)("inlineCode",{parentName:"p"},"text")," package.\nIt is more efficient than ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," because while ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," is implemented as a\nlinked list of ",(0,i.kt)("inlineCode",{parentName:"p"},"Char"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Text")," is implemented as an array of bytes.\n",(0,i.kt)("inlineCode",{parentName:"p"},"Text")," is usually what we should use for text values instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),". We haven't\nbeen using it up until now because it is slightly less ergonomic to use\nthan ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),". But it is often the preferred type to use for text!")),(0,i.kt)("p",null,"As you can see, modifiers can be composed using the ",(0,i.kt)("inlineCode",{parentName:"p"},"<>")," function,\nwhich means modifiers implement an instance of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup")," type class!"),(0,i.kt)("p",null,"With such an interface we don't have to supply all the modifier\noptions, but only the relevant ones. So if we don't want to\nhave a shortened flag name, we don't have to add it."),(0,i.kt)("h4",{id:"functor"},"Functor"),(0,i.kt)("p",null,"For the data type we've defined, having ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser FilePath")," takes us\na good step in the right direction, but it is not exactly what we need\nfor a ",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertSingle"),". We need a ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser SingleInput")," and a\n",(0,i.kt)("inlineCode",{parentName:"p"},"Parser SingleOutput"),". If we had a ",(0,i.kt)("inlineCode",{parentName:"p"},"FilePath"),", we could convert\nit into ",(0,i.kt)("inlineCode",{parentName:"p"},"SingleInput")," by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"InputFile")," constructor.\nRemember, ",(0,i.kt)("inlineCode",{parentName:"p"},"InputFile")," is also a function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"InputFile :: FilePath -> SingleInput\nOutputFile :: FilePath -> SingleOutput\n")),(0,i.kt)("p",null,"However, to convert a parser, we need functions with these types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"f :: Parser FilePath -> Parser SingleInput\ng :: Parser FilePath -> Parser SingleOutput\n")),(0,i.kt)("p",null,"Fortunately, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),' interface provides us with a function to "lift"\na function like ',(0,i.kt)("inlineCode",{parentName:"p"},"FilePath -> SingleInput")," to work on parsers, making\nit a function with the type ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser FilePath -> Parser SingleInput"),".\nOf course, this function will work for any input and output,\nso if we have a function with the type ",(0,i.kt)("inlineCode",{parentName:"p"},"a -> b"),", we can pass it to\nthat function and get a new function of the type ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser a -> Parser b"),"."),(0,i.kt)("p",null,"This function is called ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"fmap :: (a -> b) -> Parser a -> Parser b\n\n-- Or with its infix version\n(<$>)  :: (a -> b) -> Parser a -> Parser b\n")),(0,i.kt)("p",null,"We've seen ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap")," before in the interface of other types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"fmap :: (a -> b) -> [a] -> [b]\n\nfmap :: (a -> b) -> IO a -> IO b\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"fmap")," is a type class function like ",(0,i.kt)("inlineCode",{parentName:"p"},"<>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"show"),". It belongs\nto the type class ",(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Functor.html#t:Functor"},(0,i.kt)("inlineCode",{parentName:"a"},"Functor")),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"class Functor f where\n  fmap :: (a -> b) -> f a -> f b\n")),(0,i.kt)("p",null,"And it has the following laws:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"-- 1. Identity law:\n--    if we don't change the values, nothing should change\nfmap id = id\n\n-- 2. Composition law:\n--    Composing the lifted functions is the same a composing\n--    them after fmap\nfmap (f . g) == fmap f . fmap g\n")),(0,i.kt)("p",null,"Any type ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," that can implement ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap")," and follow these laws can be a valid\ninstance of ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Notice how ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," has a kind ",(0,i.kt)("inlineCode",{parentName:"p"},"* -> *"),", we can infer the kind of ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),"\nby looking at the other types in the type signature of ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),":"),(0,i.kt)("ol",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"b")," have the kind ",(0,i.kt)("inlineCode",{parentName:"li"},"*")," because they are used as arguments/return\ntypes of functions"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"f a")," has the kind ",(0,i.kt)("inlineCode",{parentName:"li"},"*")," because it is used as an argument to a function, therefore"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"f")," has the kind ",(0,i.kt)("inlineCode",{parentName:"li"},"* -> *")))),(0,i.kt)("p",null,"Let's choose a data type and see if we can implement a ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," instance.\nWe need to choose a data type that has the kind ",(0,i.kt)("inlineCode",{parentName:"p"},"* -> *"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," fits the bill.\nWe need to implement a function ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap :: (a -> b) -> Maybe a -> Maybe b"),".\nHere's one very simple (and wrong) implementation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"mapMaybe :: (a -> b) -> Maybe a -> Maybe b\nmapMaybe func maybeX = Nothing\n")),(0,i.kt)("p",null,"Check it yourself! It compiles successfully! But unfortunately it does not\nsatisfy the first law. ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap id = id")," means that\n",(0,i.kt)("inlineCode",{parentName:"p"},"mapMaybe id (Just x) == Just x"),", however from the definition we can\nclearly see that ",(0,i.kt)("inlineCode",{parentName:"p"},"mapMaybe id (Just x) == Nothing"),"."),(0,i.kt)("p",null,"This is a good example of how Haskell doesn't help us make sure the laws\nare satisfied, and why they are important. Unlawful ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," instances\nwill behave differently from what we'd expect a ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," to behave.\nLet's try again!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"mapMaybe :: (a -> b) -> Maybe a -> Maybe b\nmapMaybe func maybeX =\n  case maybeX of\n    Nothing -> Nothing\n    Just x -> Just (func x)\n")),(0,i.kt)("p",null,"This ",(0,i.kt)("inlineCode",{parentName:"p"},"mapMaybe")," will satisfy the functor laws. This can be proved\nby doing algebra - if we can do substitution and reach the other side of the\nequation in each law, then the law holds."),(0,i.kt)("p",null,"Functor is a very important type class, and many types implement this interface.\nAs we know, ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"[]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser")," all have the kind ",(0,i.kt)("inlineCode",{parentName:"p"},"* -> *"),',\nand all allows us to map over their "payload" type.'),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Often people try to look for analogies and metaphors to what a type class mean,\nbut type classes with funny names like ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," don't usually have an\nanalogy or a metaphor that fits them in all cases. It is easier to give up\non the metaphor and think about it as it is - an interface with laws.")),(0,i.kt)("p",null,"We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap")," on ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser")," to make a parser that returns ",(0,i.kt)("inlineCode",{parentName:"p"},"FilePath")," to\nreturn a ",(0,i.kt)("inlineCode",{parentName:"p"},"SingleInput")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"SingleOutput")," instead:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'pInputFile :: Parser SingleInput\npInputFile = fmap InputFile parser\n  where\n    parser =\n      strOption\n        ( long "input"\n          <> short \'i\'\n          <> metavar "FILE"\n          <> help "Input file"\n        )\n\npOutputFile :: Parser SingleOutput\npOutputFile = OutputFile <$> parser -- fmap and <$> are the same\n  where\n    parser =\n      strOption\n        ( long "output"\n          <> short \'o\'\n          <> metavar "FILE"\n          <> help "Output file"\n        )\n')),(0,i.kt)("h4",{id:"applicative"},"Applicative"),(0,i.kt)("p",null,"Now that we have two parsers,\n",(0,i.kt)("inlineCode",{parentName:"p"},"pInputFile :: Parser SingleInput"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"pOutputFile :: Parser SingleOutput"),",\nwe want to ",(0,i.kt)("em",{parentName:"p"},"combine")," them as ",(0,i.kt)("inlineCode",{parentName:"p"},"Options"),". Again, if we only had\n",(0,i.kt)("inlineCode",{parentName:"p"},"SingleInput")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"SingleOutput"),", we could use the constructor ",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertSingle"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"ConvertSingle :: SingleInput -> SingleOutput -> Options\n")),(0,i.kt)("p",null,"Can we do a similar trick to the one we saw before with ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),"?\nDoes a function exist that can lift a binary function to work\non ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),"s instead? One with this type signature:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"???\n  :: (SingleInput -> SingleOutput -> Options)\n  -> (Parser SingleInput -> Parser SingleOutput -> Parser Options)\n")),(0,i.kt)("p",null,"Yes. This function is called ",(0,i.kt)("inlineCode",{parentName:"p"},"liftA2")," and it is from the ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative"),"\ntype class. ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative")," (also known as applicative functor) has three\nprimary functions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"class Functor f => Applicative f where\n  pure :: a -> f a\n  liftA2 :: (a -> b -> c) -> f a -> f b -> f c\n  (<*>) :: f (a -> b) -> f a -> f b\n")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Applicative.html#t:Applicative"},(0,i.kt)("inlineCode",{parentName:"a"},"Applicative")),"\nis another very popular type class with many instances."),(0,i.kt)("p",null,"Just like any ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"Semigroup"),", any ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative"),"\nis a ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor"),". This means that any type that wants to implement\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative")," interface should also implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor")," interface."),(0,i.kt)("p",null,"Beyond what a regular functor can do, which is to lift a function over\na certain ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", applicative functors allow us to apply a function to\n",(0,i.kt)("em",{parentName:"p"},"multiple instances")," of a certain ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),', as well as "lift" any value of type ',(0,i.kt)("inlineCode",{parentName:"p"},"a")," into an ",(0,i.kt)("inlineCode",{parentName:"p"},"f a"),"."),(0,i.kt)("p",null,"You should already be familiar with ",(0,i.kt)("inlineCode",{parentName:"p"},"pure"),", we've seen it when we\ntalked about ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),". For ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"pure")," lets us create an ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," action\nwith a specific return value without doing IO.\nWith ",(0,i.kt)("inlineCode",{parentName:"p"},"pure")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),", we can create a ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser")," that when run\nwill return a specific value as output without doing any parsing."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"liftA2")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<*>")," are two functions that can be implemented in\nterms of one another. ",(0,i.kt)("inlineCode",{parentName:"p"},"<*>")," is actually the more useful one between\nthe two. Because when combined with ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap")," (or rather the infix version ",(0,i.kt)("inlineCode",{parentName:"p"},"<$>"),"),\nit can be used to apply a function with many arguments, instead of just two."),(0,i.kt)("p",null,"To combine our two parsers to one, we can use either ",(0,i.kt)("inlineCode",{parentName:"p"},"liftA2")," or\na combination of ",(0,i.kt)("inlineCode",{parentName:"p"},"<$>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<*>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"-- with liftA2\npConvertSingle :: Parser Options\npConvertSingle =\n  liftA2 ConvertSingle pInputFile pOutputFile\n\n-- with <$> and <*>\npConvertSingle :: Parser Options\npConvertSingle =\n  ConvertSingle <$> pInputFile <*> pOutputFile\n")),(0,i.kt)("p",null,"Note that both ",(0,i.kt)("inlineCode",{parentName:"p"},"<$>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<*>")," associate to the left,\nso we have invisible parenthesis that look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"pConvertSingle :: Parser Options\npConvertSingle =\n  (ConvertSingle <$> pInputFile) <*> pOutputFile\n")),(0,i.kt)("p",null,"Let's take a deeper look at the types of the sub-expressions\nwe have here, to prove that this type-checks:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"pConvertSingle :: Parser Options\n\npInputFile :: Parser SingleInput\npOutputFile :: Parser SingleOutput\n\nConvertSingle :: SingleInput -> SingleOutput -> Options\n\n(<$>) :: (a -> b) -> Parser a -> Parser b\n  -- Specifically, here `a` is `SingleInput`\n  -- and `b` is `SingleOutput -> Options`,\n\nConvertSingle <$> pInputFile :: Parser (SingleOutput -> Options)\n\n(<*>) :: Parser (a -> b) -> Parser a -> Parser b\n  -- Specifically, here `a -> b` is `SingleOutput -> Options`\n  -- so `a` is `SingleOutput` and `b` is `Options`\n\n-- So we get:\n(ConvertSingle <$> pInputFile) <*> pOutputFile :: Parser Options\n")),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"<$>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<*>")," we can chain as many parsers (or any applicative really)\nas we want. This is because of two things: currying and parametric polymorphism.\nBecause functions in Haskell take exactly one argument and return exactly one,\nany multiple argument function can be represented as ",(0,i.kt)("inlineCode",{parentName:"p"},"a -> b"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"You can find the laws for the applicative functors in this article called\n",(0,i.kt)("a",{parentName:"p",href:"https://wiki.haskell.org/Typeclassopedia#Laws_2"},"Typeclassopedia"),", which\ntalks about various useful type classes and their laws.")),(0,i.kt)("p",null,"Applicative functor is a very important concept and will appear in various\nparser interfaces (not just for command-line arguments, but also JSON\nparsers and general parsers), I/O, concurrency, non-determinism, and more.\nThe reason this library is called optparse-applicative is because\nit uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative")," interface as the main API for\nconstructing parsers."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Exercise"),": create a similar interface for the ",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertDir")," constructor of ",(0,i.kt)("inlineCode",{parentName:"p"},"Options"),"."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'pInputDir :: Parser FilePath\npInputDir =\n  strOption\n    ( long "input"\n      <> short \'i\'\n      <> metavar "DIRECTORY"\n      <> help "Input directory"\n    )\n\npOutputDir :: Parser FilePath\npOutputDir =\n  strOption\n    ( long "output"\n      <> short \'o\'\n      <> metavar "DIRECTORY"\n      <> help "Output directory"\n    )\n\npConvertDir :: Parser Options\npConvertDir =\n  ConvertDir <$> pInputDir <*> pOutputDir\n'))),(0,i.kt)("hr",null),(0,i.kt)("h4",{id:"alternative"},"Alternative"),(0,i.kt)("p",null,"One thing we forgot about is that each input and output for\n",(0,i.kt)("inlineCode",{parentName:"p"},"ConvertSingle")," could also potentially use the standard input and output instead.\nUp until now we only offered one option: reading from or writing to a file\nby specifying the flags ",(0,i.kt)("inlineCode",{parentName:"p"},"--input")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"--output"),".\nHowever, we'd like to make these flags optional, and when they are\nnot specified, use the alternative standard i/o. We can do that by using\nthe function ",(0,i.kt)("inlineCode",{parentName:"p"},"optional")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"Control.Applicative"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"optional :: Alternative f => f a -> f (Maybe a)\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"optional")," works on types which implement instances of the\n",(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Applicative.html#t:Alternative"},(0,i.kt)("inlineCode",{parentName:"a"},"Alternative"))," type class:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"class Applicative f => Alternative f where\n  (<|>) :: f a -> f a -> f a\n  empty :: f a\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Alternative")," looks very similar to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid")," type class,\nbut it works on applicative functors. This type class isn't\nvery common and is mostly used for parsing libraries as far as I know.\nIt provides us with an interface to combine two ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),"s -\nif the first one fails to parse, try the other.\nIt also provides other useful functions such as ",(0,i.kt)("inlineCode",{parentName:"p"},"optional"),",\nwhich will help us with our case:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"pSingleInput :: Parser SingleInput\npSingleInput =\n  fromMaybe Stdin <$> optional pInputFile\n\npSingleOutput :: Parser SingleOutput\npSingleOutput =\n  fromMaybe Stdout <$> optional pOutputFile\n")),(0,i.kt)("p",null,"Note that with ",(0,i.kt)("inlineCode",{parentName:"p"},"fromMaybe :: a -> Maybe a -> a")," we can extract\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," out of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe")," by supplying a value for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing")," case."),(0,i.kt)("p",null,"Now we can use these more appropriate functions in ",(0,i.kt)("inlineCode",{parentName:"p"},"pConvertSingle")," instead:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"pConvertSingle :: Parser Options\npConvertSingle =\n  ConvertSingle <$> pSingleInput <*> pSingleOutput\n")),(0,i.kt)("h4",{id:"commands-and-subparsers"},"Commands and subparsers"),(0,i.kt)("p",null,"We currently have two possible operations in our interface,\nconvert a single source, or convert a directory. A nice interface for\nselecting the right operation would be via commands.\nIf the user would like to convert a single source, they can use\n",(0,i.kt)("inlineCode",{parentName:"p"},"convert"),", for a directory, ",(0,i.kt)("inlineCode",{parentName:"p"},"convert-dir"),"."),(0,i.kt)("p",null,"We can create a parser with commands with the ",(0,i.kt)("inlineCode",{parentName:"p"},"subparser")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"command"),"\nfunctions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"subparser :: Mod CommandFields a -> Parser a\n\ncommand :: String -> ParserInfo a -> Mod CommandFields a\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"subparser")," takes ",(0,i.kt)("em",{parentName:"p"},"command modifiers")," (which can be constructed\nwith the ",(0,i.kt)("inlineCode",{parentName:"p"},"command")," function) as input, and produces a ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser"),".\n",(0,i.kt)("inlineCode",{parentName:"p"},"command"),' takes the command name (in our case "convert" or "convert-dir")\nand a ',(0,i.kt)("inlineCode",{parentName:"p"},"ParserInfo a"),", and produces a command modifier. As we've seen\nbefore these modifiers have a ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid")," instance and they can be\ncomposed, meaning that we can append multiple commands to serve as alternatives."),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"ParserInfo a")," can be constructed with the ",(0,i.kt)("inlineCode",{parentName:"p"},"info")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"info :: Parser a -> InfoMod a -> ParserInfo a\n")),(0,i.kt)("p",null,"This function wraps a ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser")," with some additional information\nsuch as a helper message, description, and more, so that the program\nitself and each sub command can print some additional information."),(0,i.kt)("p",null,"Let's see how to construct a ",(0,i.kt)("inlineCode",{parentName:"p"},"ParserInfo"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'pConvertSingleInfo :: ParserInfo Options\npConvertSingleInfo =\n  info\n    (helper <*> pConvertSingle)\n    (progDesc "Convert a single markup source to html")\n')),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"helper")," adds a helper output screen in case the parser fails."),(0,i.kt)("p",null,"Let's also build a command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'pConvertSingleCommand :: Mod CommandFields Options\npConvertSingleCommand =\n  command "convert" pConvertSingleInfo\n')),(0,i.kt)("p",null,"Try creating a ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser Options")," combining the two options with ",(0,i.kt)("inlineCode",{parentName:"p"},"subparser"),"."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'pOptions :: Parser Options\npOptions =\n  subparser\n    ( command\n      "convert"\n      ( info\n        (helper <*> pConvertSingle)\n        (progDesc "Convert a single markup source to html")\n      )\n      <> command\n      "convert-dir"\n      ( info\n        (helper <*> pConvertDir)\n        (progDesc "Convert a directory of markup files to html")\n      )\n    )\n'))),(0,i.kt)("h4",{id:"parserinfo"},"ParserInfo"),(0,i.kt)("p",null,"Since we finished building a parser, we should wrap it up in a ",(0,i.kt)("inlineCode",{parentName:"p"},"ParserInfo"),"\nand add some information to it to make it ready to run:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'opts :: ParserInfo Options\nopts =\n  info (helper <*> pOptions)\n    ( fullDesc\n      <> header "hs-blog-gen - a static blog generator"\n      <> progDesc "Convert markup files or directories to html"\n    )\n')),(0,i.kt)("h3",{id:"running-a-parser"},"Running a parser"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"optparse-applicative")," provides a non-",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," interface to parse arguments,\nbut the most convenient way to use it is to let it take care of fetching\nprogram arguments, try to parse them, and throw errors and help messages in case\nit fails. This can be done with the function ",(0,i.kt)("inlineCode",{parentName:"p"},"execParser :: ParserInfo a -> IO a"),"."),(0,i.kt)("p",null,"We can place all this options parsing stuff in a new module\nand then import it from ",(0,i.kt)("inlineCode",{parentName:"p"},"app/Main.hs"),". Let's do that.\nHere's what we have up until now:"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"app/OptParse.hs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'-- | Command-line options parsing\n\nmodule OptParse\n  ( Options(..)\n  , SingleInput(..)\n  , SingleOutput(..)\n  , parse\n  )\n  where\n\nimport Data.Maybe (fromMaybe)\nimport Options.Applicative\n\n------------------------------------------------\n-- * Our command-line options model\n\n-- | Model\ndata Options\n  = ConvertSingle SingleInput SingleOutput\n  | ConvertDir FilePath FilePath\n  deriving Show\n\n-- | A single input source\ndata SingleInput\n  = Stdin\n  | InputFile FilePath\n  deriving Show\n\n-- | A single output sink\ndata SingleOutput\n  = Stdout\n  | OutputFile FilePath\n  deriving Show\n\n------------------------------------------------\n-- * Parser\n\n-- | Parse command-line options\nparse :: IO Options\nparse = execParser opts\n\nopts :: ParserInfo Options\nopts =\n  info (pOptions <**> helper)\n    ( fullDesc\n      <> header "hs-blog-gen - a static blog generator"\n      <> progDesc "Convert markup files or directories to html"\n    )\n\n-- | Parser for all options\npOptions :: Parser Options\npOptions =\n  subparser\n    ( command\n      "convert"\n      ( info\n        (helper <*> pConvertSingle)\n        (progDesc "Convert a single markup source to html")\n      )\n      <> command\n      "convert-dir"\n      ( info\n        (helper <*> pConvertDir)\n        (progDesc "Convert a directory of markup files to html")\n      )\n    )\n\n------------------------------------------------\n-- * Single source to sink conversion parser\n\n-- | Parser for single source to sink option\npConvertSingle :: Parser Options\npConvertSingle =\n  ConvertSingle <$> pSingleInput <*> pSingleOutput\n\n-- | Parser for single input source\npSingleInput :: Parser SingleInput\npSingleInput =\n  fromMaybe Stdin <$> optional pInputFile\n\n-- | Parser for single output sink\npSingleOutput :: Parser SingleOutput\npSingleOutput =\n  fromMaybe Stdout <$> optional pOutputFile\n\n-- | Input file parser\npInputFile :: Parser SingleInput\npInputFile = fmap InputFile parser\n  where\n    parser =\n      strOption\n        ( long "input"\n          <> short \'i\'\n          <> metavar "FILE"\n          <> help "Input file"\n        )\n\n-- | Output file parser\npOutputFile :: Parser SingleOutput\npOutputFile = OutputFile <$> parser\n  where\n    parser =\n      strOption\n        ( long "output"\n          <> short \'o\'\n          <> metavar "FILE"\n          <> help "Output file"\n        )\n\n------------------------------------------------\n-- * Directory conversion parser\n\npConvertDir :: Parser Options\npConvertDir =\n  ConvertDir <$> pInputDir <*> pOutputDir\n\n-- | Parser for input directory\npInputDir :: Parser FilePath\npInputDir =\n  strOption\n    ( long "input"\n      <> short \'i\'\n      <> metavar "DIRECTORY"\n      <> help "Input directory"\n    )\n\n-- | Parser for output directory\npOutputDir :: Parser FilePath\npOutputDir =\n  strOption\n    ( long "output"\n      <> short \'o\'\n      <> metavar "DIRECTORY"\n      <> help "Output directory"\n    )\n'))),(0,i.kt)("h3",{id:"pattern-matching-on-options"},"Pattern matching on Options"),(0,i.kt)("p",null,"After running the command-line arguments parser, we can pattern match\non our model and call the right functions. Currently, our program\ndoes not expose this kind of API. So let's go to our ",(0,i.kt)("inlineCode",{parentName:"p"},"src/HsBlog.hs"),"\nmodule and change the API. We can delete ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," from that file and\nadd two new functions instead:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"convertSingle :: Html.Title -> Handle -> Handle -> IO ()\n\nconvertDirectory :: FilePath -> FilePath -> IO ()\n")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/System-IO.html#t:Handle"},(0,i.kt)("inlineCode",{parentName:"a"},"Handle")),"\nis an I/O abstraction over file system objects, including ",(0,i.kt)("inlineCode",{parentName:"p"},"stdin")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"stdout"),".\nBefore, we used ",(0,i.kt)("inlineCode",{parentName:"p"},"writeFile")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"getContents")," - these functions either\nget a ",(0,i.kt)("inlineCode",{parentName:"p"},"FilePath")," to open and work on, or they assume the ",(0,i.kt)("inlineCode",{parentName:"p"},"Handle")," is the standard I/O.\nWe can use the explicit versions that take a ",(0,i.kt)("inlineCode",{parentName:"p"},"Handle")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"System.IO")," instead:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"convertSingle :: Html.Title -> Handle -> Handle -> IO ()\nconvertSingle title input output = do\n  content <- hGetContents input\n  hPutStrLn output (process title content)\n")),(0,i.kt)("p",null,"We will leave ",(0,i.kt)("inlineCode",{parentName:"p"},"convertDirectory")," unimplemented for now and implement it in the next chapter."),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"app/Main.hs"),", we will need to pattern match on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Options")," and\nprepare to call the right functions from ",(0,i.kt)("inlineCode",{parentName:"p"},"HsBlog"),"."),(0,i.kt)("p",null,"Let's look at our full ",(0,i.kt)("inlineCode",{parentName:"p"},"app/Main.hs")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"src/HsBlog.hs"),":"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"app/Main.hs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'-- | Entry point for the hs-blog-gen program\n\nmodule Main where\n\nimport OptParse\nimport qualified HsBlog\n\nimport System.Exit (exitFailure)\nimport System.Directory (doesFileExist)\nimport System.IO\n\nmain :: IO ()\nmain = do\n  options <- parse\n  case options of\n    ConvertDir input output ->\n      HsBlog.convertDirectory input output\n\n    ConvertSingle input output -> do\n      (title, inputHandle) <-\n        case input of\n          Stdin ->\n            pure ("", stdin)\n          InputFile file ->\n            (,) file <$> openFile file ReadMode\n\n      outputHandle <-\n        case output of\n          Stdout -> pure stdout\n          OutputFile file -> do\n            exists <- doesFileExist file\n            shouldOpenFile <-\n              if exists\n                then confirm\n                else pure True\n            if shouldOpenFile\n              then\n                openFile file WriteMode\n              else\n                exitFailure\n\n      HsBlog.convertSingle title inputHandle outputHandle\n      hClose inputHandle\n      hClose outputHandle\n\n------------------------------------------------\n-- * Utilities\n\n-- | Confirm user action\nconfirm :: IO Bool\nconfirm =\n  putStrLn "Are you sure? (y/n)" *>\n    getLine >>= \\answer ->\n      case answer of\n        "y" -> pure True\n        "n" -> pure False\n        _ -> putStrLn "Invalid response. use y or n" *>\n          confirm\n'))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"src/HsBlog.hs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'-- HsBlog.hs\nmodule HsBlog\n  ( convertSingle\n  , convertDirectory\n  , process\n  )\n  where\n\nimport qualified HsBlog.Markup as Markup\nimport qualified HsBlog.Html as Html\nimport HsBlog.Convert (convert)\n\nimport System.IO\n\nconvertSingle :: Html.Title -> Handle -> Handle -> IO ()\nconvertSingle title input output = do\n  content <- hGetContents input\n  hPutStrLn output (process title content)\n\nconvertDirectory :: FilePath -> FilePath -> IO ()\nconvertDirectory = error "Not implemented"\n\nprocess :: Html.Title -> String -> String\nprocess title = Html.render . convert title . Markup.parse\n'))),(0,i.kt)("p",null,"We need to make a few small changes to the ",(0,i.kt)("inlineCode",{parentName:"p"},".cabal")," file."),(0,i.kt)("p",null,"First, we need to add the dependency ",(0,i.kt)("inlineCode",{parentName:"p"},"directory")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"executable"),",\nbecause we use the library ",(0,i.kt)("inlineCode",{parentName:"p"},"System.Directory")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"Main"),"."),(0,i.kt)("p",null,"Second, we need to list ",(0,i.kt)("inlineCode",{parentName:"p"},"OptParse")," in the list of modules in\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"executable"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"}," executable hs-blog-gen\n   import: common-settings\n   hs-source-dirs: app\n   main-is: Main.hs\n+  other-modules:\n+    OptParse\n   build-depends:\n       base\n+    , directory\n     , optparse-applicative\n     , hs-blog\n   ghc-options:\n     -O\n")),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"We've learned about a new fancy library called ",(0,i.kt)("inlineCode",{parentName:"p"},"optparse-applicative"),"\nand used it to create a fancier command-line interface in a declarative way.\nSee the result of running ",(0,i.kt)("inlineCode",{parentName:"p"},"hs-blog-gen --help")," (or the equivalent\n",(0,i.kt)("inlineCode",{parentName:"p"},"cabal"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"stack")," commands we discussed in the last chapter):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"hs-blog-gen - a static blog generator\n\nUsage: hs-blog-gen COMMAND\n  Convert markup files or directories to html\n\nAvailable options:\n  -h,--help                Show this help text\n\nAvailable commands:\n  convert                  Convert a single markup source to html\n  convert-dir              Convert a directory of markup files to html\n")),(0,i.kt)("p",null,"Along the way we've learned two powerful new abstractions, ",(0,i.kt)("inlineCode",{parentName:"p"},"Functor"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"Applicative"),", as well as revisited an abstraction\ncalled ",(0,i.kt)("inlineCode",{parentName:"p"},"Monoid"),". With this library we've seen another example\nof the usefulness of these abstractions for constructing APIs and EDSLs."),(0,i.kt)("p",null,"We will continue to meet these abstractions in the rest of the book."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Bonus exercise"),": Add another flag named ",(0,i.kt)("inlineCode",{parentName:"p"},"--replace")," to indicate that\nif the output file or directory already exists, it's okay to replace them."),(0,i.kt)("hr",null),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"You can view the git commit of\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/commit/d0d76aad632fe3abd8701e44db5ba687e0c7ac96"},"the changes we've made"),"\nand the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/tree/d0d76aad632fe3abd8701e44db5ba687e0c7ac96"},"code up until now"),".")))}m.isMDXComponent=!0}}]);