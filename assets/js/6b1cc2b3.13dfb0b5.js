"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[946],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>c});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=s(t),h=i,c=m["".concat(p,".").concat(h)]||m[h]||d[h]||r;return t?a.createElement(c,o(o({ref:n},u),{},{components:t})):a.createElement(c,o({ref:n},u))}));function c(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=h;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[m]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=t[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},8652:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=t(7462),i=(t(7294),t(3905));const r={},o="Working with IO",l={unversionedId:"glue/io",id:"glue/io",title:"Working with IO",description:"In previous chapters we were able to build a parser from a text",source:"@site/docs/05-glue/02-io.md",sourceDirName:"05-glue",slug:"/glue/io",permalink:"/learn-haskell-blog-generator/glue/io",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/05-glue/02-io.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Converting Markup to HTML",permalink:"/learn-haskell-blog-generator/glue/markup-to-html"},next:{title:"Defining a project description",permalink:"/learn-haskell-blog-generator/glue/project"}},p={},s=[{value:"Purely functional",id:"purely-functional",level:2},{value:"IO",id:"io",level:2},{value:"Combining IO expressions",id:"combining-io-expressions",level:2},{value:"&gt;&gt;=",id:"",level:3},{value:"*&gt; and &gt;&gt;",id:"-and-",level:3},{value:"pure and return",id:"pure-and-return",level:3},{value:"fmap and &lt;$&gt;",id:"fmap-and-",level:3},{value:"Summary",id:"summary",level:3},{value:"IO is first class",id:"io-is-first-class",level:2},{value:"Getting out of IO?",id:"getting-out-of-io",level:2},{value:"Functional core, imperative shell",id:"functional-core-imperative-shell",level:2},{value:"Building a blog generator",id:"building-a-blog-generator",level:2},{value:"Do notation",id:"do-notation",level:2},{value:"Summary",id:"summary-1",level:2}],u={toc:s},m="wrapper";function d(e){let{components:n,...t}=e;return(0,i.kt)(m,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"working-with-io"},"Working with IO"),(0,i.kt)("p",null,"In previous chapters we were able to build a parser from a text\nstring to a Haskell representation of our markup language,\nand we built an EDSL for easy writing of HTML code.\nHowever, our program is still not useful to other users because\nwe did not make this functionality accessible via some sort of\nuser interface."),(0,i.kt)("p",null,"In our program, we'd like to take user input and then convert it to HTML.\nThere are many ways to design this kind of interface, for example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Get text input via the ",(0,i.kt)("em",{parentName:"li"},"standard input")," and output HTML\nvia the ",(0,i.kt)("em",{parentName:"li"},"standard output")),(0,i.kt)("li",{parentName:"ul"},"Receive two file names as ",(0,i.kt)("em",{parentName:"li"},"command-line arguments"),", read the contents\nof the first one, and write the output to the second one"),(0,i.kt)("li",{parentName:"ul"},"Ask for fancier command-line arguments parsing and prefix\nthe file names with flags indicating what they are"),(0,i.kt)("li",{parentName:"ul"},"Some fancy GUI interface"),(0,i.kt)("li",{parentName:"ul"},"Combination of all of the above")),(0,i.kt)("p",null,"To make this interesting, we will start with the following interface:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"If the user calls the program without arguments, we will read from\nthe standard input, and write to the standard output"),(0,i.kt)("li",{parentName:"ol"},"If the user calls the program with two arguments, the first one\nwill be the input file name, and the second one\nwill be the output file name"),(0,i.kt)("li",{parentName:"ol"},"If the output file already exists, we'll ask the user if they want\nto overwrite the file"),(0,i.kt)("li",{parentName:"ol"},"On any other kind of input, we'll print a generic message explaining\nthe proper usage")),(0,i.kt)("p",null,"In a later chapter, we will add a fancier command-line interface\nusing a library, and also read whole directories in addition to single files."),(0,i.kt)("p",null,"But first, we need to learn about I/O in Haskell, what makes\nit special, and why it's different from other programming languages."),(0,i.kt)("h2",{id:"purely-functional"},"Purely functional"),(0,i.kt)("p",null,"Originally, Haskell was designed as an ",(0,i.kt)("em",{parentName:"p"},"open standard"),"\nfunctional programming language with ",(0,i.kt)("strong",{parentName:"p"},"non-strict semantics"),", to serve\nas a unifying language for future research in functional language design."),(0,i.kt)("p",null,"In GHC Haskell, we use a ",(0,i.kt)("em",{parentName:"p"},"lazy evaluation strategy")," to implement non-strict\nsemantics (We've talked about laziness\n",(0,i.kt)("a",{parentName:"p",href:"/learn-haskell-blog-generator/markup/parsing-01#laziness"},"before"),")."),(0,i.kt)("p",null,"The requirement for non-strict semantics raises interesting challenges:\nHow do we design a language that can do more than just evaluate expressions,\nhow do we model interaction with the outside world, how do we do I/O?"),(0,i.kt)("p",null,"The challenge with doing I/O operations in a language with a lazy evaluation strategy\nis that as programs grow larger, the order of evaluation becomes less trivial to\nfigure out. Consider this hypothetical code example\n(which won't actually type-check in Haskell, we'll see why soon):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"addWithInput :: Int -> Int\naddWithInput n = readIntFromStdin + n\n\nmain =\n  let\n    result1 = addWithInput 1\n    result2 = addWithInput 2\n  in\n    print (result2 - result1)\n")),(0,i.kt)("p",null,"This hypothetical program will read 2 integers from the standard input,\nand then will subtract the second one (+2) from the first one (+1),\nor so we would expect if this was a strict language. In a strict language\nwe expect the order of operations to happen from the top-down."),(0,i.kt)("p",null,"But in a lazy language we don't evaluate an expression until\nit is needed, and so neither ",(0,i.kt)("inlineCode",{parentName:"p"},"result1")," nor ",(0,i.kt)("inlineCode",{parentName:"p"},"result2")," are evaluated\nuntil we wish to print the result of subtracting one from the other.\nAnd then when we try to evaluate ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),", it evaluates the two arguments\nfrom left to right, so we first evaluate ",(0,i.kt)("inlineCode",{parentName:"p"},"result2"),"."),(0,i.kt)("p",null,"Evaluating ",(0,i.kt)("inlineCode",{parentName:"p"},"result2"),", with substitution, means to replace occurrences of ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),"\nwith the input ",(0,i.kt)("inlineCode",{parentName:"p"},"2"),", and then evaluate the top level function (",(0,i.kt)("inlineCode",{parentName:"p"},"+"),"), which is a\nprimitive function. We then evaluate its arguments, ",(0,i.kt)("inlineCode",{parentName:"p"},"readIntFromStdin"),"\nand then ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),"; at this point ",(0,i.kt)("em",{parentName:"p"},"we are reading the first integer from the stdin"),"."),(0,i.kt)("p",null,"After calculating the result, we can move to evaluate ",(0,i.kt)("inlineCode",{parentName:"p"},"result1"),", which\n",(0,i.kt)("em",{parentName:"p"},"will read the second integer from stdin"),". This is the\ncomplete opposite of what we wanted!"),(0,i.kt)("p",null,"Issues like these make lazy evaluation hard to work with in the presence of\n",(0,i.kt)("strong",{parentName:"p"},"side effects")," - when the evaluation of an expression ",(0,i.kt)("em",{parentName:"p"},"can affect or be affected\nby the outside world"),", this includes reading/writing from mutable memory\nor performing I/O operations."),(0,i.kt)("p",null,"We call functions that have side-effects, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"addWithInput"),", ",(0,i.kt)("strong",{parentName:"p"},"impure functions"),".\nAnd an unfortunate consequence of impure functions is that\n",(0,i.kt)("strong",{parentName:"p"},"they can return different results even when they take the same input"),"."),(0,i.kt)("p",null,"The presence of impure functions makes it harder for us to reason about lazy evaluation,\nand also messes up our ability to use ",(0,i.kt)("strong",{parentName:"p"},"equational reasoning")," to understand programs."),(0,i.kt)("p",null,"Therefore, in Haskell, it was decided to only allow ",(0,i.kt)("strong",{parentName:"p"},"pure")," functions and expressions - ones that\nhave ",(0,i.kt)("strong",{parentName:"p"},"no side effects"),". Pure functions will ",(0,i.kt)("em",{parentName:"p"},"always")," return the same output (given the same input)\nand ",(0,i.kt)("strong",{parentName:"p"},"evaluating pure expressions is deterministic"),"."),(0,i.kt)("p",null,"But now, how can we do I/O operations? There are many possible solutions"),(0,i.kt)("p",null,"For Haskell it was decided to design an interface\nwith an accompanied type called ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),"'s interface will force a distinction\nfrom non-I/O expressions, and will also require that in order to ",(0,i.kt)("em",{parentName:"p"},"combine"),"\nmultiple ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," operations, we will have to ",(0,i.kt)("strong",{parentName:"p"},"specify the order the operations"),"."),(0,i.kt)("h2",{id:"io"},"IO"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"IO")," is an opaque type, like our ",(0,i.kt)("inlineCode",{parentName:"p"},"Html")," type in which we hide its internal\nrepresentation from the user behind an interface. But in this case ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," is a\nbuilt-in type that is hidden by the Haskell language rather than a module."),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," has a payload type which represents the\nresult of an ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," operation.\nWhen there isn't a meaningful result, we use the unit type,\n",(0,i.kt)("inlineCode",{parentName:"p"},"()")," (which only has one value: ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),") to represent that."),(0,i.kt)("p",null,"Here are a few ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," operations and functions that return ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," operations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"putStrLn :: String -> IO ()\n\ngetLine :: IO String\n\ngetArgs :: IO [String]\n\nlookupEnv :: String -> IO (Maybe String)\n\nwriteFile :: FilePath -> String -> IO ()\n")),(0,i.kt)("p",null,"Notice that each function returns an ",(0,i.kt)("inlineCode",{parentName:"p"},"IO <something>"),", but what does that mean?"),(0,i.kt)("p",null,"The meaning behind ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a")," is that it is a ",(0,i.kt)("em",{parentName:"p"},"description of a program (or subroutine)\nthat when executed will produce some value of type ",(0,i.kt)("inlineCode",{parentName:"em"},"a"),", and may do some I/O effects\nduring execution"),"."),(0,i.kt)("p",null,"Executing an ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a")," is different from evaluating it.\nEvaluating an ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a")," expression is pure - the ",(0,i.kt)("strong",{parentName:"p"},"evaluation")," will always reduce to\nthe same ",(0,i.kt)("strong",{parentName:"p"},"description")," of a program. This helps us keep purity and equational reasoning!"),(0,i.kt)("p",null,"The Haskell runtime will ",(0,i.kt)("em",{parentName:"p"},"execute")," the entry point to the program\n(the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"main"),", that must have the type ",(0,i.kt)("inlineCode",{parentName:"p"},"IO ()"),") in order for our IO operation\nto also run - it has to be ",(0,i.kt)("em",{parentName:"p"},"combined into")," the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," expression - let's see what that means."),(0,i.kt)("h2",{id:"combining-io-expressions"},"Combining IO expressions"),(0,i.kt)("p",null,"Just like our ",(0,i.kt)("inlineCode",{parentName:"p"},"Html.Structure")," type, the IO interface provides ",(0,i.kt)("strong",{parentName:"p"},"combinators")," for composing\nsmall ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," operations into bigger ones. This interface also ensures that the order\nof operations is well defined!"),(0,i.kt)("p",null,"Note that, just like the ",(0,i.kt)("inlineCode",{parentName:"p"},"<>")," we've defined for ",(0,i.kt)("inlineCode",{parentName:"p"},"Html.Structure"),", the combinators for ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),"\nare implemented as ",(0,i.kt)("strong",{parentName:"p"},"type-class instances")," rather than specialized variants\n(for example our ",(0,i.kt)("inlineCode",{parentName:"p"},"append_")," function was a specialized version of ",(0,i.kt)("inlineCode",{parentName:"p"},"<>")," tailored only\nfor ",(0,i.kt)("inlineCode",{parentName:"p"},"Structure"),")."),(0,i.kt)("p",null,"In this section I will introduce specialized type signatures rather than generalized ones,\nbecause I think it'll be easier to digest, but we'll talk about the generalized versions\nlater."),(0,i.kt)("h3",{id:""},">>="),(0,i.kt)("p",null,"Our first combinator is ",(0,i.kt)("inlineCode",{parentName:"p"},">>=")," (pronounced bind), and is the most useful of the bunch:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"(>>=) :: IO a -> (a -> IO b) -> IO b\n")),(0,i.kt)("p",null,"This combinator takes two arguments, the first is an IO operation, and the second is\na function that takes as input ",(0,i.kt)("em",{parentName:"p"},"the result of the first IO operation")," and returns\na new ",(0,i.kt)("inlineCode",{parentName:"p"},"IO b")," which is the final result."),(0,i.kt)("p",null,"Here are a few examples using the functions we described above:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Echo"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"getLine >>= (\\line -> putStrLn line)\n")),(0,i.kt)("p",{parentName:"li"},"We are reading a line from the standard input on the left of ",(0,i.kt)("inlineCode",{parentName:"p"},">>="),",\nwe receive the input to the right of ",(0,i.kt)("inlineCode",{parentName:"p"},">>=")," as an argument to the lambda function,\nand then write it to the standard output in the body of the lambda function.\n",(0,i.kt)("inlineCode",{parentName:"p"},">>="),"'s role here is to ",(0,i.kt)("strong",{parentName:"p"},"pass the result of the IO operation\non the left to the function returning an IO operation on the right"),"."),(0,i.kt)("p",{parentName:"li"},"Notice how ",(0,i.kt)("inlineCode",{parentName:"p"},">>=")," ",(0,i.kt)("em",{parentName:"p"},"defines an order of operations - from left to right"),"."),(0,i.kt)("p",{parentName:"li"},"The type of each sub expression here is:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"getLine :: IO String\n\nputStrLn :: String -> IO ()\n\n(>>=) :: IO String -> (String -> IO ()) -> IO ()\n\nline :: String\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Question: what is the type of the whole expression? ",(0,i.kt)("details",null,(0,i.kt)("summary",null,"Answer"),"IO ()"))),(0,i.kt)("p",{parentName:"li"},"Also note that this example can be written in a more concise manner\nin point free style ",(0,i.kt)("inlineCode",{parentName:"p"},"getLine >>= putStrLn"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Appending two inputs"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'getLine >>= (\\honorific -> getLine >>= (\\name -> putStrLn ("Hello " ++ honorific ++ " " ++ name)))\n')),(0,i.kt)("p",{parentName:"li"},"This subroutine combines multiple operations together, it reads two lines from\nthe standard input and prints a greeting.\nNote that:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Using ",(0,i.kt)("inlineCode",{parentName:"li"},">>=")," defines the order of operation from left to right"),(0,i.kt)("li",{parentName:"ul"},"Because of the scoping rules in Haskell, ",(0,i.kt)("inlineCode",{parentName:"li"},"honorific")," will be in scope\nin the body of the function for which it is its input, including the most inner function")),(0,i.kt)("p",{parentName:"li"},"This is a bit hard to read, but we can remove the parenthesis and add indentation to make it a bit easier to read:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'getLine >>= \\honorific ->\n  getLine >>= \\name ->\n    putStrLn ("Hello " ++ honorific ++ " " ++ name)\n')))),(0,i.kt)("p",null,"Let's see a few more combinators!"),(0,i.kt)("h3",{id:"-and-"},"*> and >>"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"(*>) :: IO a -> IO b -> IO b\n(>>) :: IO a -> IO b -> IO b\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"*>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},">>")," have the same type signature for ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," and mean the same thing.\nIn fact, ",(0,i.kt)("inlineCode",{parentName:"p"},"*>")," is a slightly more generalized version of ",(0,i.kt)("inlineCode",{parentName:"p"},">>")," and can always\nbe used instead of ",(0,i.kt)("inlineCode",{parentName:"p"},">>"),", which only still exists to avoid breaking backward\ncompatibility."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"*>")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," means run the first IO operation, discard the result\nthen run the second operation. It can be implemented using ",(0,i.kt)("inlineCode",{parentName:"p"},">>="),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"a *> b = a >>= \\_ -> b\n")),(0,i.kt)("p",null,"This combinator is useful when we want to run several ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," operations one after\nthe other that might not return anything meaningful, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"putStrLn"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'putStrLn "hello" *> putStrLn "world"\n')),(0,i.kt)("h3",{id:"pure-and-return"},"pure and return"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"pure :: a -> IO a\n")),(0,i.kt)("p",null,"like ",(0,i.kt)("inlineCode",{parentName:"p"},"*>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},">>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"pure")," is a more general version of ",(0,i.kt)("inlineCode",{parentName:"p"},"return"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"pure")," also has the\nadvantage of not having a resemblance to an unrelated keyword in other languages."),(0,i.kt)("p",null,"Remember that we said ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a")," is a description of a program\nthat when executed will produce some value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and may do some I/O effects\nduring execution?"),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"pure"),", we can build an ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a")," that does no I/O, and will produce a\nspecific value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", the one we supply to ",(0,i.kt)("inlineCode",{parentName:"p"},"pure"),"!"),(0,i.kt)("p",null,"This function is useful when we want to do some uneffectful computation that depends on ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),"."),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'confirm :: IO Bool\nconfirm =\n  putStrLn "Are you sure? (y/n)" *>\n    getLine >>= \\answer ->\n      case answer of\n        "y" -> pure True\n        "n" -> pure False\n        _ ->\n          putStrLn "Invalid response. use y or n" *>\n            confirm\n')),(0,i.kt)("p",null,"Trying to return just ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," here wouldn't work because of the\ntype of ",(0,i.kt)("inlineCode",{parentName:"p"},">>="),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"(>>=) :: IO a -> (a -> IO b) -> IO b\n")),(0,i.kt)("p",null,"The right side of ",(0,i.kt)("inlineCode",{parentName:"p"},">>=")," in our code example (",(0,i.kt)("inlineCode",{parentName:"p"},"\\answer -> case ..."),") must\nbe of type ",(0,i.kt)("inlineCode",{parentName:"p"},"String -> IO Bool"),". This is because:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"getLine :: IO String"),", so the ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," in the type signature of ",(0,i.kt)("inlineCode",{parentName:"li"},">>="),"\nshould be the same as ",(0,i.kt)("inlineCode",{parentName:"li"},"String")," in this instance, and"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"confirm :: IO Bool"),", so ",(0,i.kt)("inlineCode",{parentName:"li"},"b")," should be ",(0,i.kt)("inlineCode",{parentName:"li"},"Bool"))),(0,i.kt)("h3",{id:"fmap-and-"},"fmap and <$>"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"fmap :: (a -> b) -> IO a -> IO b\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"<$>")," is the infix version of ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap"),". Use it at your discretion."),(0,i.kt)("p",null,"What if we want a function that reads a line from stdin\nand returns it with ",(0,i.kt)("inlineCode",{parentName:"p"},"!")," at the end? We could use a combination\nof ",(0,i.kt)("inlineCode",{parentName:"p"},">>=")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"pure"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'getLine >>= \\line -> pure (line ++ "!")\n')),(0,i.kt)("p",null,"The pattern is unified to the ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'fmap (\\line -> line ++ "!") getLine\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"fmap")," applies a function to the value to be returned\nfrom the ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),' operation, also known as "mapping" over it.'),(0,i.kt)("p",null,"(By the way, Have you noticed the similarities between ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"map :: (a -> b) -> [a] -> [b]"),"?)"),(0,i.kt)("h3",{id:"summary"},"Summary"),(0,i.kt)("p",null,"Here's a list of ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," combinators we ran into:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'-- chaining IO operations: passing the *result* of the left IO operation\n-- as an argument to the function on the right.\n-- Pronounced "bind".\n(>>=) :: IO a -> (a -> IO b) -> IO b\n\n-- sequence two IO operations, discarding the payload of the first.\n(*>) :: IO a -> IO b -> IO b\n\n-- "lift" a value into IO context, does not add any I/O effects.\npure :: a -> IO a\n\n-- "map" (or apply a function) over the payload value of an IO operation.\nfmap :: (a -> b) -> IO a -> IO b\n')),(0,i.kt)("h2",{id:"io-is-first-class"},"IO is first class"),(0,i.kt)("p",null,"The beauty of ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," is that it's a completely first-class construct in the language,\nand is not really different from ",(0,i.kt)("inlineCode",{parentName:"p"},"Maybe"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Either")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Structure"),". We can pass it to\nfunctions, put it in a container, etc. Remember that it represents a description\nof a program, and without combining it into ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," in some way won't actually\n",(0,i.kt)("em",{parentName:"p"},"do")," anything. It is just a value!"),(0,i.kt)("p",null,"Here's an example of a function that takes IO actions as input:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"whenIO :: IO Bool -> IO () -> IO ()\nwhenIO cond action =\n  cond >>= \\result ->\n    if result\n      then action\n      else pure ()\n")),(0,i.kt)("p",null,"And how it can be used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'main :: IO ()\nmain =\n  putStrLn "This program will tell you a secret" *>\n    whenIO confirm (putStrLn "IO is actually pretty awesome") *>\n      putStrLn "Bye"\n')),(0,i.kt)("p",null,"Notice how ",(0,i.kt)("inlineCode",{parentName:"p"},'putStrLn "IO is actually pretty awesome"')," isn't executed\nright away, but only if it is what ",(0,i.kt)("inlineCode",{parentName:"p"},"whenIO")," returns, and in turn is ",(0,i.kt)("em",{parentName:"p"},"combined"),"\nwith ",(0,i.kt)("inlineCode",{parentName:"p"},"*>")," as part of the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," expression."),(0,i.kt)("h2",{id:"getting-out-of-io"},"Getting out of IO?"),(0,i.kt)("p",null,"What we've seen above has great consequences to the Haskell language.\nIn our ",(0,i.kt)("inlineCode",{parentName:"p"},"Html")," type, we had a function ",(0,i.kt)("inlineCode",{parentName:"p"},"render :: Html -> String"),"\nthat could turn an ",(0,i.kt)("inlineCode",{parentName:"p"},"Html")," to a string value."),(0,i.kt)("p",null,"In Haskell, ",(0,i.kt)("strong",{parentName:"p"},"there is no way")," to implement a function such as ",(0,i.kt)("inlineCode",{parentName:"p"},"execute :: IO a -> a"),"\nthat preserves purity and equational reasoning!"),(0,i.kt)("p",null,"Also, ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," is ",(0,i.kt)("em",{parentName:"p"},"opaque"),". It does not let us examine it. So we are really bound\nto what the Haskell API for ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," allows us to do."),(0,i.kt)("p",null,"This means that ",(0,i.kt)("strong",{parentName:"p"},"we need to think about using IO differently"),"!"),(0,i.kt)("p",null,"In Haskell, once we get into ",(0,i.kt)("inlineCode",{parentName:"p"},"IO"),", there is no getting out.\nThe only thing we can do is to build bigger IO computations by ",(0,i.kt)("em",{parentName:"p"},"combining"),"\nit with more IO computations."),(0,i.kt)("p",null,"We also can't use ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a")," in place of an ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),". For example,\nwe can't write ",(0,i.kt)("inlineCode",{parentName:"p"},'getLine ++ "!"')," because ",(0,i.kt)("inlineCode",{parentName:"p"},"++")," expects both\nsides to be ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),", but ",(0,i.kt)("inlineCode",{parentName:"p"},"getLine"),"'s type is ",(0,i.kt)("inlineCode",{parentName:"p"},"IO String"),". The types do not match!\nWe have to use ",(0,i.kt)("inlineCode",{parentName:"p"},"fmap")," and the return type must be ",(0,i.kt)("inlineCode",{parentName:"p"},"IO String"),", like we've seen before."),(0,i.kt)("p",null,"In Haskell we like to keep ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," usage minimal, and we like to push it to the edges\nof the program. This pattern is often called ",(0,i.kt)("em",{parentName:"p"},"Functional core, imperative shell"),"."),(0,i.kt)("h2",{id:"functional-core-imperative-shell"},"Functional core, imperative shell"),(0,i.kt)("p",null,"In our blog generator program, we want to read a file, parse it, convert it to HTML,\nand then print the result to the console."),(0,i.kt)("p",null,"In many programming languages, we might interleave reading from the file with parsing,\nand writing to the file with the HTML conversion. But we don't mix these here.\nParsing operates on a ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," value rather than some file handle,\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"Html")," is being converted to a ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," rather than being written to the screen directly."),(0,i.kt)("p",null,"This approach of separating ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," and pushing it to the edge of the program gives us\na lot of flexibility. These functions without ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," are easier to test and examine\n(because they are guaranteed to have deterministic evaluation!),\nand they are more modular and can work in many contexts (reading from stdin,\nreading from network socket, writing to an HTTP connection, and more)."),(0,i.kt)("p",null,"This pattern is often a good approach for building Haskell programs, especially\nbatch programs."),(0,i.kt)("h2",{id:"building-a-blog-generator"},"Building a blog generator"),(0,i.kt)("p",null,"We'd like to start building a blog generator, and we want to have the following\ninterface:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"If the user calls the program without arguments, we will read from\nthe standard input, and write to the standard output"),(0,i.kt)("li",{parentName:"ol"},"If the user calls the program with two arguments, the first one\nwill be the input file name, and the second one\nwill be the output file name"),(0,i.kt)("li",{parentName:"ol"},"If the output file already exists, we'll ask the user if they want\nto overwrite the file"),(0,i.kt)("li",{parentName:"ol"},"On any other kind of input, we'll print a generic message explaining\nthe proper usage")),(0,i.kt)("p",null,"We are going to need a few functions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"getArgs :: IO [String] -- Get the program arguments\n\ngetContents :: IO String -- Read all of the content from stdin\n\nreadFile :: FilePath -> IO String -- Read all of the content from a file\n\nwriteFile :: FilePath -> String -> IO () -- Write a string into a file\n\ndoesFileExist :: FilePath -> IO Bool -- Checks whether a file exists\n")),(0,i.kt)("p",null,"And the following imports:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"import System.Directory (doesFileExist)\nimport System.Environment (getArgs)\n")),(0,i.kt)("p",null,"We don't need to add the following import because ",(0,i.kt)("inlineCode",{parentName:"p"},"Prelude")," already imports\nthese functions for us:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"-- imported by Prelude\nimport System.IO (getContents, readFile, writeFile)\n")),(0,i.kt)("hr",null),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Implement a function ",(0,i.kt)("inlineCode",{parentName:"li"},"process :: Title -> String -> String")," which will parse\na document to markup, convert it to HTML, and then render the HTML to a string.")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Answer"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"process :: Html.Title -> String -> String\nprocess title = Html.render . convert title . Markup.parse\n"))),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},'Try implementing the "imperative shell" for our blog generator program.\nStart with ',(0,i.kt)("inlineCode",{parentName:"li"},"main"),", pattern match on the result of ",(0,i.kt)("inlineCode",{parentName:"li"},"getArgs"),", and decide what to\ndo. Look back at the examples above for inspiration.")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Answer"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'-- Main.hs\nmodule Main where\n\nimport qualified Markup\nimport qualified Html\nimport Convert (convert)\n\nimport System.Directory (doesFileExist)\nimport System.Environment (getArgs)\n\nmain :: IO ()\nmain =\n  getArgs >>= \\args ->\n    case args of\n      -- No program arguments: reading from stdin and writing to stdout\n      [] ->\n        getContents >>= \\content ->\n          putStrLn (process "Empty title" content)\n\n      -- With input and output file paths as program arguments\n      [input, output] ->\n        readFile input >>= \\content ->\n          doesFileExist output >>= \\exists ->\n            let\n              writeResult = writeFile output (process input content)\n            in\n              if exists\n                then whenIO confirm writeResult\n                else writeResult\n\n      -- Any other kind of program arguments\n      _ ->\n        putStrLn "Usage: runghc Main.hs [-- <input-file> <output-file>]"\n\nprocess :: Html.Title -> String -> String\nprocess title = Html.render . convert title . Markup.parse\n\nconfirm :: IO Bool\nconfirm =\n  putStrLn "Are you sure? (y/n)" *>\n    getLine >>= \\answer ->\n      case answer of\n        "y" -> pure True\n        "n" -> pure False\n        _ -> putStrLn "Invalid response. use y or n" *>\n          confirm\n\nwhenIO :: IO Bool -> IO () -> IO ()\nwhenIO cond action =\n  cond >>= \\result ->\n    if result\n      then action\n      else pure ()\n'))),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"do-notation"},"Do notation"),(0,i.kt)("p",null,"While using ",(0,i.kt)("inlineCode",{parentName:"p"},">>=")," to chain ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," actions is manageable, Haskell provides\nan even more convenient syntactic sugar called ",(0,i.kt)("em",{parentName:"p"},"do notation"),"\nwhich emulates imperative programming."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"do block")," starts with the ",(0,i.kt)("inlineCode",{parentName:"p"},"do"),' keyword, and continues with one or more\n"statements" which can be one of the following:'),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"An expression of type ",(0,i.kt)("inlineCode",{parentName:"li"},"IO ()"),", such as:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'putStrLn "Hello"')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'if True then putStrLn "Yes" else putStrLn "No"')))),(0,i.kt)("li",{parentName:"ol"},"A let block, such as",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"let x = 1")),(0,i.kt)("li",{parentName:"ul"},"or multiple let declarations:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"let\n  x = 1\n  y = 2\n")),"Note that we do not write the ",(0,i.kt)("inlineCode",{parentName:"li"},"in")," here."))),(0,i.kt)("li",{parentName:"ol"},"A binding ",(0,i.kt)("inlineCode",{parentName:"li"},"<variable> <- <expresion>"),", such as",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"line <- getLine\n")))),(0,i.kt)("p",null,'And the last "statement" must be an expression of type ',(0,i.kt)("inlineCode",{parentName:"p"},"IO <something>")," -\nthis will be the result type of the do block."),(0,i.kt)("p",null,"These constructs are desugared (translated) by the Haskell compiler to:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"<expression> *>"),","),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"let ... in")," and"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"<expression> >>= \\<variable>"))),(0,i.kt)("p",null,"respectively."),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'greeting :: IO ()\ngreeting = do\n  putStrLn "Tell me your name."\n  let greet name = "Hello, " ++ name ++ "!"\n  name <- getLine\n  putStrLn (greet name)\n')),(0,i.kt)("p",null,"Is just syntactic sugar for:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'greeting :: IO ()\ngreeting =\n  putStrLn "Tell me your name." *>\n    let\n      greet name = "Hello, " ++ name ++ "!"\n    in\n      getLine >>= \\name ->\n        putStrLn (greet name)\n')),(0,i.kt)("p",null,"It's important to note the difference between ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<-")," (bind).\n",(0,i.kt)("inlineCode",{parentName:"p"},"let")," is used to give a new name to an expression which will be in scope\nfor subsequent lines, and ",(0,i.kt)("inlineCode",{parentName:"p"},"<-")," is used to bind the result ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," in an ",(0,i.kt)("inlineCode",{parentName:"p"},"IO a"),"\naction to a new name which will be in scope for subsequent lines."),(0,i.kt)("p",null,"Do notation is very very common and is often preferable to using ",(0,i.kt)("inlineCode",{parentName:"p"},">>=")," directly."),(0,i.kt)("hr",null),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Exercise: Translate the examples in this chapter to ",(0,i.kt)("em",{parentName:"p"},"do notation"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Exercise: Translate our glue code for the blog generator to ",(0,i.kt)("em",{parentName:"p"},"do notation"),"."))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'-- Main.hs\nmodule Main where\n\nimport qualified Markup\nimport qualified Html\nimport Convert (convert)\n\nimport System.Directory (doesFileExist)\nimport System.Environment (getArgs)\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  case args of\n    -- No program arguments: reading from stdin and writing to stdout\n    [] -> do\n      content <- getContents\n      putStrLn (process "Empty title" content)\n\n    -- With input and output file paths as program arguments\n    [input, output] -> do\n      content <- readFile input\n      exists <- doesFileExist output\n      let\n        writeResult = writeFile output (process input content)\n      if exists\n        then whenIO confirm writeResult\n        else writeResult\n\n    -- Any other kind of program arguments\n    _ ->\n      putStrLn "Usage: runghc Main.hs [-- <input-file> <output-file>]"\n\nprocess :: Html.Title -> String -> String\nprocess title = Html.render . convert title . Markup.parse\n\nconfirm :: IO Bool\nconfirm = do\n  putStrLn "Are you sure? (y/n)"\n  answer <- getLine\n  case answer of\n    "y" -> pure True\n    "n" -> pure False\n    _ -> do\n      putStrLn "Invalid response. use y or n"\n      confirm\n\nwhenIO :: IO Bool -> IO () -> IO ()\nwhenIO cond action = do\n  result <- cond\n  if result\n    then action\n    else pure ()\n'))),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"summary-1"},"Summary"),(0,i.kt)("p",null,'In this chapter we discussed what "purely functional" means,\nwhere the initial motivation for being purely functional comes from,\nand how Haskell\'s I/O interface allows us to create descriptions of programs\nwithout breaking purity.'),(0,i.kt)("p",null,"We have also achieved a major milestone. With this chapter, we have implemented\nenough pieces to finally run our program on a single document\nand get an HTML rendered result!"),(0,i.kt)("p",null,"However, our command-line interface is still sub-par. We want to render a blog\nwith multiple articles, create an index page, and more. We still have more to do\nto be able to call our program a blog generator."),(0,i.kt)("p",null,"Let's keep going!"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"You can view the git commit of\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/commit/908e7173cf32de5ce8507e43a1fb9124fc5d63f4"},"the changes we've made"),"\nand the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/soupi/learn-haskell-blog-generator/tree/908e7173cf32de5ce8507e43a1fb9124fc5d63f4"},"code up until now"),".")))}d.isMDXComponent=!0}}]);