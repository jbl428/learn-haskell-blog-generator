"use strict";(self.webpackChunklearn_haskell_blog_generator=self.webpackChunklearn_haskell_blog_generator||[]).push([[385],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>c});var a=t(7294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},k=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,r=e.originalType,p=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=s(t),k=l,c=m["".concat(p,".").concat(k)]||m[k]||d[k]||r;return t?a.createElement(c,i(i({ref:n},u),{},{components:t})):a.createElement(c,i({ref:n},u))}));function c(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var r=t.length,i=new Array(r);i[0]=k;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[m]="string"==typeof e?e:l,i[1]=o;for(var s=2;s<r;s++)i[s]=t[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}k.displayName="MDXCreateElement"},1596:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var a=t(7462),l=(t(7294),t(3905));const r={},i="\ub9c8\ud06c\uc5c5 \ud30c\uc2f1\ud558\uae30 01 (\uc7ac\uadc0)",o={unversionedId:"markup/parsing-01",id:"markup/parsing-01",title:"\ub9c8\ud06c\uc5c5 \ud30c\uc2f1\ud558\uae30 01 (\uc7ac\uadc0)",description:"\uc774\uc804 \uc7a5\uc5d0\uc11c \uc815\uc758\ud55c Document \ud0c0\uc785\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc0ac\uc6a9\uc790\uac00 \uc791\uc131\ud55c \uc5ec\ub7ec \uc904\uc758 \ub9c8\ud06c\uc5c5 \ud14d\uc2a4\ud2b8\ub97c \ud30c\uc2f1\ud558\ub294 \ubc29\ubc95\uc744 \uc0b4\ud3b4\ubcf4\uaca0\uc2b5\ub2c8\ub2e4.",source:"@site/docs/04-markup/02-parsing-01.md",sourceDirName:"04-markup",slug:"/markup/parsing-01",permalink:"/learn-haskell-blog-generator/markup/parsing-01",draft:!1,editUrl:"https://github.com/jbl428/learn-haskell-blog-generator/tree/book/docs/04-markup/02-parsing-01.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ud558\uc2a4\ucf08 \ub370\uc774\ud130 \ud0c0\uc785\uc73c\ub85c \ub9c8\ud06c\uc5c5 \uc5b8\uc5b4 \ud45c\ud604\ud558\uae30",permalink:"/learn-haskell-blog-generator/markup/data-type"},next:{title:"Displaying the parsing results (type classes)",permalink:"/learn-haskell-blog-generator/markup/displaying-results"}},p={},s=[{value:"\uc7ac\uadc0\uc640 \uc815\ubcf4 \ub204\uc801",id:"\uc7ac\uadc0\uc640-\uc815\ubcf4-\ub204\uc801",level:2},{value:"\uc7ac\uadc0\uc758 \ud3c9\uac00",id:"\uc7ac\uadc0\uc758-\ud3c9\uac00",level:3},{value:"\uc9c0\uc5f0\uc131",id:"\uc9c0\uc5f0\uc131",level:4},{value:"General recursion",id:"general-recursion",level:3},{value:"Mutual recursion",id:"mutual-recursion",level:3},{value:"Partial functions",id:"partial-functions",level:2},{value:"Parsing markup?",id:"parsing-markup",level:2}],u={toc:s},m="wrapper";function d(e){let{components:n,...t}=e;return(0,l.kt)(m,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"\ub9c8\ud06c\uc5c5-\ud30c\uc2f1\ud558\uae30-01-\uc7ac\uadc0"},"\ub9c8\ud06c\uc5c5 \ud30c\uc2f1\ud558\uae30 01 (\uc7ac\uadc0)"),(0,l.kt)("p",null,"\uc774\uc804 \uc7a5\uc5d0\uc11c \uc815\uc758\ud55c ",(0,l.kt)("inlineCode",{parentName:"p"},"Document")," \ud0c0\uc785\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc0ac\uc6a9\uc790\uac00 \uc791\uc131\ud55c \uc5ec\ub7ec \uc904\uc758 \ub9c8\ud06c\uc5c5 \ud14d\uc2a4\ud2b8\ub97c \ud30c\uc2f1\ud558\ub294 \ubc29\ubc95\uc744 \uc0b4\ud3b4\ubcf4\uaca0\uc2b5\ub2c8\ub2e4."),(0,l.kt)("p",null,"\uc804\ub7b5\uc740 \ub9c8\ud06c\uc5c5 \ubb38\uc790\uc5f4\uc744 \ub2e4\uc74c\uacfc \uac19\uc774 \ucc98\ub9ac\ud558\ub294 \uac83\uc785\ub2c8\ub2e4:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\uac01 \uc904\uc744 \uac1c\ubcc4\uc801\uc778 \uc694\uc18c\ub85c \ubd84\ud560\ud558\uace0"),(0,l.kt)("li",{parentName:"ol"},"\uc694\uc18c\ub97c \uc21c\ud68c\ud558\uba74\uc11c \uc904 \ubcc4\ub85c \ucc98\ub9ac\ud558\uace0, \ud544\uc694\ud558\ub2e4\uba74 \uc774\uc804 \uc904\uc758 \uc815\ubcf4\ub97c \uae30\uc5b5\ud569\ub2c8\ub2e4")),(0,l.kt)("p",null,"\ub530\ub77c\uc11c \ucc98\uc74c \ud574\uc57c\ud560 \uc77c\uc740 \ubb38\uc790\uc5f4\uc744 \uc904 \ub2e8\uc704\ub85c \ucc98\ub9ac\ud558\ub294 \uac83\uc785\ub2c8\ub2e4.\n\uc774\ub97c \uc704\ud574 \ubb38\uc790\uc5f4\uc744 \ubb38\uc790\uc5f4\uc758 \ub9ac\uc2a4\ud2b8\ub85c \ubcc0\ud658\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\ub2e4\ud589\ud788\ub3c4 \ud558\uc2a4\ucf08 \ud45c\uc900 \ub77c\uc774\ube0c\ub7ec\ub9ac ",(0,l.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base"},(0,l.kt)("inlineCode",{parentName:"a"},"base")),"\uc758\n",(0,l.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:lines"},(0,l.kt)("inlineCode",{parentName:"a"},"Prelude")),"\n\ubaa8\ub4c8\uc5d0\uc11c ",(0,l.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:lines"},(0,l.kt)("inlineCode",{parentName:"a"},"lines")),"\n\ud568\uc218\ub97c \uc81c\uacf5\ud558\uace0 \uc788\uc2b5\ub2c8\ub2e4.\n",(0,l.kt)("inlineCode",{parentName:"p"},"Prelude")," \ubaa8\ub4c8\uc740 \uae30\ubcf8\uc801\uc73c\ub85c \ubaa8\ub4e0 \ud558\uc2a4\ucf08 \ud30c\uc77c\uc5d0\uc11c \uc0ac\uc6a9\ud560 \uc218 \uc788\uc73c\ubbc0\ub85c \uac00\uc838\uc62c(import) \ud544\uc694\uac00 \uc5c6\uc2b5\ub2c8\ub2e4."),(0,l.kt)("p",null,"\uc904 \ucc98\ub9ac\ub97c \uc704\ud574, \uba3c\uc800 \ub9c8\ud06c\uc5c5 \ubb38\ubc95\uc740 \ubb34\uc2dc\ud558\uace0 \uc904\uc744 \uadf8\ub8f9\ud654\ud558\uc5ec \ub2e8\ub77d(paragraph)\uc73c\ub85c \ub9cc\ub4e4\uc5b4 \ubcf4\uaca0\uc2b5\ub2c8\ub2e4.\n(\ub2e8\ub77d\uc740 \ube48 \uc904\ub85c \uad6c\ubd84\ub429\ub2c8\ub2e4) \uadf8\ub9ac\uace0 \ub098\uc911\uc5d0 \uc7a5\uc758 \ub4b7\ubd80\ubd84\uc5d0\uc11c \uc0c8\ub85c\uc6b4 \uae30\ub2a5\uc744 \ubc18\ubcf5\uc801\uc73c\ub85c \ucd94\uac00\ud560 \uac83\uc785\ub2c8\ub2e4."),(0,l.kt)("p",null,"\uba85\ub839\ud615 \ud504\ub85c\uadf8\ub7a8\uc5d0\uc11c\uc758 \uc77c\ubc18\uc801\uc778 \ud574\uacb0\ucc45\uc740 ",(0,l.kt)("em",{parentName:"p"},"loop")," \uad6c\uc870\ub97c \uc0ac\uc6a9\ud558\uc5ec \uc21c\ud68c\ud558\uace0 \uadf8\ub8f9\ud654\ud574\uc57c \ud558\ub294 \uc904\uc744 \uc911\uac04 \uac00\ubcc0 \ubcc0\uc218\uc5d0 \ub204\uc801\ud558\ub294 \uac83\uc785\ub2c8\ub2e4.\n\ube48 \uc904\uc5d0 \ub3c4\ub2ec\ud558\uba74 \uadf8 \ubcc0\uc218\uc758 \ub0b4\uc6a9\uc744 \ub2e4\ub978 \uac00\ubcc0 \ubcc0\uc218\uc5d0 \ub204\uc801\ud558\uc5ec \uacb0\uacfc\ub97c \uc800\uc7a5\ud569\ub2c8\ub2e4."),(0,l.kt)("p",null,"\ud558\uc2a4\ucf08\uc758 \uc811\uadfc \ubc29\uc2dd\uc740 \ub8e8\ud504\ub098 \uac00\ubcc0 \ubcc0\uc218\ub97c \uc0ac\uc6a9\ud558\uc9c0 \uc54a\ub294\ub2e4\ub294 \uc810\uc744 \uc81c\uc678\ud558\uace0\ub294 \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4.\n\ud558\uc2a4\ucf08\uc740 \ub300\uc2e0 ",(0,l.kt)("strong",{parentName:"p"},"\uc7ac\uadc0"),"\ub97c \uc0ac\uc6a9\ud569\ub2c8\ub2e4."),(0,l.kt)("h2",{id:"\uc7ac\uadc0\uc640-\uc815\ubcf4-\ub204\uc801"},"\uc7ac\uadc0\uc640 \uc815\ubcf4 \ub204\uc801"),(0,l.kt)("p",null,"loop \ub300\uc2e0, \ud558\uc2a4\ucf08\uc5d0\uc11c\ub294 \uc7ac\uadc0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ubc18\ubcf5\uc744 \ubaa8\ub378\ub9c1\ud569\ub2c8\ub2e4."),(0,l.kt)("p",null,"\ub2e4\uc74c\uacfc \uac19\uc740 \uc778\uc704\uc801\uc778 \uc608\ub97c \uc0dd\uac01\ud574 \ubcf4\uaca0\uc2b5\ub2c8\ub2e4: \ub450 \uac1c\uc758 \uc790\uc5f0\uc218\ub97c \ub354\ud558\ub294 \uc54c\uace0\ub9ac\uc998\uc774 \ud544\uc694\ud558\ub2e4\uace0 \uac00\uc815\ud574 \ubcf4\uaca0\uc2b5\ub2c8\ub2e4.\n\ud558\uc9c0\ub9cc \uc77c\ubc18\uc801\uc778 \ub367\uc148 \uc5f0\uc0b0\uc790 ",(0,l.kt)("inlineCode",{parentName:"p"},"+"),"\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uace0, \uac01 \uc22b\uc790\uc5d0 \ub300\ud574 ",(0,l.kt)("inlineCode",{parentName:"p"},"increment"),"\uc640 ",(0,l.kt)("inlineCode",{parentName:"p"},"decrement"),"\ub77c\ub294 \ub450 \uac1c\uc758 \uc5f0\uc0b0\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4."),(0,l.kt)("p",null,'\uc774 \ubb38\uc81c\ub97c \ud574\uacb0\ud558\uae30 \uc704\ud55c \ubc29\ubc95\uc740 \ud558\ub098\uc758 \uc22b\uc790\ub97c \ub2e4\ub978 \uc22b\uc790\ub85c \uc810\uc9c4\uc801\uc73c\ub85c "\uc804\ub2ec"\ud558\ub294 \uac83\uc785\ub2c8\ub2e4.\n\uc989, \ud558\ub098\ub97c \uc99d\uac00\uc2dc\ud0a4\uace0 \ub2e4\ub978 \ud558\ub098\ub97c \uac10\uc18c\uc2dc\ud0a4\uace0, \uc774\ub97c \ubc18\ubcf5\ud558\uc5ec \ub450 \ubc88\uc9f8 \uc22b\uc790\uac00 0\uc774 \ub420 \ub54c\uae4c\uc9c0 \uc218\ud589\ud569\ub2c8\ub2e4.'),(0,l.kt)("p",null,"\uc608\ub97c \ub4e4\uc5b4 ",(0,l.kt)("inlineCode",{parentName:"p"},"3"),"\uacfc ",(0,l.kt)("inlineCode",{parentName:"p"},"2"),"\ub97c \ub354\ud55c\ub2e4\uace0 \uac00\uc815\ud574 \ubcf4\uaca0\uc2b5\ub2c8\ub2e4:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"3"),"\uacfc ",(0,l.kt)("inlineCode",{parentName:"li"},"2"),"\ub97c \uc2dc\uc791\uc73c\ub85c \ud569\ub2c8\ub2e4. ",(0,l.kt)("inlineCode",{parentName:"li"},"3"),"\uc744 \uc99d\uac00\uc2dc\ud0a4\uace0 ",(0,l.kt)("inlineCode",{parentName:"li"},"2"),"\ub97c \uac10\uc18c\uc2dc\ud0b5\ub2c8\ub2e4."),(0,l.kt)("li",{parentName:"ul"},"\ub2e4\uc74c \ub2e8\uacc4\uc5d0\uc11c\ub294 ",(0,l.kt)("inlineCode",{parentName:"li"},"4"),"\uc640 ",(0,l.kt)("inlineCode",{parentName:"li"},"1"),"\uc774 \ub429\ub2c8\ub2e4. ",(0,l.kt)("inlineCode",{parentName:"li"},"4"),"\ub97c \uc99d\uac00\uc2dc\ud0a4\uace0 ",(0,l.kt)("inlineCode",{parentName:"li"},"1"),"\uc744 \uac10\uc18c\uc2dc\ud0b5\ub2c8\ub2e4."),(0,l.kt)("li",{parentName:"ul"},"\ub2e4\uc74c \ub2e8\uacc4\uc5d0\uc11c\ub294 ",(0,l.kt)("inlineCode",{parentName:"li"},"5"),"\uc640 ",(0,l.kt)("inlineCode",{parentName:"li"},"0"),"\uc774 \ub429\ub2c8\ub2e4. ",(0,l.kt)("inlineCode",{parentName:"li"},"2"),"\uac00 ",(0,l.kt)("inlineCode",{parentName:"li"},"0"),"\uc774\ubbc0\ub85c ",(0,l.kt)("inlineCode",{parentName:"li"},"5"),"\ub97c \uacb0\uacfc\ub85c \ubc18\ud658\ud569\ub2c8\ub2e4.")),(0,l.kt)("p",null,"\uc774\ub97c \uba85\ub839\ud615\uc73c\ub85c \uc791\uc131\ud558\uba74 \ub2e4\uc74c\uacfc \uac19\uc2b5\ub2c8\ub2e4:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"function add(n, m) {\n  while ((m /= 0)) {\n    n = increment(n);\n    m = decrement(m);\n  }\n  return n;\n}\n")),(0,l.kt)("p",null,"\ud558\uc2a4\ucf08\uc5d0\uc11c\ub294 \ubcc0\uc218\uc758 \ubcc0\uacbd\uc5c6\uc774 \uc7ac\uadc0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ub3d9\uc77c\ud55c \uc54c\uace0\ub9ac\uc998\uc744 \uc791\uc131\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"add n m =\n  if m /= 0\n    then add (increment n) (decrement m)\n    else n\n")),(0,l.kt)("p",null,"\ud558\uc2a4\ucf08\uc5d0\uc11c\ub294 ",(0,l.kt)("em",{parentName:"p"},"\uac00\ubcc0 \uc0c1\ud0dc\ub97c \ud65c\uc6a9\ud574 \ubc18\ubcf5\uc744 \uad6c\ud604"),"\ud558\ub294 \ub300\uc2e0, \ud568\uc218\ub97c \ub2e4\uc2dc \ud638\ucd9c\ud558\uc5ec \ubcc0\uc218\uc758 \uac12\uc744 \ub2e4\uc74c \ubc18\ubcf5\uc5d0 \uc0ac\uc6a9\ud558\ub3c4\ub85d \ud569\ub2c8\ub2e4."),(0,l.kt)("h3",{id:"\uc7ac\uadc0\uc758-\ud3c9\uac00"},"\uc7ac\uadc0\uc758 \ud3c9\uac00"),(0,l.kt)("p",null,"\ubc30\uadc0\ub294 \uc77c\ubc18\uc801\uc73c\ub85c loop\ubcf4\ub2e4 \ub290\ub9ac\uace0, \uc548\uc804\ud558\uc9c0 \uc54a\ub2e4\uace0 \uc54c\ub824\uc838 \uc788\uc2b5\ub2c8\ub2e4.\n\uc774\ub294 \uba85\ub839\ud615 \uc5b8\uc5b4\uc5d0\uc11c \ud568\uc218 \ud638\ucd9c\uc774 \uc0c8\ub85c\uc6b4 \ud638\ucd9c \uc2a4\ud0dd\uc744 \uc0dd\uc131\uc744 \uc694\uad6c\ud558\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4."),(0,l.kt)("p",null,"\uadf8\ub7ec\ub098 \ud568\uc218\ud615 \uc5b8\uc5b4(\ud2b9\ud788 \ud558\uc2a4\ucf08)\ub294 \ub2e4\ub978 \uaddc\uce59\uc744 \ub530\ub974\uba70, ",(0,l.kt)("em",{parentName:"p"},"\uaf2c\ub9ac \ud638\ucd9c \uc81c\uac70(tail call elimination)")," \uc774\ub77c\ub294 \uae30\ub2a5\uc744 \uad6c\ud604\ud569\ub2c8\ub2e4.\n\ud568\uc218 \ud638\ucd9c\uc758 \uacb0\uacfc\uac00 \ud568\uc218 \uc790\uccb4\uc758 \uacb0\uacfc\uc778 \uacbd\uc6b0(\uc774\ub97c ",(0,l.kt)("em",{parentName:"p"},"\uaf2c\ub9ac \uc704\uce58(tail position)")," \uc774\ub77c\uace0 \ud568),\n\ud604\uc7ac \uc2a4\ud0dd \ud504\ub808\uc784\uc744 \uc0ad\uc81c\ud558\uace0 \ud638\ucd9c\ud558\ub294 \ud568\uc218\ub97c \uc704\ud55c \ud558\ub098\uc758 \uc2a4\ud0dd \ud504\ub808\uc784\uc744 \ud560\ub2f9\ud558\uc5ec ",(0,l.kt)("inlineCode",{parentName:"p"},"N"),"\ubc88\uc758 \ubc18\ubcf5\uc5d0 \ub300\ud574 ",(0,l.kt)("inlineCode",{parentName:"p"},"N"),"\uac1c\uc758 \uc2a4\ud0dd \ud504\ub808\uc784\uc774 \ud544\uc694\ud558\uc9c0 \uc54a\ub3c4\ub85d \ud569\ub2c8\ub2e4."),(0,l.kt)("p",null,"\ubb3c\ub860, \uc774\ub294 \uaf2c\ub9ac \ud638\ucd9c \uc81c\uac70\ub97c \uc218\ud589\ud558\ub294 \ud55c \uac00\uc9c0 \ubc29\ubc95\uc77c \ubfd0\uc774\uba70,\n\uc6b0\ub9ac\uac00 \uc704\uc5d0\uc11c \uc7ac\uadc0\uc801\uc73c\ub85c \uc791\uc131\ud55c ",(0,l.kt)("inlineCode",{parentName:"p"},"add")," \ud568\uc218\uc640 \uac19\uc740 \ucf54\ub4dc\ub97c \ubc18\ubcf5 \ubc84\uc804\uc73c\ub85c \ubcc0\ud658\ud558\ub294 \uac83\uacfc \uac19\uc740 \ub2e4\ub978 \uc804\ub7b5\ub3c4 \uc874\uc7ac\ud569\ub2c8\ub2e4."),(0,l.kt)("h4",{id:"\uc9c0\uc5f0\uc131"},"\uc9c0\uc5f0\uc131"),(0,l.kt)("p",null,"Haskell\uc740 \ud754\ud788 \uc0ac\uc6a9\ub418\ub294 \uc5c4\uaca9\ud55c \ud3c9\uac00 \uc804\ub7b5(strict evaluation strategy)\uc774 \uc544\ub2cc ",(0,l.kt)("em",{parentName:"p"},"\uc9c0\uc5f0 \ud3c9\uac00 \uc804\ub7b5(lazy evaluation strategy)"),"\uc744 \uc0ac\uc6a9\ud558\uae30 \ub54c\ubb38\uc5d0 \uc870\uae08 \ub2e4\ub978 \uaddc\uce59\uc744 \ub530\ub985\ub2c8\ub2e4.\n\uc5ec\uae30\uc11c ",(0,l.kt)("em",{parentName:"p"},"\ud3c9\uac00 \uc804\ub7b5(evaluation strategy)"),'\uc774\ub780 "\uc5b8\uc81c \uacc4\uc0b0\uc744 \ud3c9\uac00\ud560 \uac83\uc778\uac00"\ub97c \uc758\ubbf8\ud569\ub2c8\ub2e4.\n\uc5c4\uaca9\ud55c \uc5b8\uc5b4\uc5d0\uc11c\uc758 \ubc95\uce59\uc740 \uac04\ub2e8\ud569\ub2c8\ub2e4: ',(0,l.kt)("em",{parentName:"p"},"\ud568\uc218\uc5d0 \uc804\ub2ec\ub418\ub294 \uc778\uc218\ub97c \ud568\uc218\uc5d0 \uc9c4\uc785\ud558\uae30 \uc804\uc5d0 \ud3c9\uac00\ud569\ub2c8\ub2e4"),"."),(0,l.kt)("p",null,"\uc608\ub97c \ub4e4\uc5b4 ",(0,l.kt)("inlineCode",{parentName:"p"},"add (increment 3) (decrement 2)"),"\ub97c \uc5c4\uaca9\ud558\uac8c \ud3c9\uac00\ud558\uba74 \ub2e4\uc74c\uacfc \uac19\uc2b5\ub2c8\ub2e4:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"increment 3"),"\uc744 \ud3c9\uac00\ud558\uc5ec ",(0,l.kt)("inlineCode",{parentName:"li"},"4"),"\ub97c \uc5bb\uc2b5\ub2c8\ub2e4."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"decrement 2"),"\ub97c \ud3c9\uac00\ud558\uc5ec ",(0,l.kt)("inlineCode",{parentName:"li"},"1"),"\uc744 \uc5bb\uc2b5\ub2c8\ub2e4."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"add 4 1"),"\uc744 \ud3c9\uac00\ud569\ub2c8\ub2e4"),(0,l.kt)("li",{parentName:"ol"},"Evaluate ",(0,l.kt)("inlineCode",{parentName:"li"},"increment 3")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"4")),(0,l.kt)("li",{parentName:"ol"},"Evaluate ",(0,l.kt)("inlineCode",{parentName:"li"},"decrement 2")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"1")),(0,l.kt)("li",{parentName:"ol"},"Evaluate ",(0,l.kt)("inlineCode",{parentName:"li"},"add 4 1"))),(0,l.kt)("p",null,"\ub610\ub294 (\uc5b8\uc5b4\uc5d0 \ub530\ub77c\uc11c) (1)\uacfc (2)\uc758 \uc21c\uc11c\ub97c \ubc18\ub300\ub85c \ud558\uace0 \uc778\uc218\ub97c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \ud3c9\uac00\ud569\ub2c8\ub2e4."),(0,l.kt)("p",null,"\ubc18\uba74 \uc9c0\uc5f0 \ud3c9\uac00 \uc804\ub7b5\uc5d0\uc11c\ub294, ",(0,l.kt)("em",{parentName:"p"},"\uc2e4\uc81c\ub85c \ud544\uc694\ud55c \uc2dc\uc810\uc5d0\ub9cc \uacc4\uc0b0\uc744 \ud3c9\uac00\ud569\ub2c8\ub2e4"),".\n\uc608\ub97c \ub4e4\uc5b4 \ud45c\uc900 \ucd9c\ub825\uc5d0 \uc5f0\uc0b0\uc744 \ucd9c\ub825\ud558\uac70\ub098 \ub124\ud2b8\uc6cc\ud06c\ub85c \ubcf4\ub0b4\ub294 \ub4f1, \uc678\ubd80 \uc138\uacc4\uc5d0 \uc601\ud5a5\uc744 \ubbf8\uce58\ub294 \uc5f0\uc0b0\uc744 \ud3ec\ud568\ud560 \ub54c \ud3c9\uac00\ud569\ub2c8\ub2e4."),(0,l.kt)("p",null,"\ub530\ub77c\uc11c \uacc4\uc0b0\uc774 \ud544\uc694\ud558\uc9c0 \uc54a\uc740 \uacbd\uc6b0, \ud3c9\uac00\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \uc608\ub4e4 \ub4e4\uba74:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'main =\n  if add (increment 2) (decrement 3) == 5\n    then putStrLn "Yes."\n    else putStrLn "No."\n')),(0,l.kt)("p",null,"\uc774 \uacbd\uc6b0 ",(0,l.kt)("inlineCode",{parentName:"p"},"add (increment 2) (decrement 3)"),"\uc758 \uacb0\uacfc\uac00 \ud544\uc694\ud558\ubbc0\ub85c \ud3c9\uac00\ud569\ub2c8\ub2e4. \ud558\uc9c0\ub9cc:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'main =\n  let\n    five = add (increment 2) (decrement 3)\n  in\n    putStrLn "Not required"\n')),(0,l.kt)("p",null,"\uc774 \uacbd\uc6b0\ub294 ",(0,l.kt)("inlineCode",{parentName:"p"},"five"),"\uac00 \ud544\uc694\ud558\uc9c0 \uc54a\uc73c\ubbc0\ub85c \ud3c9\uac00\ud558\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4!"),(0,l.kt)("p",null,"\uadf8\ub807\ub2e4\uba74 ",(0,l.kt)("inlineCode",{parentName:"p"},"add (increment 2) (decrement 3)"),"\uac00 \ud544\uc694\ud558\ub2e4\uace0 \ud310\ub2e8\ud558\uba74 \uc5c4\uaca9\ud55c \ud3c9\uac00\ub97c \uc218\ud589\ud560\uae4c\uc694?\n\uadf8\ub807\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4 - \uc65c\ub0d0\ud558\uba74 \uacc4\uc0b0\uc744 \uc644\ub8cc\ud558\uae30 \uc704\ud574 \uc778\uc790\ub97c \ud3c9\uac00\ud560 \ud544\uc694\uac00 \uc5c6\uc744 \uc218\ub3c4 \uc788\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4.\n\uc608\ub97c \ub4e4\uc5b4 \ub2e4\uc74c\uacfc \uac19\uc740 \uacbd\uc6b0:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'const a b = a\n\nmain =\n  if const (increment 2) (decrement 3) == 3\n    then putStrLn "Yes."\n    else putStrLn "No."\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"const"),"\ub294 \ub450 \ubc88\uc9f8 \uc778\uc790\ub97c \ubb34\uc2dc\ud558\uace0 \uccab \ubc88\uc9f8 \uc778\uc790\ub97c \ubc18\ud658\ud558\ubbc0\ub85c, \uacc4\uc0b0\uc758 \uacb0\uacfc\ub97c \uc81c\uacf5\ud558\uace0 \ud654\uba74\uc5d0 \ucd9c\ub825\ud558\uae30 \uc704\ud574 ",(0,l.kt)("inlineCode",{parentName:"p"},"decrement 3"),"\uc744 \ud3c9\uac00\ud560 \ud544\uc694\uac00 \uc5c6\uc2b5\ub2c8\ub2e4."),(0,l.kt)("p",null,"\uc9c0\uc5f0 \ud3c9\uac00 \uc804\ub7b5\uc5d0\uc11c\ub294 \ud544\uc694\ud560 \ub54c\ub9cc \uacc4\uc0b0\uc744 \ud3c9\uac00\ud558\uba70 (\uc0ac\uc6a9\uc790\uac00 \ubb34\uc5b8\uac00\ub97c \uc218\ud589\ud558\uae30 \uc704\ud574 \ud544\uc694\ud560 \ub54c),\n\ubc14\uae65\uc5d0\uc11c \uc548\uc73c\ub85c \ud3c9\uac00\ud569\ub2c8\ub2e4 - \uba3c\uc800 \ud568\uc218\uc5d0 \uc9c4\uc785\ud558\uace0, \uadf8 \ub2e4\uc74c\uc5d0 \ud544\uc694\ud560 \ub54c \uc778\uc790\ub97c \ud3c9\uac00\ud569\ub2c8\ub2e4 (\ub300\ubd80\ubd84\uc758 \uacbd\uc6b0 ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," \ud45c\ud604\uc2dd\uc758 \uc870\uac74\uc774\ub098 \ud328\ud134 \ub9e4\uce6d\uc758 \ud328\ud134\uc5d0 \ub098\ud0c0\ub0a0 \ub54c)."),(0,l.kt)("hr",null),(0,l.kt)("p",null,"\ud558\uc2a4\ucf08\uc5d0\uc11c \uc774\ub7f0 \uc804\ub7b5\uc774 \uc5b4\ub5bb\uac8c \uc774\ub8e8\uc5b4\uc9c0\ub294\uc9c0\uc5d0 \ub300\ud55c \uc790\uc138\ud55c \ub0b4\uc6a9\uc744 \ub2e4\uc74c \ube14\ub85c\uadf8 \ud3ec\uc2a4\ud2b8\uc5d0\uc11c \ud655\uc778\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4:\n",(0,l.kt)("a",{parentName:"p",href:"https://gilmi.me/blog/post/2020/10/01/substitution-and-equational-reasoning"},"Substitution and Equational Reasoning"),"."),(0,l.kt)("p",null,"\uc77d\uc5b4\ubcf8 \ud6c4, \ub2e4\uc74c \ud504\ub85c\uadf8\ub7a8\uc744 \uc9c1\uc811 \ud3c9\uac00\ud574 \ubcf4\uc138\uc694:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'import Prelude hiding (const) -- \uc774 \uc904\uc740 \ubb34\uc2dc\ud574\ub3c4 \uc88b\uc2b5\ub2c8\ub2e4\n\nincrement n = n + 1\n\ndecrement n = n - 1\n\nconst a b = a\n\nadd n m =\n  if m /= 0\n    then add (increment n) (decrement m)\n    else n\n\nmain =\n  if const (add 3 2) (decrement 3) == 5\n    then putStrLn "Yes."\n    else putStrLn "No."\n')),(0,l.kt)("p",null,"\ud3c9\uac00\ub294 \uc5b8\uc81c\ub098 ",(0,l.kt)("inlineCode",{parentName:"p"},"main"),"\uc5d0\uc11c \uc2dc\uc791\ud558\ub294 \uc810\uc744 \uba85\uc2ec\ud558\uc138\uc694."),(0,l.kt)("details",null,(0,l.kt)("summary",null,"\uc815\ub2f5"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"main")," \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if const (add 3 2) (decrement 3) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"const")," \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if add 3 2 == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"add")," \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if (if 2 /= 0 then add (increment 3) (decrement 2) else 3) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,"\uc81c\uc5b4\ubb38 ",(0,l.kt)("inlineCode",{parentName:"p"},"2 /= 0")," \ud3c9\uac00 "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if (if True then add (increment 3) (decrement 2) else 3) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"then")," \ubd84\uae30 \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if (add (increment 3) (decrement 2)) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"add")," \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  ( if decrement 2 /= 0\n    then add\n      (increment (increment 3))\n      (decrement (decrement 2))\n    else (increment 3)\n  ) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,"\uc81c\uc5b4\ubb38\uc5d0\uc11c ",(0,l.kt)("inlineCode",{parentName:"p"},"decrement 2")," \ud3c9\uac00 (\ub450 \uacf3\uc774 \ubcc0\uacbd\ub418\ub294 \uac83\uc5d0 \uc8fc\ubaa9\ud558\uc138\uc694!)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  ( if 1 /= 0\n    then add\n      (increment (increment 3))\n      (decrement 1)\n    else (increment 3)\n  ) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,"\uc81c\uc5b4\ubb38 ",(0,l.kt)("inlineCode",{parentName:"p"},"1 /= 0")," \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  ( if True\n    then add\n      (increment (increment 3))\n      (decrement 1)\n    else (increment 3)\n  ) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"then")," \ubd84\uae30 \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  ( add\n    (increment (increment 3))\n    (decrement 1)\n  ) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"add")," \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  ( if decrement 1 /= 0\n    then add\n      (increment (increment (increment 3)))\n      (decrement (decrement 1))\n    else increment (increment 3)\n  ) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,"\uc81c\uc5b4\ubb38 ",(0,l.kt)("inlineCode",{parentName:"p"},"decrement 1")," \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  ( if 0 /= 0\n    then add\n      (increment (increment (increment 3)))\n      (decrement 0)\n    else increment (increment 3)\n  ) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,"\uc81c\uc5b4\ubb38 ",(0,l.kt)("inlineCode",{parentName:"p"},"0 /= 0")," \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  ( if False\n    then add\n      (increment (increment (increment 3)))\n      (decrement 0)\n    else increment (increment 3)\n  ) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"else")," \ubd84\uae30 \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  (increment (increment 3)) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,"\uc81c\uc5b4\ubb38 ",(0,l.kt)("inlineCode",{parentName:"p"},"increment (increment 3)")," \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  (increment 3 + 1) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,"\uc81c\uc5b4\ubb38 ",(0,l.kt)("inlineCode",{parentName:"p"},"increment 3")," \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  (3 + 1 + 1) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,"\uc81c\uc5b4\ubb38 ",(0,l.kt)("inlineCode",{parentName:"p"},"3 + 1")," \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  (4 + 1) == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,"\uc81c\uc5b4\ubb38 ",(0,l.kt)("inlineCode",{parentName:"p"},"4 + 1")," \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  5 == 5\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,"\uc81c\uc5b4\ubb38 ",(0,l.kt)("inlineCode",{parentName:"p"},"5 == 5")," \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'if\n  True\n  then putStrLn "Yes."\n  else putStrLn "No."\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"then")," \ubd84\uae30 \ud3c9\uac00"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'putStrLn "Yes."\n')),(0,l.kt)("p",null,"\ud654\uba74\uc5d0 ",(0,l.kt)("inlineCode",{parentName:"p"},"Yes."),"\ub97c \ucd9c\ub825\ud569\ub2c8\ub2e4.")),(0,l.kt)("hr",null),(0,l.kt)("h3",{id:"general-recursion"},"General recursion"),(0,l.kt)("p",null,"In general, when trying to solve problems recursively, it is useful to think\nabout the problem in three parts:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Finding the ",(0,l.kt)("strong",{parentName:"li"},"base case")," (the most simple cases - the ones we already know how to answer)"),(0,l.kt)("li",{parentName:"ol"},"Figuring out how to ",(0,l.kt)("strong",{parentName:"li"},"reduce")," the problem to something simpler (so it gets closer to the base case)"),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"Mitigating the difference")," between the reduced version and the solution we need to provide")),(0,l.kt)("p",null,"The reduce and mitigate steps together are usually called the ",(0,l.kt)("em",{parentName:"p"},"recursive step"),"."),(0,l.kt)("p",null,"Let's take a look at another example problem: generating a list of a particular size\nwith a specific value in place of every element."),(0,l.kt)("p",null,"In Haskell, this function would have the following signature:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"replicate :: Int -> a -> [a]\n")),(0,l.kt)("p",null,"Here are a few usage examples of ",(0,l.kt)("inlineCode",{parentName:"p"},"replicate"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> replicate 4 True\n[True,True,True,True]\nghci> replicate 0 True\n[]\nghci> replicate (-13) True\n[]\n")),(0,l.kt)("p",null,"How would we implement this function recursively? How would describe it in three steps above?"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"Base case"),": the cases we already know how to generate are the cases where the length\nof the list is zero (or less) - we just return an empty list."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"Reduce"),": while we might not know how to generate a list of size ",(0,l.kt)("inlineCode",{parentName:"li"},"N")," (where ",(0,l.kt)("inlineCode",{parentName:"li"},"N")," is positive),\nif we knew the solution for ",(0,l.kt)("inlineCode",{parentName:"li"},"N-1")," we could:"),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"Mitigate"),": Add another element to the solution for ",(0,l.kt)("inlineCode",{parentName:"li"},"N-1")," using the ",(0,l.kt)("inlineCode",{parentName:"li"},":")," (cons) operator.")),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Try to write this in Haskell!"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Solution"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"replicate :: Int -> a -> [a]\nreplicate n x =\n  if n <= 0    -- recognizing the base case\n    then\n      []       -- the solution for the base case\n    else\n        x : replicate (n - 1) x\n  --   ---  -------------------\n  --    ^           ^\n  --    |           |\n  --    |           +-------- reduction\n  --    |\n  --    +--- mitigation\n"))),(0,l.kt)("hr",null),(0,l.kt)("h3",{id:"mutual-recursion"},"Mutual recursion"),(0,l.kt)("p",null,"When solving functions recursively we usually call the same function again,\nbut that doesn't have to be the case. It is possible to reduce our problem\nto something simpler that requires an answer from a different function.\nIf, in turn, that function will (or another function in that call chain)\ncall our function again, we have a ",(0,l.kt)("strong",{parentName:"p"},"mutual recursive")," solution."),(0,l.kt)("p",null,"For example, let's write two functions, one that checks whether a natural number\nis even or not, and one that checks whether a number is odd or not\nonly by decrementing it."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"even :: Int -> Bool\n\nodd :: Int -> Bool\n")),(0,l.kt)("p",null,"Let's start with ",(0,l.kt)("inlineCode",{parentName:"p"},"even"),", how should we solve this recursively?"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"Base case"),": We know the answer for ",(0,l.kt)("inlineCode",{parentName:"li"},"0")," - it is ",(0,l.kt)("inlineCode",{parentName:"li"},"True"),"."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"Reduction"),": We might not know the answer for a general ",(0,l.kt)("inlineCode",{parentName:"li"},"N"),", but we could check whether ",(0,l.kt)("inlineCode",{parentName:"li"},"N - 1")," is odd,"),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"Mitigation"),": if ",(0,l.kt)("inlineCode",{parentName:"li"},"N - 1")," is odd, then ",(0,l.kt)("inlineCode",{parentName:"li"},"N")," is even! if it isn't odd, then ",(0,l.kt)("inlineCode",{parentName:"li"},"N")," isn't even.")),(0,l.kt)("p",null,"What about ",(0,l.kt)("inlineCode",{parentName:"p"},"odd"),"?"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"Base case"),": We know the answer for ",(0,l.kt)("inlineCode",{parentName:"li"},"0")," - it is ",(0,l.kt)("inlineCode",{parentName:"li"},"False"),"."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"Reduction"),": We might not know the answer for a general ",(0,l.kt)("inlineCode",{parentName:"li"},"N"),", but we could check whether ",(0,l.kt)("inlineCode",{parentName:"li"},"N - 1")," is even,"),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"Mitigation"),": if ",(0,l.kt)("inlineCode",{parentName:"li"},"N - 1")," is even, then ",(0,l.kt)("inlineCode",{parentName:"li"},"N")," is odd! if it isn't even, then ",(0,l.kt)("inlineCode",{parentName:"li"},"N")," isn't odd.")),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Try writing this in Haskell!"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Solution"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"even :: Int -> Bool\neven n =\n  if n == 0\n    then\n      True\n    else\n      odd (n - 1)\n\nodd :: Int -> Bool\nodd n =\n  if n == 0\n    then\n      False\n    else\n      even (n - 1)\n\n"))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"partial-functions"},"Partial functions"),(0,l.kt)("p",null,"Because we didn't handle the negative numbers cases in the example above,\nour functions will loop forever when a negative value is passed as input.\nA function that does not return a result for some value\n(either by not terminating or by throwing an error) is called ",(0,l.kt)("strong",{parentName:"p"},"a partial function"),"\n(because it only returns a result for a part of the possible inputs)."),(0,l.kt)("p",null,"Partial functions are generally considered ",(0,l.kt)("strong",{parentName:"p"},"bad practice")," because they can have\nundesired behaviour at runtime (a runtime exception or an infinite loop),\nso we want to ",(0,l.kt)("strong",{parentName:"p"},"avoid using")," partial functions\nas well as ",(0,l.kt)("strong",{parentName:"p"},"avoid writing")," partial functions."),(0,l.kt)("p",null,"The best way to avoid writing partial functions is by covering all inputs!\nIn the situation above, it is definitely possible to handle negative numbers\nas well, so we should do that! Or, instead, we could require that our functions\naccept a ",(0,l.kt)("inlineCode",{parentName:"p"},"Natural")," instead of an ",(0,l.kt)("inlineCode",{parentName:"p"},"Int"),", and then the type system would've stopped\nus from using these functions with values that we did not handle."),(0,l.kt)("p",null,"There are cases where we can't possibly cover all inputs, in these cases it is important\nto re-examine the code and see if we could further restrict the inputs using types to\nmitigate these issues."),(0,l.kt)("p",null,"For example, the ",(0,l.kt)("inlineCode",{parentName:"p"},"head :: [a] -> a")," function from ",(0,l.kt)("inlineCode",{parentName:"p"},"Prelude")," promises\nto return the first element (the head) of a list, but we know that lists\ncould possibly be empty, so how can this function deliver on its promise?"),(0,l.kt)("p",null,"Unfortunately, it can't. But there exists a different function that can:\n",(0,l.kt)("inlineCode",{parentName:"p"},"head :: NonEmpty a -> a")," from the\n",(0,l.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-List-NonEmpty.html"},(0,l.kt)("inlineCode",{parentName:"a"},"Data.List.NonEmpty")),"\nmodule! The trick here is that this other ",(0,l.kt)("inlineCode",{parentName:"p"},"head")," does not take a general list\nas input, it takes a different type entirely, one that promises to have\nat least one element, and therefore can deliver on its promise!"),(0,l.kt)("p",null,"We could also potentially use smart constructors with ",(0,l.kt)("inlineCode",{parentName:"p"},"newtype")," and enforce some sort\nof restrictions in the type system, as we saw in earlier chapters,\nBut this solution can sometimes be less ergonomic to use."),(0,l.kt)("p",null,"An alternative approach is to use ",(0,l.kt)("inlineCode",{parentName:"p"},"data")," types to encode the absence of a proper result,\nfor example, using ",(0,l.kt)("inlineCode",{parentName:"p"},"Maybe"),", as we'll see in a future chapter."),(0,l.kt)("p",null,"Make sure the functions you write return a result for every input,\neither by constraining the input using types, or by encoding the absence of a result using\ntypes."),(0,l.kt)("h2",{id:"parsing-markup"},"Parsing markup?"),(0,l.kt)("p",null,"Let's get back to the task at hand."),(0,l.kt)("p",null,"As stated previously, our strategy for parsing the markup text is:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Split the string to a list where each element is a separate line\n(which we can do with ",(0,l.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:lines"},(0,l.kt)("inlineCode",{parentName:"a"},"lines")),"), and"),(0,l.kt)("li",{parentName:"ol"},"Go over the list line by line and process it, remembering\ninformation from previous lines if necessary")),(0,l.kt)("p",null,"Remember that we want to start by ignoring all of the markup syntax\nand just group lines together into paragraphs (paragraphs are separated by an empty line),\nand iteratively add new features later in the chapter:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'parse :: String -> Document\nparse = parseLines [] . lines -- (1)\n\nparseLines :: [String] -> [String] -> Document\nparseLines currentParagraph txts =\n  let\n    paragraph = Paragraph (unlines (reverse currentParagraph)) -- (2), (3)\n  in\n    case txts of -- (4)\n      [] -> [paragraph]\n      currentLine : rest ->\n        if trim currentLine == ""\n          then\n            paragraph : parseLines [] rest -- (5)\n          else\n            parseLines (currentLine : currentParagraph) rest -- (6)\n\ntrim :: String -> String\ntrim = unwords . words\n')),(0,l.kt)("p",null,"Things to note:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"We pass a list that contains the currently grouped paragraph (paragraphs are separated by an empty line)")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Because of laziness, ",(0,l.kt)("inlineCode",{parentName:"p"},"paragraph")," is not computed until it's needed, so we don't have to worry about\nthe performance implications in the case that we are still grouping lines")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Why do we reverse ",(0,l.kt)("inlineCode",{parentName:"p"},"currentParagraph"),"? (See point (6))")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"We saw case expressions used to deconstruct ",(0,l.kt)("inlineCode",{parentName:"p"},"newtype"),"s and ",(0,l.kt)("inlineCode",{parentName:"p"},"Char"),"s,\nbut we can also pattern match on lists and other ADTs as well!\nIn this case we match against two patterns, an empty list (",(0,l.kt)("inlineCode",{parentName:"p"},"[]"),'),\nand a "cons cell" - a list with at least one element (',(0,l.kt)("inlineCode",{parentName:"p"},"currentLine : rest"),').\nIn the body of the "cons" pattern, we bind the first element to the name ',(0,l.kt)("inlineCode",{parentName:"p"},"currentLine"),",\nand the rest of the elements to the name ",(0,l.kt)("inlineCode",{parentName:"p"},"rest"),"."),(0,l.kt)("p",{parentName:"li"},"We will talk about how all of this works really soon!")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"When we run into an empty line we add the accumulated paragraph to the resulting list (A ",(0,l.kt)("inlineCode",{parentName:"p"},"Document")," is a list of structures) and start the function again with the rest of the input.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"We pass the new lines to be grouped in a paragraph ",(0,l.kt)("strong",{parentName:"p"},"in reverse order")," because of\nperformance characteristics - because of the nature of singly-linked lists,\nprepending an element is fast, and appending is slow. Prepending only requires\nus to create a new cons (",(0,l.kt)("inlineCode",{parentName:"p"},":"),") cell to hold a pointer to the value and a pointer to the list,\nbut appending requires us to traverse the list to its end and rebuild the cons cells -\nthe last one will contain the last value of the list and a pointer to the list to append,\nthe next will contain the value before the last value of the list and a pointer to the\nlist which contains the last element and the appended list, and so on."))),(0,l.kt)("p",null,"This code above will group together paragraphs in a structure, but how do we view our result?\nIn the next chapter we will take a short detour and talk about type classes, and how\nthey can help us in this scenario."))}d.isMDXComponent=!0}}]);