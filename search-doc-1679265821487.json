[{"title":"Generating documentation","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/documentation","content":"","keywords":""},{"title":"Running Haddock​","type":1,"pageTitle":"Generating documentation","url":"/learn-haskell-blog-generator/documentation#running-haddock","content":"We can generate API reference pages (a.k.a. haddocks in the Haskell world) for our project using our favorite package manager: "},{"title":"Cabal​","type":1,"pageTitle":"Generating documentation","url":"/learn-haskell-blog-generator/documentation#cabal","content":"We can run cabal haddock to generate haddocks: ➜ cabal haddock Resolving dependencies... Build profile: -w ghc-9.0.1 -O1 In order, the following will be built (use -v for more details): - hs-blog-0.1.0.0 (lib) (first run) Configuring library for hs-blog-0.1.0.0.. Preprocessing library for hs-blog-0.1.0.0.. Running Haddock on library for hs-blog-0.1.0.0.. Haddock coverage: 0% ( 0 / 3) in 'HsBlog.Env' Missing documentation for: Module header Env (src/HsBlog/Env.hs:3) defaultEnv (src/HsBlog/Env.hs:10) 21% ( 7 / 33) in 'HsBlog.Html.Internal' Missing documentation for: Module header Html (src/HsBlog/Html/Internal.hs:8) ... Documentation created: /tmp/learn-haskell-blog-generator/dist-newstyle/build/x86_64-linux/ghc-9.0.1/hs-blog-0.1.0.0/doc/html/hs-blog/index.html  Cabal and Haddock will build our project and generate HTML pages for us at: ./dist-newstyle/build/&lt;platform &gt;/&lt;compiler &gt;/&lt;package &gt;-&lt;version&gt;/doc/html/&lt;package&gt;/&lt;/package&gt;&lt;/version&gt;&lt;/package &gt;&lt;/compiler &gt;&lt;/platform &gt;  We can then open the index.html file from that directory in a web browser and view our package documentation. "},{"title":"Stack​","type":1,"pageTitle":"Generating documentation","url":"/learn-haskell-blog-generator/documentation#stack","content":"We can run stack haddock to generate haddocks: ➜ stack haddock ... hs-blog&gt; build (lib + exe) Preprocessing library for hs-blog-0.1.0.0.. Building library for hs-blog-0.1.0.0.. [1 of 7] Compiling HsBlog.Env [2 of 7] Compiling HsBlog.Html.Internal ... hs-blog&gt; haddock Preprocessing library for hs-blog-0.1.0.0.. Running Haddock on library for hs-blog-0.1.0.0.. Haddock coverage: 0% ( 0 / 3) in 'HsBlog.Env' Missing documentation for: Module header Env (src/HsBlog/Env.hs:3) defaultEnv (src/HsBlog/Env.hs:10) 21% ( 7 / 33) in 'HsBlog.Html.Internal' Missing documentation for: Module header Html (src/HsBlog/Html/Internal.hs:8) ... Documentation created: .stack-work/dist/x86_64-linux-tinfo6/Cabal-3.2.1.0/doc/html/hs-blog/index.html, .stack-work/dist/x86_64-linux-tinfo6/Cabal-3.2.1.0/doc/html/hs-blog/hs-blog.txt Preprocessing executable 'hs-blog-gen' for hs-blog-0.1.0.0.. ...  Stack and Haddock will build our project and generate HTML pages for us at: ./.stack-work/dist/&lt;platform &gt;/Cabal-&lt;version&gt;/doc/html/&lt;package&gt;/&lt;/package&gt;&lt;/version&gt;&lt;/platform &gt;  We can then open the index.html file from that directory in a web browser and view our package documentation. "},{"title":"Haddock coverage​","type":1,"pageTitle":"Generating documentation","url":"/learn-haskell-blog-generator/documentation#haddock-coverage","content":"Haddock will also output a coverage report when run, and will mention user-exposed constructs which are missing documentation. These constructs could be module headers, types, data constructors, type classes, functions, values, etc. For example: Haddock coverage: ... 0% ( 0 / 3) in 'HsBlog.Convert' Missing documentation for: Module header convert (src/HsBlog/Convert.hs:8) convertStructure (src/HsBlog/Convert.hs:23) 67% ( 2 / 3) in 'HsBlog.Directory' Missing documentation for: buildIndex (src/HsBlog/Directory.hs:80) ...  We can see that we did not document the HsBlog.Convert at all, and we are missing documentation for the module header, the convert function and the convertStructure function. On the other hand, it seems that we do currently have some documentation written for the HsBlog.Directorymodule! We'll see why, but first - try to generate haddocks, see the module hierarchy, browse around the different modules, follow the links of the types, imagine what this API reference could look like, and let's see how we can improve it. "},{"title":"Haddock markup​","type":1,"pageTitle":"Generating documentation","url":"/learn-haskell-blog-generator/documentation#haddock-markup","content":"Haddock builds the API reference pages by building our project, examining the exported modules and their exported definitions, and grabbing source code comments written in special markup format. Let's take a quick look at this markup format. We will go over a few important bits, but if you'd like to learn more, a complete guide for Haddock markup can be found in theHaddock documentation. "},{"title":"Documenting definitions​","type":1,"pageTitle":"Generating documentation","url":"/learn-haskell-blog-generator/documentation#documenting-definitions","content":"All haddock annotations appear as part of regular Haskell comments. They can be used with both single line form (--) and multi-line form ({- and -}). The placement of a comment block and the haddock marker determine to which Haskell definition the haddock string is attached. We can annotate a Haskell definition by writing a comment block prefixed with | beforethe definition, or by writing a comment block prefixed with ^ after the definition. For example: -- | Construct an HTML page from a `Head` -- and a `Structure`. html_ :: Head -- ^ Represents the @\\&lt;head\\&gt;@ section in an HTML file -&gt; Structure -- ^ Represents the @\\&lt;body\\&gt;@ section in an HTML file -&gt; Html html_ = ... ...  Here's another example: {- | Represents a single markup structure. Such as: - A paragraph - An unordered list - A code block -} data Structure = Heading Natural String -- ^ A section heading with a level | Paragraph String -- ^ A paragraph | UnorderedList [String] -- ^ An unordered list of strings | OrderedList [String] -- ^ An ordered list of strings | CodeBlock [String] -- ^ A code block  And another: {- | Markup to HTML conversion module. This module handles converting documents written in our custom Markup language into HTML pages. -} module HsBlog.Convert where  As you can see, | and ^ can be used to document functions, function arguments, types, data constructors, modules, and more. They are probably the most important Haddock annotations to remember (and even then, | alone will suffice). Tip: Annotate the modules, types, and the top-level definitions which are exported from your project with some high-level description of what they are used for (at the very least). Your users and collaborators will thank you! "},{"title":"Section headings​","type":1,"pageTitle":"Generating documentation","url":"/learn-haskell-blog-generator/documentation#section-headings","content":"We can separate our module into sections by adding headings. Headings are comments which are prefixed with a number of * (just like in our markup language). For example: -- * HTML EDSL html_ :: Head -&gt; Structure -&gt; Html html_ = ... -- ** Structure p_ :: Content -&gt; Structure p_ = .. h_ :: Content -&gt; Structure h_ = .. ... -- ** Content txt_ :: String -&gt; Content txt_ = ... link_ :: FilePath -&gt; Content -&gt; Content link_ = ...  It is also possible to add headings to the export list instead: module HsBlog.Html ( -- * HTML EDSL Html , html_ -- ** Combinators used to construct the @\\&lt;head\\&gt;@ section , Head , title_ , stylesheet_ , meta_ -- ** Combinators used to construct the @\\&lt;body\\&gt;@ section , Structure , p_ , h_ , ul_ , ol_ , code_ -- ** Combinators used to construct content inside structures , Content , txt_ , img_ , link_ , b_ , i_ -- ** Render HTML to String , render ) where  Separating parts of the module into sections helps keeping the important things together and Haddock will create a table-of-contents at the top of a module page for us as well. Sometimes it's also easier to figure out whether a module should be split into multiple modules or not after splitting it into sections using headings.  Exercise: Try to re-arrange the modules in our project to your liking and add headings to sections.  "},{"title":"Formatting​","type":1,"pageTitle":"Generating documentation","url":"/learn-haskell-blog-generator/documentation#formatting","content":"As we saw earlier, we can also add formatting in the content of our comments. For example, we can: Hyperlink identifiers by surrounding them with ` For example: `Heading` Write monospaced text by surrounding it with @ For example: @Paragraph &quot;Hello&quot;@ Add emphasis to text by surrounding it with / For example: /this is emphasised/ Add bold to text by surrounding it with __ For example: __this is bold__ "},{"title":"More​","type":1,"pageTitle":"Generating documentation","url":"/learn-haskell-blog-generator/documentation#more","content":"In this chapter we've covered the basics of the Haddock markup language. If you'd like to know more, the Haddock markup guidecontains information on how to create even more interesting documentation structures, such as code blocks, grid tables, images and examples. "},{"title":"Summary​","type":1,"pageTitle":"Generating documentation","url":"/learn-haskell-blog-generator/documentation#summary","content":"We've briefly covered one aspect of documenting Haskell programs: using Haddock to generate informative API reference pages created from source code comments which are annotated with Haddock markup. While API references are incredibly valuable, remember that there are other forms of documentation that can help your users get started quickly, such as examples and tutorials.  Exercise: Add haddock annotation to the top-level definitions in our project and test your understanding of the program and the various parts - sometimes the best way to learn something is to try explaining it!  "},{"title":"Passing environment variables","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/environment","content":"","keywords":""},{"title":"Environment​","type":1,"pageTitle":"Passing environment variables","url":"/learn-haskell-blog-generator/environment#environment","content":"We can represent our environment as a record data type and build it from user input. The user input can be from command-line arguments, a configuration file, or something else: module HsBlog.Env where data Env = Env { eBlogName :: String , eStylesheetPath :: FilePath } deriving Show defaultEnv :: Env defaultEnv = Env &quot;My Blog&quot; &quot;style.css&quot;  After filling this record with the requested information, we can pass it as input to any function that might need it. This is a simple approach that can definitely work for small projects. But sometimes when the project gets bigger and many nested functions need the same information, threading the environment can get tedious. There is an alternative solution to threading the environment as input to functions, and that is using theReaderTtype from the mtl (or transformers) package. "},{"title":"ReaderT​","type":1,"pageTitle":"Passing environment variables","url":"/learn-haskell-blog-generator/environment#readert","content":"newtype ReaderT r m a = ReaderT (r -&gt; m a)  ReaderT is another monad transformer like ExceptT, which means that it also has an instance of Functor, Applicative, Monad and MonadTrans. As we can see in the definition, ReaderT is a newtype over a function that takes some value of type r, and returns a value of type m a. The r usually represents the environment we want to share between functions that we want to compose, and the m a represents the underlying result that we return. The m could be any type that implements Monad that we are familiar with. Usually it goes well with IO or Identity, depending on if we want to share an environment between effectful or uneffectful computations. ReaderT carries a value of type r and passes it around to other functions when we use the Applicative and Monad interfaces so that we don't have to pass the value around manually. And when we want to grab the r and use it, all we have to do is ask. For our case, this means that instead of passing around Env, we can instead convert our functions to use ReaderT - those that are uneffectful and don't useIO, can return ReaderT Env Identity a instead of a (or the simplified version, Reader Env a), and those that are effectful can return ReaderT Env IO a instead of IO a. Note, as we've said before, Functor, Applicative, and Monad all expect the type that implements their interfaces to have the kind * -&gt; *. This means that it is ReaderT r m which implements these interfaces, and when we compose functions with &lt;*&gt; or &gt;&gt;= we replace the f or min their type signature with ReaderT r m. This means that, as with Either e when we had composed functions with the same error type, so it is with ReaderT r m - we have to compose functions with the same r type and samem type, we can't mix different environment types or different underlying m types. We're going to use a specialized version of ReaderT that uses a specific m = Identitycalled Reader. The Control.Monad.Reader provides an alias: Reader r a = ReaderT r Identity a. If the idea behind ReaderT is still a bit fuzzy to you and you want to get a better understanding of how ReaderT works, try doing the following exercise: Choose an Applicative or Monad interface function, I recommend liftA2, and specialize its type signature by replacing f (or m) with a concrete ReaderT type such asReaderT Int IOUnpack the ReaderT newtype, replacing ReaderT Int IO t with Int -&gt; IO tImplement this specialized version of the function you've chosen Solution for liftA2 liftA2 :: Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c Solution for (1) -- Specialize: replace `f` with `ReaderT Env IO` liftA2 :: (a -&gt; b -&gt; c) -&gt; ReaderT Env IO a -&gt; ReaderT Env IO b -&gt; ReaderT Env IO c Solution for (2) -- Unpack the newtype, replacing `ReaderT Env IO a` with `Env -&gt; IO a` liftA2 :: (a -&gt; b -&gt; c) -&gt; (Env -&gt; IO a) -&gt; (Env -&gt; IO b) -&gt; (Env -&gt; IO c) Solution for (3) specialLiftA2 :: (a -&gt; b -&gt; c) -&gt; (Env -&gt; IO a) -&gt; (Env -&gt; IO b) -&gt; (Env -&gt; IO c) specialLiftA2 combine funcA funcB env = liftA2 combine (funcA env) (funcB env) Notice how the job of our special liftA2 for ReaderT is to supply the two functions with env, and then use the liftA2implementation of the underlying m type (in our case IO) to do the rest of the work. Does it look like we're adding a capability on top of a different m? That's the idea behind monad transformers. "},{"title":"How to use Reader​","type":1,"pageTitle":"Passing environment variables","url":"/learn-haskell-blog-generator/environment#how-to-use-reader","content":"Defining a function​ Instead of defining a function like this: txtsToRenderedHtml :: Env -&gt; [(FilePath, String)] -&gt; [(FilePath, String)]  We define it like this: txtsToRenderedHtml :: [(FilePath, String)] -&gt; Reader Env [(FilePath, String)]  Now that our code uses Reader, we have to accommodate that in the way we write our functions. Before: txtsToRenderedHtml :: Env -&gt; [(FilePath, String)] -&gt; [(FilePath, String)] txtsToRenderedHtml env txtFiles = let txtOutputFiles = map toOutputMarkupFile txtFiles index = (&quot;index.html&quot;, buildIndex env txtOutputFiles) htmlPages = map (convertFile env) txtOutputFiles in map (fmap Html.render) (index : htmlPages)  Note how we needed to thread the env to the other functions that use it. After: txtsToRenderedHtml :: [(FilePath, String)] -&gt; Reader Env [(FilePath, String)] txtsToRenderedHtml txtFiles = do let txtOutputFiles = map toOutputMarkupFile txtFiles index &lt;- (,) &quot;index.html&quot; &lt;$&gt; buildIndex txtOutputFiles htmlPages &lt;- traverse convertFile txtOutputFiles pure $ map (fmap Html.render) (index : htmlPages)  Note how we use do notation now, and instead of threading env around we composethe relevant functions, buildIndex and convertFile, we use the type classes interfaces to compose the functions. Note how we needed to fmap over buildIndexto add the output file we needed with the tuple, and how we needed to use traverse instead of map to compose the various Reader values convertFile will produce. "},{"title":"Extracting Env​","type":1,"pageTitle":"Passing environment variables","url":"/learn-haskell-blog-generator/environment#extracting-env","content":"When we want to use our Env, we need to extract it from the Reader. We can do it with: ask :: ReaderT r m r  Which yanks the r from the Reader - we can extract with &gt;&gt;= or &lt;- in do notation. See the comparison: Before: convertFile :: Env -&gt; (FilePath, Markup.Document) -&gt; (FilePath, Html.Html) convertFile env (file, doc) = (file, convert env (takeBaseName file) doc)  After: convertFile :: (FilePath, Markup.Document) -&gt; Reader Env (FilePath, Html.Html) convertFile (file, doc) = do env &lt;- ask pure (file, convert env (takeBaseName file) doc)  Note: we didn't change convert to use Reader because it is a user facing API for our library. By providing a simpler interface we allow more users to use our library - even those that aren't yet familiar with monad transformers. Providing a simple function argument passing interface is preferred in this case. "},{"title":"Run a Reader​","type":1,"pageTitle":"Passing environment variables","url":"/learn-haskell-blog-generator/environment#run-a-reader","content":"Similar to handling the errors with Either, at some point we need to supply the environment to a computation that uses Reader, and extract the result from the computation. We can do that with the functions runReader and runReaderT: runReader :: Reader r a -&gt; (r -&gt; a) runReaderT :: ReaderT r m a -&gt; (r -&gt; m a)  These functions convert a Reader or ReaderT to a function that takes r. Then we can pass the initial environment to that function: convertDirectory :: Env -&gt; FilePath -&gt; FilePath -&gt; IO () convertDirectory env inputDir outputDir = do DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir createOutputDirectoryOrExit outputDir let outputHtmls = runReader (txtsToRenderedHtml filesToProcess) env copyFiles outputDir filesToCopy writeFiles outputDir outputHtmls putStrLn &quot;Done.&quot;  See the let outputHtmlspart. "},{"title":"Extra: Transforming Env for a particular call​","type":1,"pageTitle":"Passing environment variables","url":"/learn-haskell-blog-generator/environment#extra-transforming-env-for-a-particular-call","content":"Sometimes we may want to modify the Env we pass to a particular function call. For example, we may have a general Env type that contains a lot of information, and functions that only need a part of that information. If the functions we are calling are like convert and take the environment as an argument instead of a Reader, we can just extract the environment with ask, apply a function to the extracted environment, and pass the result to the function, like this: outer :: Reader BigEnv MyResult outer = do env &lt;- ask pure (inner (extractSmallEnv env)) inner :: SmallEnv -&gt; MyResult inner = ... extractSmallEnv :: BigEnv -&gt; SmallEnv extractSmallEnv = ...  But if inner uses a Reader SmallEnv instead of argument passing, we can use runReader to convert inner to a normal function, and use the same idea as above! outer :: Reader BigEnv MyResult outer = do env &lt;- ask -- Here the type of `runReader inner` is `SmallEnv -&gt; MyResult` pure (runReader inner (extractSmallEnv env)) inner :: Reader SmallEnv MyResult inner = ... extractSmallEnv :: BigEnv -&gt; SmallEnv extractSmallEnv = ...  This pattern is generalized and captured by a function calledwithReaderT, and works even for ReaderT: withReaderT :: (env2 -&gt; env1) -&gt; ReaderT env1 m a -&gt; ReaderT env2 m a  withReaderT takes a function that modifies the environment, and converts a ReaderT env1 m a computation to a ReaderT env2 m a computation using this function. Let's see it concretely with our example: outer :: Reader BigEnv MyResult outer = withReaderT extractSmallEnv inner   Question: what is the type of withReaderT when specialized in our case? Answer withReaderT :: (BigEnv -&gt; SmallEnv) -- This is the type of `extractSmallEnv` -&gt; Reader SmallEnv MyResult -- This is the type of `inner` -&gt; Reader BigEnv MyResult -- This is the type of `outer`   Note the order of the environments! We use a function from a BigEnv to a SmallEnv, to convert a Reader of SmallEnv to a Reader of BigEnv! This is because we are mapping over the input of a function rather than the output, and is related to topics like variance and covariance, but isn't terribly important for us at the moment. "},{"title":"Using Env in our logic code​","type":1,"pageTitle":"Passing environment variables","url":"/learn-haskell-blog-generator/environment#using-env-in-our-logic-code","content":"One thing we haven't talked about yet is using our environment in the convertfunction to generate the pages we want. And actually, we don't even have the ability to add stylesheets to our HTML EDSL at the moment! We need to go back and extend it. Let's do all that now:  Since stylesheets go in the head element, perhaps it's a good idea to create an additionalnewtype like Structure for head information? Things like title, stylesheet, and even meta elements can be composed together just like we did for Structureto build the head! Do it now: extend our HTML library to include headings and add 3 functions:title_ for titles, stylesheet_ for stylesheets, and meta_ for meta elements like twitter cards. Solution src/HsBlog/Html.hs -- Html.hs module HsBlog.Html ( Html , Head , title_ , stylesheet_ , meta_ , Structure , html_ , p_ , h_ , ul_ , ol_ , code_ , Content , txt_ , img_ , link_ , b_ , i_ , render ) where import Prelude hiding (head) import HsBlog.Html.Internal src/HsBlog/Html/Internal.hs newtype Head = Head String -- * EDSL html_ :: Head -&gt; Structure -&gt; Html html_ (Head head) content = Html ( el &quot;html&quot; ( el &quot;head&quot; head &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) -- * Head title_ :: String -&gt; Head title_ = Head . el &quot;title&quot; . escape stylesheet_ :: FilePath -&gt; Head stylesheet_ path = Head $ &quot;&lt;link rel=\\&quot;stylesheet\\&quot; type=\\&quot;text/css\\&quot; href=\\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\\&quot;&gt;&quot; meta_ :: String -&gt; String -&gt; Head meta_ name content = Head $ &quot;&lt;meta name=\\&quot;&quot; &lt;&gt; escape name &lt;&gt; &quot;\\&quot; content=\\&quot;&quot; &lt;&gt; escape content &lt;&gt; &quot;\\&quot;&gt;&quot; instance Semigroup Head where (&lt;&gt;) (Head h1) (Head h2) = Head (h1 &lt;&gt; h2) instance Monoid Head where mempty = Head &quot;&quot; Fix convert and buildIndex to use the new API. Note: buildIndex should returnReader! Solution src/HsBlog/Convert.hs import Prelude hiding (head) import HsBlog.Env (Env(..)) convert :: Env -&gt; String -&gt; Markup.Document -&gt; Html.Html convert env title doc = let head = Html.title_ (eBlogName env &lt;&gt; &quot; - &quot; &lt;&gt; title) &lt;&gt; Html.stylesheet_ (eStylesheetPath env) article = foldMap convertStructure doc websiteTitle = Html.h_ 1 (Html.link_ &quot;index.html&quot; $ Html.txt_ $ eBlogName env) body = websiteTitle &lt;&gt; article in Html.html_ head body src/HsBlog/Directory.hs buildIndex :: [(FilePath, Markup.Document)] -&gt; Reader Env Html.Html buildIndex files = do env &lt;- ask let previews = map ( \\(file, doc) -&gt; case doc of Markup.Head 1 head : article -&gt; Html.h_ 3 (Html.link_ file (Html.txt_ head)) &lt;&gt; foldMap convertStructure (take 2 article) &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;)) _ -&gt; Html.h_ 3 (Html.link_ file (Html.txt_ file)) ) files pure $ Html.html_ ( Html.title_ (eBlogName env) &lt;&gt; Html.stylesheet_ (eStylesheetPath env) ) ( Html.h_ 1 (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;)) &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;) &lt;&gt; mconcat previews ) Create a command-line parser for Env, attach it to the convert-dir command, and pass the result it to the convertDirectory function. Solution src/HsBlog.hs import HsBlog.Env (defaultEnv) convertSingle :: String -&gt; Handle -&gt; Handle -&gt; IO () process :: String -&gt; String -&gt; String process title = Html.render . convert defaultEnv title . Markup.parse app/OptParse.hs import HsBlog.Env ------------------------------------------------ -- * Our command-line options model -- | Model data Options = ConvertSingle SingleInput SingleOutput | ConvertDir FilePath FilePath Env deriving Show ------------------------------------------------ -- * Directory conversion parser pConvertDir :: Parser Options pConvertDir = ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir &lt;*&gt; pEnv -- | Parser for blog environment pEnv :: Parser Env pEnv = Env &lt;$&gt; pBlogName &lt;*&gt; pStylesheet -- | Blog name parser pBlogName :: Parser String pBlogName = strOption ( long &quot;name&quot; &lt;&gt; short 'N' &lt;&gt; metavar &quot;STRING&quot; &lt;&gt; help &quot;Blog name&quot; &lt;&gt; value (eBlogName defaultEnv) &lt;&gt; showDefault ) -- | Stylesheet parser pStylesheet :: Parser String pStylesheet = strOption ( long &quot;style&quot; &lt;&gt; short 'S' &lt;&gt; metavar &quot;FILE&quot; &lt;&gt; help &quot;Stylesheet filename&quot; &lt;&gt; value (eStylesheetPath defaultEnv) &lt;&gt; showDefault ) app/Main.hs main :: IO () main = do options &lt;- parse case options of ConvertDir input output env -&gt; HsBlog.convertDirectory env input output ...   "},{"title":"Summary​","type":1,"pageTitle":"Passing environment variables","url":"/learn-haskell-blog-generator/environment#summary","content":"Which version do you like better? Manually passing arguments, or using Reader? To me, it is not clear that the second version with Reader is better than the first with explicit argument passing in our particular case. Using Reader and ReaderT makes our code a little less friendly toward beginners that are not yet familiar with these concepts and techniques, and we don't see (in this case) much benefit. As programs grow larger, techniques like using Reader become more attractive to use. For our relatively small example, using Reader might not be appropriate. I've included it in this book because it is an important technique to have in our arsenal and I wanted to demonstrate it. It is important to weigh the benefits and costs of using advanced techniques, and it's often better to try and get away with simpler techniques if we can. You can view the git commit ofthe changes we've madeand the code up until now. "},{"title":"Handling errors and multiple files","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/errors_and_files","content":"","keywords":""},{"title":"Links in HTML​","type":1,"pageTitle":"Handling errors and multiple files","url":"/learn-haskell-blog-generator/errors_and_files#links-in-html","content":"Our HTML EDSL currently does not support links or other content modifiers such as bold and italics. We should add these so we can use them when creating an index. Up until now we've passed String to Structure creating functions such as p_and h_. Instead, we could create and pass them a new type, Content, which can be regular text, links, images, and so on.  Exercise: implement what we've just discussed. Follow the compiler errors and refactor what needs refactoring. Solution src/Html/Internal.hs module HsBlog.Html.Internal where import Numeric.Natural -- * Types newtype Html = Html String newtype Structure = Structure String newtype Content = Content String type Title = String -- * EDSL html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; (escape title)) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) -- * Structure p_ :: Content -&gt; Structure p_ = Structure . el &quot;p&quot; . getContentString h_ :: Natural -&gt; Content -&gt; Structure h_ n = Structure . el (&quot;h&quot; &lt;&gt; show n) . getContentString ul_ :: [Structure] -&gt; Structure ul_ = Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString) ol_ :: [Structure] -&gt; Structure ol_ = Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString) code_ :: String -&gt; Structure code_ = Structure . el &quot;pre&quot; . escape instance Semigroup Structure where (&lt;&gt;) c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) instance Monoid Structure where mempty = Structure &quot;&quot; -- * Content txt_ :: String -&gt; Content txt_ = Content . escape link_ :: FilePath -&gt; Content -&gt; Content link_ path content = Content $ elAttr &quot;a&quot; (&quot;href=\\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\\&quot;&quot;) (getContentString content) img_ :: FilePath -&gt; Content img_ path = Content $ &quot;&lt;img src=\\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\\&quot;&gt;&quot; b_ :: Content -&gt; Content b_ content = Content $ el &quot;b&quot; (getContentString content) i_ :: Content -&gt; Content i_ content = Content $ el &quot;i&quot; (getContentString content) instance Semigroup Content where (&lt;&gt;) c1 c2 = Content (getContentString c1 &lt;&gt; getContentString c2) instance Monoid Content where mempty = Content &quot;&quot; -- * Render render :: Html -&gt; String render html = case html of Html str -&gt; str -- * Utilities el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; elAttr :: String -&gt; String -&gt; String -&gt; String elAttr tag attrs content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot; &quot; &lt;&gt; attrs &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; getStructureString :: Structure -&gt; String getStructureString structure = case structure of Structure str -&gt; str getContentString :: Content -&gt; String getContentString content = case content of Content str -&gt; str escape :: String -&gt; String escape = let escapeChar c = case c of '&lt;' -&gt; &quot;&amp;lt;&quot; '&gt;' -&gt; &quot;&amp;gt;&quot; '&amp;' -&gt; &quot;&amp;amp;&quot; '&quot;' -&gt; &quot;&amp;quot;&quot; '\\'' -&gt; &quot;&amp;#39;&quot; _ -&gt; [c] in concat . map escapeChar src/Html.hs module HsBlog.Html ( Html , Title , Structure , html_ , p_ , h_ , ul_ , ol_ , code_ , Content , txt_ , img_ , link_ , b_ , i_ , render ) where import HsBlog.Html.Internal src/Convert.hs module HsBlog.Convert where import qualified HsBlog.Markup as Markup import qualified HsBlog.Html as Html convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html convert title = Html.html_ title . foldMap convertStructure convertStructure :: Markup.Structure -&gt; Html.Structure convertStructure structure = case structure of Markup.Heading n txt -&gt; Html.h_ n $ Html.txt_ txt Markup.Paragraph p -&gt; Html.p_ $ Html.txt_ p Markup.UnorderedList list -&gt; Html.ul_ $ map (Html.p_ . Html.txt_) list Markup.OrderedList list -&gt; Html.ol_ $ map (Html.p_ . Html.txt_) list Markup.CodeBlock list -&gt; Html.code_ (unlines list)   You can view the git commit ofthe changes we've madeand the code up until now. "},{"title":"Creating an index page​","type":1,"pageTitle":"Handling errors and multiple files","url":"/learn-haskell-blog-generator/errors_and_files#creating-an-index-page","content":"With our extended HTML EDSL, we can now create an index page with links to the other pages. To create an index page, we need a list of files with their target destinations, as well as their Markup (so we can extract information to include in our index page, such as the first heading and paragraph). Our output should be an Html page.  We need to implement the following function: buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html  Solution buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html buildIndex files = let previews = map ( \\(file, doc) -&gt; case doc of Markup.Heading 1 heading : article -&gt; Html.h_ 3 (Html.link_ file (Html.txt_ heading)) &lt;&gt; foldMap convertStructure (take 3 article) &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;)) _ -&gt; Html.h_ 3 (Html.link_ file (Html.txt_ file)) ) files in Html.html_ &quot;Blog&quot; ( Html.h_ 1 (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;)) &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;) &lt;&gt; mconcat previews )   "},{"title":"Processing directories​","type":1,"pageTitle":"Handling errors and multiple files","url":"/learn-haskell-blog-generator/errors_and_files#processing-directories","content":"Our general strategy for processing whole directories is going to be: Create the output directoryGrab all file names in a directoryFilter them according to their extension, we want to process txt file and copy other files without modificationWe want to parse each text file, build an index of the result, convert the files to HTML, and write everything to the target directory While our parsing function can't really fail, trying to read or write a file to the file-system can fail in several ways. It would be nice if our static blog generator was robust enough that it wouldn't fail completely if one single file gave it some trouble. This is a good opportunity to learn about error handling in Haskell, both in uneffectful code and for I/O code. In the next few chapters we'll survey the landscape of error handling in Haskell before figuring out the right approach for our use case. "},{"title":"Either with IO?","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/errors_and_files/except","content":"","keywords":""},{"title":"Composing IO + Either using ExceptT​","type":1,"pageTitle":"Either with IO?","url":"/learn-haskell-blog-generator/errors_and_files/except#composing-io--either-using-exceptt","content":"One way to handle this is by using monad transformers. Monad transformers provide a way to stack monad capabilities on top of one another. They are called transformers becausethey take a type that has an instance of monad as input, and return a new type that implements the monad interface, stacking a new capability on top of it. For example, if we want to compose values of a type that is equivalent to IO (Either Error a), using the monadic interface (the function &gt;&gt;=), we can use a monad transformer called ExceptTand stack it over IO. Let's see how ExceptT is defined: newtype ExceptT e m a = ExceptT (m (Either e a))  Remember, a newtype is a new name for an existing type. And if we substitutee with Error and m with IO we get exactly IO (Either Error a) as we wanted. And we can convert an ExceptT Error IO a into IO (Either Error a) using the function runExceptT: runExceptT :: ExceptT e m a -&gt; m (Either e a)  ExceptT implements the monadic interface in a way that combines the capabilities ofEither, and whatever m it takes. Because ExceptT e m has a Monad instance, a specialized version of &gt;&gt;= would look like this: -- Generalized version (&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b -- Specialized version, replace the `m` above with `ExceptT e m`. (&gt;&gt;=) :: Monad m =&gt; ExceptT e m a -&gt; (a -&gt; ExceptT e m b) -&gt; ExceptT e m b  Note that the m in the specialized version still needs to be an instance of Monad.  Unsure how this works? Try to implement &gt;&gt;= for IO (Either Error a): bindExceptT :: IO (Either Error a) -&gt; (a -&gt; IO (Either Error b)) -&gt; IO (Either Error b)  Solution bindExceptT :: IO (Either Error a) -&gt; (a -&gt; IO (Either Error b)) -&gt; IO (Either Error b) bindExceptT mx f = do x &lt;- mx -- `x` has the type `Either Error a` case x of Left err -&gt; pure (Left err) Right y -&gt; f y Note that we didn't actually use the implementation details of Error or IO,Error isn't mentioned at all, and for IO we only used the monadic interface with the do notation. We could write the same function with a more generalized type signature: bindExceptT :: Monad m =&gt; m (Either e a) -&gt; (a -&gt; m (Either e b)) -&gt; m (Either e b) bindExceptT mx f = do x &lt;- mx -- `x` has the type `Either e a` case x of Left err -&gt; pure (Left err) Right y -&gt; f y And because newtype ExceptT e m a = ExceptT (m (Either e a)) we can just pack and unpack that ExceptT constructor and get: bindExceptT :: Monad m =&gt; ExceptT e m a -&gt; (a -&gt; ExceptT e m b) -&gt; ExceptT e m b bindExceptT mx f = ExceptT $ do -- `runExceptT mx` has the type `m (Either e a)` -- `x` has the type `Either e a` x &lt;- runExceptT mx case x of Left err -&gt; pure (Left err) Right y -&gt; runExceptT (f y)   Note that when stacking monad transformers, the order in which we stack them matters. With ExceptT Error IO a, we have an IO operation that when run will return Eitheran error or a value. ExceptT can enjoy both worlds - we can return error values using the function throwError: throwError :: e -&gt; ExceptT e m a  and we can &quot;lift&quot; functions that return a value of the underlying monadic type m to return a value of ExceptT e m a instead: lift :: m a -&gt; ExceptT e m a  for example: getLine :: IO String lift getLine :: ExceptT e IO String  Actually, lift is also a type class function from MonadTrans, the type class of monad transformers. So technically lift getLine :: MonadTrans t =&gt; t IO String, but we are specializing for concreteness. Now, if we had: readFile :: FilePath -&gt; ExceptT IOError IO String writeFile :: FilePath -&gt; String -&gt; ExceptT IOError IO ()  We could compose them again without issue: readFile &quot;input.txt&quot; &gt;&gt;= writeFile &quot;ouptut.html&quot;  But remember - the error type e (in both the case Either and Except) must be the same between composed functions! This means that the type representing errors for both readFile and writeFile must be the same - that would also force anyone using these functions to handle these errors - should a user who called writeFile be required to handle a &quot;file not found&quot; error? Should a user who called readFile be required to handle an &quot;out of disk space&quot; error? There are many many more possible IO errors! &quot;network unreachable&quot;, &quot;out of memory&quot;, &quot;cancelled thread&quot;, we cannot require a user to handle all these errors, or even cover them all in a data type. So what do we do? We give up on this approach for IO code, and use a different one: Exceptions, as we'll see in the next chapter. Note - when we stack ExceptT on top of a different type calledIdentitythat also implements the Monad interface, we get a type that is exactly like Eithercalled Except(without the T at the end). You might sometimes want to use Except instead of Eitherbecause it has a more appropriate name and better API for error handling than Either. "},{"title":"Handling errors with Either","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/errors_and_files/either","content":"","keywords":""},{"title":"Applicative + Traversable​","type":1,"pageTitle":"Handling errors with Either","url":"/learn-haskell-blog-generator/errors_and_files/either#applicative--traversable","content":"The Applicative interface of Either is very powerful, and can be combined with another abstraction calledTraversable - for data structures that can be traversed from left to right, like a linked list or a binary tree. With these, we can combine an unspecified amount of values such as Either ParseDigitError Int, as long as they are all in a data structure that implements Traversable. Let's see an example: ghci&gt; :t &quot;1234567&quot; &quot;1234567&quot; :: String -- remember, a String is an alias for a list of Char ghci&gt; :info String type String :: * type String = [Char] -- Defined in ‘GHC.Base’ ghci&gt; :t map parseDigit &quot;1234567&quot; map parseDigit mystring :: [Either ParseDigitError Int] ghci&gt; map parseDigit &quot;1234567&quot; [Right 1,Right 2,Right 3,Right 4,Right 5,Right 6,Right 7] ghci&gt; :t sequenceA sequenceA :: (Traversable t, Applicative f) =&gt; t (f a) -&gt; f (t a) -- Substitute `t` with `[]`, and `f` with `Either Error` for a specialized version ghci&gt; sequenceA (map parseDigit mystring) Right [1,2,3,4,5,6,7] ghci&gt; map parseDigit &quot;1a2&quot; [Right 1,Left (NotADigit 'a'),Right 2] ghci&gt; sequenceA (map parseDigit &quot;1a2&quot;) Left (NotADigit 'a')  The pattern of doing map and then sequenceA is another function called traverse: ghci&gt; :t traverse traverse :: (Traversable t, Applicative f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b) ghci&gt; traverse parseDigit &quot;1234567&quot; Right [1,2,3,4,5,6,7] ghci&gt; traverse parseDigit &quot;1a2&quot; Left (NotADigit 'a')  We can use traverse on any two types where one implements the Applicativeinterface, like Either a or IO, and the other implements the Traversable interface, like [] (linked lists) andMap k(also known as a dictionary in other languages - a mapping from keys to values). For example using IO and Map. Note that we can construct a Map data structure from a list of tuples using thefromListfunction - the first value in the tuple is the key, and the second is the type. ghci&gt; import qualified Data.Map as M -- from the containers package ghci&gt; file1 = (&quot;output/file1.html&quot;, &quot;input/file1.txt&quot;) ghci&gt; file2 = (&quot;output/file2.html&quot;, &quot;input/file2.txt&quot;) ghci&gt; file3 = (&quot;output/file3.html&quot;, &quot;input/file3.txt&quot;) ghci&gt; files = M.fromList [file1, file2, file3] ghci&gt; :t files :: M.Map FilePath FilePath -- FilePath is an alias of String files :: M.Map FilePath FilePath :: M.Map FilePath FilePath ghci&gt; readFiles = traverse readFile ghci&gt; :t readFiles readFiles :: Traversable t =&gt; t FilePath -&gt; IO (t String) ghci&gt; readFiles files fromList [(&quot;output/file1.html&quot;,&quot;I'm the content of file1.txt\\n&quot;),(&quot;output/file2.html&quot;,&quot;I'm the content of file2.txt\\n&quot;),(&quot;output/file3.html&quot;,&quot;I'm the content of file3.txt\\n&quot;)] ghci&gt; :t readFiles files readFiles files :: IO (Map String String)  Above, we created a function readFiles that will take a mapping from output file pathto input file path and returns an IO operation that when run will read the input files and replace their contents right there in the map! Surely this will be useful later. "},{"title":"Multiple errors​","type":1,"pageTitle":"Handling errors with Either","url":"/learn-haskell-blog-generator/errors_and_files/either#multiple-errors","content":"Note, since Either has the kind * -&gt; * -&gt; * (it takes two type parameters) Either cannot be an instance of Functor or Applicative: instances of these type classes must have the kind * -&gt; *. Remember that when we look at a type class function signature like: fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b  And we want to implement it for a specific type (in place of the f), we need to be able to substitute the f with the target type. If we'd try to do it with Either we would get: fmap :: (a -&gt; b) -&gt; Either a -&gt; Either b  And neither Either a or Either b are saturated, so this won't type check. For the same reason if we'll try to substitute f with, say, Int, we'll get: fmap :: (a -&gt; b) -&gt; Int a -&gt; Int b  Which also doesn't make sense. While we can't use Either, we can use Either e, which has the kind* -&gt; *. Now let's try substituting f with Either e in this signature: liftA2 :: Applicative =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c  And we'll get: liftA2 :: (a -&gt; b -&gt; c) -&gt; Either e a -&gt; Either e b -&gt; Either e c  What this teaches us is that we can only use the applicative interface to combine two Eithers with the same type for the Left constructor. So what can we do if we have two functions that can return different errors? There are a few approaches, the most prominent ones are: Make them return the same error type. Write an ADT that holds all possible error descriptions. This can work in some cases but isn't always ideal. For example a user calling parseDigit shouldn't be forced to handle a possible case that the input might be an empty stringUse a specialized error type for each type, and when they are composed together, map the error type of each function to a more general error type. This can be done with the functionfirstfrom the Bifunctor type class "},{"title":"Monadic interface​","type":1,"pageTitle":"Handling errors with Either","url":"/learn-haskell-blog-generator/errors_and_files/either#monadic-interface","content":"The applicative interface allows us to lift a function to work on multipleEither values (or other applicative functor instances such as IO and Parser). But more often than not, we'd like to use a value from one computation that might return an error in another computation that might return an error. For example, a compiler such has GHC operates in stages, such as lexical analysis, parsing, type-checking, and so on. Each stage depends on the output of the stage before it, and each stage might fail. We can write the types for these functions: tokenize :: String -&gt; Either Error [Token] parse :: [Token] -&gt; Either Error AST typecheck :: AST -&gt; Either Error TypedAST  We want to compose these functions so that they work in a chain. The output of tokenizegoes to parse, and the output of parse goes to typecheck. We know that we can lift a function over an Either (and other functors), we can also lift a function that returns an Either: -- reminder the type of fmap fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b -- specialized for `Either Error` fmap :: (a -&gt; b) -&gt; Either Error a -&gt; Either Error b -- here, `a` is [Token] and `b` is `Either Error AST`: &gt; fmap parse (tokenize string) :: Either Error (Either Error AST)  While this code compiles, it isn't great, because we are building layers of Either Error and we can't use this trick again withtypecheck! typecheck expects an AST, but if we try to fmap it on fmap parse (tokenize string), the a will be Either Error ASTinstead. What we would really like is to flatten this structure instead of nesting it. If we look at the kind of values Either Error (Either Error AST) could have, it looks something like this: Left &lt;error&gt;Right (Left error)Right (Right &lt;ast&gt;)  Exercise: What if we just used pattern matching for this instead? How would this look like? Solution case tokenize string of Left err -&gt; Left err Right tokens -&gt; case parse tokens of Left err -&gt; Left err Right ast -&gt; typecheck ast If we run into an error in a stage, we return that error and stop. If we succeed, we use the value on the next stage.  Flattening this structure for Either is very similar to that last part - the body of the Right tokens case: flatten :: Either e (Either e a) -&gt; Either e a flatten e = case e of Left l -&gt; Left l Right x -&gt; x  Because we have this function, we can now use it on the output offmap parse (tokenize string) :: Either Error (Either Error AST)from before: &gt; flatten (fmap parse (tokenize string)) :: Either Error AST  And now we can use this function again to compose with typecheck: &gt; flatten (fmap typecheck (flatten (fmap parse (tokenize string)))) :: Either Error TypedAST  This flatten + fmap combination looks like a recurring pattern which we can combine into a function: flatMap :: (a -&gt; Either e b) -&gt; Either a -&gt; Either b flatMap func val = flatten (fmap func val)  And now we can write the code this way: &gt; flatMap typecheck (flatMap parse (tokenize string)) :: Either Error TypedAST -- Or using backticks syntax to convert the function to infix form: &gt; typecheck `flatMap` parse `flatMap` tokenize string -- Or create a custom infix operator: (=&lt;&lt;) = flatMap &gt; typeCheck =&lt;&lt; parse =&lt;&lt; tokenize string  This function, flatten (and flatMap as well), have different names in Haskell. They are calledjoinand =&lt;&lt;(pronounced &quot;reverse bind&quot;), and they are the essence of another incredibly useful abstraction in Haskell. If we have a type that can implement: The Functor interface, specifically the fmap functionThe Applicative interface, most importantly the pure functionThis join function They can implement an instance of the Monad type class. With functors, we were able to &quot;lift&quot; a function to work over the type implementing the functor type class: fmap :: (a -&gt; b) -&gt; f a -&gt; f b  With applicative functors we were able to &quot;lift&quot; a function of multiple arguments over multiple values of a type implementing the applicative functor type class, and also lift a value into that type: pure :: a -&gt; f a liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c  With monads we can now flatten (or, &quot;join&quot; in Haskell terminology) types that implement the Monad interface: join :: m (m a) -&gt; m a -- this is =&lt;&lt; with the arguments reversed, pronounced &quot;bind&quot; (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b  With &gt;&gt;= we can write our compilation pipeline from before in a left-to-right manner, which seems to be more popular for monads: &gt; tokenize string &gt;&gt;= parse &gt;&gt;= typecheck  We have already met this function before when we talked about IO. Yes,IO also implements the Monad interface. The monadic interface for IOhelped us with creating a proper ordering of effects. The essence of the Monad interface is the join/&gt;&gt;= functions, and as we've seen we can implement &gt;&gt;= in terms of join, we can also implement join in terms of &gt;&gt;= (try it!). The monadic interface can mean very different things for different types. For IO this is ordering of effects, for Either it is early cutoff, for Logic this means backtracking computation, etc. Again, don't worry about analogies and metaphors, focus on the API and thelaws. Hey, did you check the monad laws? left identity, right identity and associativity? We've already discussed a type class with exactly these laws - the Monoid type class. Maybe this is related to the famous quote about monads being just monoids in something something... "},{"title":"Do notation?​","type":1,"pageTitle":"Handling errors with Either","url":"/learn-haskell-blog-generator/errors_and_files/either#do-notation","content":"Remember the do notation? Turns out it works for any type that is an instance of Monad. How cool is that? Instead of writing: pipeline :: String -&gt; Either Error TypedAST pipeline string = tokenize string &gt;&gt;= \\tokens -&gt; parse tokens &gt;&gt;= \\ast -&gt; typecheck ast  We can write: pipeline :: String -&gt; Either Error TypedAST pipeline string = do tokens &lt;- tokenize string ast &lt;- parse tokens typecheck ast  And it will work! Still, in this particular case tokenize string &gt;&gt;= parse &gt;&gt;= typecheckis so concise it can only be beaten by using&gt;=&gt;or&lt;=&lt;: (&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c -- compare with function composition: (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c  pipeline = tokenize &gt;=&gt; parse &gt;=&gt; typecheck  or pipeline = typecheck &lt;=&lt; parse &lt;=&lt; tokenize  Haskell's ability to create very concise code using abstractions is great once one is familiar with the abstractions. Knowing the monad abstraction, we are now already familiar with the core composition API of many libraries - for example: Concurrentand asynchronous programmingWeb programmingTestingEmulating stateful computationsharing environment between computationsand many more. "},{"title":"Summary​","type":1,"pageTitle":"Handling errors with Either","url":"/learn-haskell-blog-generator/errors_and_files/either#summary","content":"Using Either for error handling is useful for two reasons: We encode possible errors using types, and we force users to acknowledge and handle them, thus making our code more resilient to crashes and bad behavioursThe Functor, Applicative, and Monad interfaces provide us with mechanisms forcomposing functions that might fail (almost) effortlessly - reducing boilerplate while maintaining strong guarantees about our code, and delaying the need to handle errors until it is appropriate "},{"title":"Exceptions","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/errors_and_files/exceptions","content":"","keywords":""},{"title":"Summary​","type":1,"pageTitle":"Exceptions","url":"/learn-haskell-blog-generator/errors_and_files/exceptions#summary","content":"Exceptions are useful and often necessary when we work with IO and want to make sure our program is handling errors gracefully. They have an advantage over Either in that we can easily compose functions that may throw errors of different types, but also have a disadvantage of not encoding types as return values, and therefore does not force us to handle them. For Haskell, the language designers have made a choice for us by designing IO to use exceptions instead of Either. And this is what I would recommend for handling your own effectful computations. However, I think that Either is more appropriate for uneffectful code, because it forces us to acknowledge and handle errors (eventually) thus making our programs more robust. And also because we can only catch exceptions in IO code. "},{"title":"Summary","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/errors_and_files/summary","content":"Summary This was quite a section. Let's recount the things we've learned. We discussed several ways to handle errors in Haskell: Encoding errors as a data type and using the Either type to encode &quot;a value or an error&quot;. Useful approach for uneffectful codeUsing ExceptT when we want to combine the approach in (1) on top on an existing type with monadic capabilitiesUsing exceptions for IO code We've also learned a few new abstractions and techniques: The Traversable type class, for data structures that can be traversed from left to right such as linked lists, binary trees and Maps. Pretty useful when combined with another applicative functor type like Either or IOThe Monad type class extends the Applicative type class with the join :: m (m a) -&gt; m afunction. We learned that Either implements this type class interface and so does IOThe MonadTrans type class for monad transformers for types that take other monads as inputs and provide a monadic interface (&gt;&gt;=, do notation, etc.) while combining both their capabilities. We saw how to stack an Either-like monad transformer, ExceptT, on top of IO We are almost done. Only a couple more things left to do with this project. Let's go! You can view the git commit ofthe changes we've madeand the code up until now.","keywords":""},{"title":"Frequently asked questions","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/faq","content":"","keywords":""},{"title":"General questions​","type":1,"pageTitle":"Frequently asked questions","url":"/learn-haskell-blog-generator/faq#general-questions","content":""},{"title":"Why should I learn Haskell​","type":1,"pageTitle":"Frequently asked questions","url":"/learn-haskell-blog-generator/faq#why-should-i-learn-haskell","content":"I've written a couple of articles on the topic: Consider Haskell (Alternative title, 'What can I do with Haskell?')7 things I learned from Haskell "},{"title":"How to install editor tools​","type":1,"pageTitle":"Frequently asked questions","url":"/learn-haskell-blog-generator/faq#how-to-install-editor-tools","content":"As far as I know, the most recommended setup today for Haskell development is using VSCode or VSCodium together with the marketplace Haskell extension. The Haskell extension uses haskell-language-serverwhich can be installed via GHCup or even via the Haskell extension itself. If you already have a preferred editor,see if HLS supports it, or alternatively use GHCidwhich provides rapid feedback independently from an editor. "},{"title":"How to learn new things​","type":1,"pageTitle":"Frequently asked questions","url":"/learn-haskell-blog-generator/faq#how-to-learn-new-things","content":"The Haskell community keeps marching forward, developing new libraries, tools and techniques as well as creating new material for older concepts. The Haskell planetarium aggregates feeds from several communities into one page, as well as a Haskell Weekly newsletter. You might also find the quite a bit of Haskell presence onTwitter! "},{"title":"Debugging​","type":1,"pageTitle":"Frequently asked questions","url":"/learn-haskell-blog-generator/faq#debugging","content":""},{"title":"How to debug Haskell code​","type":1,"pageTitle":"Frequently asked questions","url":"/learn-haskell-blog-generator/faq#how-to-debug-haskell-code","content":"Most imperative languages provide a step debugger. While theGHCi debugger, exists it is not particularly easy to use, especially because of Haskell's lazy evaluation where things might not evaluated at the order we might intuitively expect. Because of that, Haskellers tend to usetrace debugging and equational reasoning. With trace debugging, we try to verify our assumptions about the code - we use the various trace functions as a &quot;hack&quot; to print variables, functions inputs, functions output or even just say &quot;got here&quot;, from anywhere at the code. After finding something that does not match our assumptions, such as unexpected input or output of a function, we try to think what piece of code could be responsible for the discrepancy, or even use trace debugging again to pinpoint the exact location, and try to use &quot;equational reasoning&quot; to evaluate the offending code that betrayed our expectations. If it's easy to do, we try running the function in ghci with different inputs to check our assumptions as well. Because Haskell focuses on immutability, composibility and using types to eliminate many classes of possible errors, &quot;local reasoning&quot; becomes possible, and trace debugging becomes a viable strategy for debugging Haskell programs. "},{"title":"How to understand type errors​","type":1,"pageTitle":"Frequently asked questions","url":"/learn-haskell-blog-generator/faq#how-to-understand-type-errors","content":"GHC type errors are often not the most friendly errors messages, but they mean well! They are just trying to help us find inconsistencies in our code - often with regards to type usage, they help us avoid making errors. When you run into error messages, start by reading the messages themselves carefully until you get used to them, and then the offending code hinted by the error message. As you gain experience, it is likely that the most important part of an error will be the location of the offending code, and by reading the code we can find the error without the actual error message. Adding type signatures and annotations to test your understanding of the types also helps greatly. We can even ask GHC for the expected type in a certain place by usingtyped holes. "},{"title":"My program is slow. Why?​","type":1,"pageTitle":"Frequently asked questions","url":"/learn-haskell-blog-generator/faq#my-program-is-slow-why","content":"There could be various reasons. From inefficient algorithms orunsuited data structures for the task in terms of time complexity of the common operations, to less efficient memory representations (this is another reminder to use Text over String in most cases), and laziness issues (again, the evaluation strategy!). The performance section in my Haskell study plan links to various resources on Haskell evaluation, profiling and case studies. "},{"title":"Design​","type":1,"pageTitle":"Frequently asked questions","url":"/learn-haskell-blog-generator/faq#design","content":""},{"title":"How to structure programs​","type":1,"pageTitle":"Frequently asked questions","url":"/learn-haskell-blog-generator/faq#how-to-structure-programs","content":"Start with the imperative shell functional core approach, define EDSLs with the combinator pattern for logic if needed, use capabilities such as State locally if needed, maybe add an environment configuration with ReaderT, see how it goes. If that approach fails you, look at why it fails and examine other solutions according to your needs. "},{"title":"How to model data​","type":1,"pageTitle":"Frequently asked questions","url":"/learn-haskell-blog-generator/faq#how-to-model-data","content":"Modeling data using ADTs are usually the way to go. Often programmers coming from object oriented background tend to look at type classes as a way to define methods similar to inheritance, but this often isn't the right approach and ADTs with different constructors for different alternatives go a long way. Remember that even OOP people often preach for composition over inheritance. Use functions to define behavior on data rather than trying to couple the two together. "},{"title":"Gluing things together","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/glue","content":"Gluing things together In this chapter we are going to glue the pieces that we built together and build an actual blog generator. We will: Read markup text from a fileParse the text to a DocumentConvert the result to our Html EDSLGenerate HTML codeWrite it to file While doing so, we will learn: How to work with IOHow to import external libraries to process whole directories and create a simple command-line interface","keywords":""},{"title":"Working with IO","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/glue/io","content":"","keywords":""},{"title":"Purely functional​","type":1,"pageTitle":"Working with IO","url":"/learn-haskell-blog-generator/glue/io#purely-functional","content":"Originally, Haskell was designed as an open standardfunctional programming language with non-strict semantics, to serve as a unifying language for future research in functional language design. In GHC Haskell, we use a lazy evaluation strategy to implement non-strict semantics (We've talked about lazinessbefore). The requirement for non-strict semantics raises interesting challenges: How do we design a language that can do more than just evaluate expressions, how do we model interaction with the outside world, how do we do I/O? The challenge with doing I/O operations in a language with a lazy evaluation strategy is that as programs grow larger, the order of evaluation becomes less trivial to figure out. Consider this hypothetical code example (which won't actually type-check in Haskell, we'll see why soon): addWithInput :: Int -&gt; Int addWithInput n = readIntFromStdin + n main = let result1 = addWithInput 1 result2 = addWithInput 2 in print (result2 - result1)  This hypothetical program will read 2 integers from the standard input, and then will subtract the second one (+2) from the first one (+1), or so we would expect if this was a strict language. In a strict language we expect the order of operations to happen from the top-down. But in a lazy language we don't evaluate an expression until it is needed, and so neither result1 nor result2 are evaluated until we wish to print the result of subtracting one from the other. And then when we try to evaluate -, it evaluates the two arguments from left to right, so we first evaluate result2. Evaluating result2, with substitution, means to replace occurrences of nwith the input 2, and then evaluate the top level function (+), which is a primitive function. We then evaluate its arguments, readIntFromStdinand then n; at this point we are reading the first integer from the stdin. After calculating the result, we can move to evaluate result1, whichwill read the second integer from stdin. This is the complete opposite of what we wanted! Issues like these make lazy evaluation hard to work with in the presence ofside effects - when the evaluation of an expression can affect or be affected by the outside world, this includes reading/writing from mutable memory or performing I/O operations. We call functions that have side-effects, such as addWithInput, impure functions. And an unfortunate consequence of impure functions is thatthey can return different results even when they take the same input. The presence of impure functions makes it harder for us to reason about lazy evaluation, and also messes up our ability to use equational reasoning to understand programs. Therefore, in Haskell, it was decided to only allow pure functions and expressions - ones that have no side effects. Pure functions will always return the same output (given the same input) and evaluating pure expressions is deterministic. But now, how can we do I/O operations? There are many possible solutions For Haskell it was decided to design an interface with an accompanied type called IO. IO's interface will force a distinction from non-I/O expressions, and will also require that in order to combinemultiple IO operations, we will have to specify the order the operations. "},{"title":"IO​","type":1,"pageTitle":"Working with IO","url":"/learn-haskell-blog-generator/glue/io#io","content":"IO is an opaque type, like our Html type in which we hide its internal representation from the user behind an interface. But in this case IO is a built-in type that is hidden by the Haskell language rather than a module. Similar to Maybe, IO has a payload type which represents the result of an IO operation. When there isn't a meaningful result, we use the unit type,() (which only has one value: ()) to represent that. Here are a few IO operations and functions that return IO operations: putStrLn :: String -&gt; IO () getLine :: IO String getArgs :: IO [String] lookupEnv :: String -&gt; IO (Maybe String) writeFile :: FilePath -&gt; String -&gt; IO ()  Notice that each function returns an IO &lt;something&gt;, but what does that mean? The meaning behind IO a is that it is a description of a program (or subroutine) that when executed will produce some value of type a, and may do some I/O effects during execution. Executing an IO a is different from evaluating it. Evaluating an IO a expression is pure - the evaluation will always reduce to the same description of a program. This helps us keep purity and equational reasoning! The Haskell runtime will execute the entry point to the program (the expression main, that must have the type IO ()) in order for our IO operation to also run - it has to be combined into the main expression - let's see what that means. "},{"title":"Combining IO expressions​","type":1,"pageTitle":"Working with IO","url":"/learn-haskell-blog-generator/glue/io#combining-io-expressions","content":"Just like our Html.Structure type, the IO interface provides combinators for composing small IO operations into bigger ones. This interface also ensures that the order of operations is well defined! Note that, just like the &lt;&gt; we've defined for Html.Structure, the combinators for IOare implemented as type-class instances rather than specialized variants (for example our append_ function was a specialized version of &lt;&gt; tailored only for Structure). In this section I will introduce specialized type signatures rather than generalized ones, because I think it'll be easier to digest, but we'll talk about the generalized versions later. "},{"title":">>=","type":1,"pageTitle":"Working with IO","url":"/learn-haskell-blog-generator/glue/io##","content":"Our first combinator is &gt;&gt;= (pronounced bind), and is the most useful of the bunch: (&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b  This combinator takes two arguments, the first is an IO operation, and the second is a function that takes as input the result of the first IO operation and returns a new IO b which is the final result. Here are a few examples using the functions we described above: Echo getLine &gt;&gt;= (\\line -&gt; putStrLn line) We are reading a line from the standard input on the left of &gt;&gt;=, we receive the input to the right of &gt;&gt;= as an argument to the lambda function, and then write it to the standard output in the body of the lambda function.&gt;&gt;='s role here is to pass the result of the IO operation on the left to the function returning an IO operation on the right. Notice how &gt;&gt;= defines an order of operations - from left to right. The type of each sub expression here is: getLine :: IO String putStrLn :: String -&gt; IO () (&gt;&gt;=) :: IO String -&gt; (String -&gt; IO ()) -&gt; IO () line :: String Question: what is the type of the whole expression? Answer IO () Also note that this example can be written in a more concise manner in point free style getLine &gt;&gt;= putStrLn. Appending two inputs getLine &gt;&gt;= (\\honorific -&gt; getLine &gt;&gt;= (\\name -&gt; putStrLn (&quot;Hello &quot; ++ honorific ++ &quot; &quot; ++ name))) This subroutine combines multiple operations together, it reads two lines from the standard input and prints a greeting. Note that: Using &gt;&gt;= defines the order of operation from left to rightBecause of the scoping rules in Haskell, honorific will be in scope in the body of the function for which it is its input, including the most inner function This is a bit hard to read, but we can remove the parenthesis and add indentation to make it a bit easier to read: getLine &gt;&gt;= \\honorific -&gt; getLine &gt;&gt;= \\name -&gt; putStrLn (&quot;Hello &quot; ++ honorific ++ &quot; &quot; ++ name)  Let's see a few more combinators! "},{"title":"*> and >>​","type":1,"pageTitle":"Working with IO","url":"/learn-haskell-blog-generator/glue/io#-and-","content":"(*&gt;) :: IO a -&gt; IO b -&gt; IO b (&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b  *&gt; and &gt;&gt; have the same type signature for IO and mean the same thing. In fact, *&gt; is a slightly more generalized version of &gt;&gt; and can always be used instead of &gt;&gt;, which only still exists to avoid breaking backward compatibility. *&gt; for IO means run the first IO operation, discard the result then run the second operation. It can be implemented using &gt;&gt;=: a *&gt; b = a &gt;&gt;= \\_ -&gt; b  This combinator is useful when we want to run several IO operations one after the other that might not return anything meaningful, such as putStrLn: putStrLn &quot;hello&quot; *&gt; putStrLn &quot;world&quot;  "},{"title":"pure and return​","type":1,"pageTitle":"Working with IO","url":"/learn-haskell-blog-generator/glue/io#pure-and-return","content":"pure :: a -&gt; IO a  like *&gt; and &gt;&gt;, pure is a more general version of return. pure also has the advantage of not having a resemblance to an unrelated keyword in other languages. Remember that we said IO a is a description of a program that when executed will produce some value of type a and may do some I/O effects during execution? With pure, we can build an IO a that does no I/O, and will produce a specific value of type a, the one we supply to pure! This function is useful when we want to do some uneffectful computation that depends on IO. For example: confirm :: IO Bool confirm = putStrLn &quot;Are you sure? (y/n)&quot; *&gt; getLine &gt;&gt;= \\answer -&gt; case answer of &quot;y&quot; -&gt; pure True &quot;n&quot; -&gt; pure False _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt; confirm  Trying to return just True or False here wouldn't work because of the type of &gt;&gt;=: (&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b  The right side of &gt;&gt;= in our code example (\\answer -&gt; case ...) must be of type String -&gt; IO Bool. This is because: getLine :: IO String, so the a in the type signature of &gt;&gt;=should be the same as String in this instance, andconfirm :: IO Bool, so b should be Bool "},{"title":"fmap and <$>​","type":1,"pageTitle":"Working with IO","url":"/learn-haskell-blog-generator/glue/io#fmap-and-","content":"fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b  &lt;$&gt; is the infix version of fmap. Use it at your discretion. What if we want a function that reads a line from stdin and returns it with ! at the end? We could use a combination of &gt;&gt;= and pure: getLine &gt;&gt;= \\line -&gt; pure (line ++ &quot;!&quot;)  The pattern is unified to the fmap function: fmap (\\line -&gt; line ++ &quot;!&quot;) getLine  fmap applies a function to the value to be returned from the IO operation, also known as &quot;mapping&quot; over it. (By the way, Have you noticed the similarities between fmap and map :: (a -&gt; b) -&gt; [a] -&gt; [b]?) "},{"title":"Summary​","type":1,"pageTitle":"Working with IO","url":"/learn-haskell-blog-generator/glue/io#summary","content":"Here's a list of IO combinators we ran into: -- chaining IO operations: passing the *result* of the left IO operation -- as an argument to the function on the right. -- Pronounced &quot;bind&quot;. (&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b -- sequence two IO operations, discarding the payload of the first. (*&gt;) :: IO a -&gt; IO b -&gt; IO b -- &quot;lift&quot; a value into IO context, does not add any I/O effects. pure :: a -&gt; IO a -- &quot;map&quot; (or apply a function) over the payload value of an IO operation. fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b  "},{"title":"IO is first class​","type":1,"pageTitle":"Working with IO","url":"/learn-haskell-blog-generator/glue/io#io-is-first-class","content":"The beauty of IO is that it's a completely first-class construct in the language, and is not really different from Maybe, Either or Structure. We can pass it to functions, put it in a container, etc. Remember that it represents a description of a program, and without combining it into main in some way won't actuallydo anything. It is just a value! Here's an example of a function that takes IO actions as input: whenIO :: IO Bool -&gt; IO () -&gt; IO () whenIO cond action = cond &gt;&gt;= \\result -&gt; if result then action else pure ()  And how it can be used: main :: IO () main = putStrLn &quot;This program will tell you a secret&quot; *&gt; whenIO confirm (putStrLn &quot;IO is actually pretty awesome&quot;) *&gt; putStrLn &quot;Bye&quot;  Notice how putStrLn &quot;IO is actually pretty awesome&quot; isn't executed right away, but only if it is what whenIO returns, and in turn is combinedwith *&gt; as part of the main expression. "},{"title":"Getting out of IO?​","type":1,"pageTitle":"Working with IO","url":"/learn-haskell-blog-generator/glue/io#getting-out-of-io","content":"What we've seen above has great consequences to the Haskell language. In our Html type, we had a function render :: Html -&gt; Stringthat could turn an Html to a string value. In Haskell, there is no way to implement a function such as execute :: IO a -&gt; athat preserves purity and equational reasoning! Also, IO is opaque. It does not let us examine it. So we are really bound to what the Haskell API for IO allows us to do. This means that we need to think about using IO differently! In Haskell, once we get into IO, there is no getting out. The only thing we can do is to build bigger IO computations by combiningit with more IO computations. We also can't use IO a in place of an a. For example, we can't write getLine ++ &quot;!&quot; because ++ expects both sides to be String, but getLine's type is IO String. The types do not match! We have to use fmap and the return type must be IO String, like we've seen before. In Haskell we like to keep IO usage minimal, and we like to push it to the edges of the program. This pattern is often called Functional core, imperative shell. "},{"title":"Functional core, imperative shell​","type":1,"pageTitle":"Working with IO","url":"/learn-haskell-blog-generator/glue/io#functional-core-imperative-shell","content":"In our blog generator program, we want to read a file, parse it, convert it to HTML, and then print the result to the console. In many programming languages, we might interleave reading from the file with parsing, and writing to the file with the HTML conversion. But we don't mix these here. Parsing operates on a String value rather than some file handle, and Html is being converted to a String rather than being written to the screen directly. This approach of separating IO and pushing it to the edge of the program gives us a lot of flexibility. These functions without IO are easier to test and examine (because they are guaranteed to have deterministic evaluation!), and they are more modular and can work in many contexts (reading from stdin, reading from network socket, writing to an HTTP connection, and more). This pattern is often a good approach for building Haskell programs, especially batch programs. "},{"title":"Building a blog generator​","type":1,"pageTitle":"Working with IO","url":"/learn-haskell-blog-generator/glue/io#building-a-blog-generator","content":"We'd like to start building a blog generator, and we want to have the following interface: If the user calls the program without arguments, we will read from the standard input, and write to the standard outputIf the user calls the program with two arguments, the first one will be the input file name, and the second one will be the output file nameIf the output file already exists, we'll ask the user if they want to overwrite the fileOn any other kind of input, we'll print a generic message explaining the proper usage We are going to need a few functions: getArgs :: IO [String] -- Get the program arguments getContents :: IO String -- Read all of the content from stdin readFile :: FilePath -&gt; IO String -- Read all of the content from a file writeFile :: FilePath -&gt; String -&gt; IO () -- Write a string into a file doesFileExist :: FilePath -&gt; IO Bool -- Checks whether a file exists  And the following imports: import System.Directory (doesFileExist) import System.Environment (getArgs)  We don't need to add the following import because Prelude already imports these functions for us: -- imported by Prelude import System.IO (getContents, readFile, writeFile)   Implement a function process :: Title -&gt; String -&gt; String which will parse a document to markup, convert it to HTML, and then render the HTML to a string. Answer process :: Html.Title -&gt; String -&gt; String process title = Html.render . convert title . Markup.parse  Try implementing the &quot;imperative shell&quot; for our blog generator program. Start with main, pattern match on the result of getArgs, and decide what to do. Look back at the examples above for inspiration. Answer -- Main.hs module Main where import qualified Markup import qualified Html import Convert (convert) import System.Directory (doesFileExist) import System.Environment (getArgs) main :: IO () main = getArgs &gt;&gt;= \\args -&gt; case args of -- No program arguments: reading from stdin and writing to stdout [] -&gt; getContents &gt;&gt;= \\content -&gt; putStrLn (process &quot;Empty title&quot; content) -- With input and output file paths as program arguments [input, output] -&gt; readFile input &gt;&gt;= \\content -&gt; doesFileExist output &gt;&gt;= \\exists -&gt; let writeResult = writeFile output (process input content) in if exists then whenIO confirm writeResult else writeResult -- Any other kind of program arguments _ -&gt; putStrLn &quot;Usage: runghc Main.hs [-- &lt;input-file&gt; &lt;output-file&gt;]&quot; process :: Html.Title -&gt; String -&gt; String process title = Html.render . convert title . Markup.parse confirm :: IO Bool confirm = putStrLn &quot;Are you sure? (y/n)&quot; *&gt; getLine &gt;&gt;= \\answer -&gt; case answer of &quot;y&quot; -&gt; pure True &quot;n&quot; -&gt; pure False _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt; confirm whenIO :: IO Bool -&gt; IO () -&gt; IO () whenIO cond action = cond &gt;&gt;= \\result -&gt; if result then action else pure ()   "},{"title":"Do notation​","type":1,"pageTitle":"Working with IO","url":"/learn-haskell-blog-generator/glue/io#do-notation","content":"While using &gt;&gt;= to chain IO actions is manageable, Haskell provides an even more convenient syntactic sugar called do notationwhich emulates imperative programming. A do block starts with the do keyword, and continues with one or more &quot;statements&quot; which can be one of the following: An expression of type IO (), such as: putStrLn &quot;Hello&quot;if True then putStrLn &quot;Yes&quot; else putStrLn &quot;No&quot; A let block, such as let x = 1or multiple let declarations: let x = 1 y = 2 Note that we do not write the in here. A binding &lt;variable&gt; &lt;- &lt;expresion&gt;, such as line &lt;- getLine  And the last &quot;statement&quot; must be an expression of type IO &lt;something&gt; - this will be the result type of the do block. These constructs are desugared (translated) by the Haskell compiler to: &lt;expression&gt; *&gt;,let ... in and&lt;expression&gt; &gt;&gt;= \\&lt;variable&gt; respectively. For example: greeting :: IO () greeting = do putStrLn &quot;Tell me your name.&quot; let greet name = &quot;Hello, &quot; ++ name ++ &quot;!&quot; name &lt;- getLine putStrLn (greet name)  Is just syntactic sugar for: greeting :: IO () greeting = putStrLn &quot;Tell me your name.&quot; *&gt; let greet name = &quot;Hello, &quot; ++ name ++ &quot;!&quot; in getLine &gt;&gt;= \\name -&gt; putStrLn (greet name)  It's important to note the difference between let and &lt;- (bind).let is used to give a new name to an expression which will be in scope for subsequent lines, and &lt;- is used to bind the result a in an IO aaction to a new name which will be in scope for subsequent lines. Do notation is very very common and is often preferable to using &gt;&gt;= directly.  Exercise: Translate the examples in this chapter to do notation. Exercise: Translate our glue code for the blog generator to do notation. Solution -- Main.hs module Main where import qualified Markup import qualified Html import Convert (convert) import System.Directory (doesFileExist) import System.Environment (getArgs) main :: IO () main = do args &lt;- getArgs case args of -- No program arguments: reading from stdin and writing to stdout [] -&gt; do content &lt;- getContents putStrLn (process &quot;Empty title&quot; content) -- With input and output file paths as program arguments [input, output] -&gt; do content &lt;- readFile input exists &lt;- doesFileExist output let writeResult = writeFile output (process input content) if exists then whenIO confirm writeResult else writeResult -- Any other kind of program arguments _ -&gt; putStrLn &quot;Usage: runghc Main.hs [-- &lt;input-file&gt; &lt;output-file&gt;]&quot; process :: Html.Title -&gt; String -&gt; String process title = Html.render . convert title . Markup.parse confirm :: IO Bool confirm = do putStrLn &quot;Are you sure? (y/n)&quot; answer &lt;- getLine case answer of &quot;y&quot; -&gt; pure True &quot;n&quot; -&gt; pure False _ -&gt; do putStrLn &quot;Invalid response. use y or n&quot; confirm whenIO :: IO Bool -&gt; IO () -&gt; IO () whenIO cond action = do result &lt;- cond if result then action else pure ()   "},{"title":"Summary​","type":1,"pageTitle":"Working with IO","url":"/learn-haskell-blog-generator/glue/io#summary-1","content":"In this chapter we discussed what &quot;purely functional&quot; means, where the initial motivation for being purely functional comes from, and how Haskell's I/O interface allows us to create descriptions of programs without breaking purity. We have also achieved a major milestone. With this chapter, we have implemented enough pieces to finally run our program on a single document and get an HTML rendered result! However, our command-line interface is still sub-par. We want to render a blog with multiple articles, create an index page, and more. We still have more to do to be able to call our program a blog generator. Let's keep going! You can view the git commit ofthe changes we've madeand the code up until now. "},{"title":"Lets code already!","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/errors_and_files/implementation","content":"","keywords":""},{"title":"New module​","type":1,"pageTitle":"Lets code already!","url":"/learn-haskell-blog-generator/errors_and_files/implementation#new-module","content":"Let's create a new module, HsBlog.Directory, which will be responsible for handling directories and multiple files. From this module we will export the convertDirectoryand buildIndex functions we've defined before: -- | Process multiple files and convert directories module HsBlog.Directory ( convertDirectory , buildIndex ) where  In this module we are going to use thedirectoryand filepathlibraries to manipulate directories, files and filepaths. We'll use the new abstractions we've learned, Traversable and Monad, and the concepts and types we've learned about: Either, IO and exceptions. For all of that, we need quite a few imports: import qualified HsBlog.Markup as Markup import qualified HsBlog.Html as Html import HsBlog.Convert (convert, convertStructure) import Data.List (partition) import Data.Traversable (for) import Control.Monad (void, when) import System.IO (hPutStrLn, stderr) import Control.Exception (catch, displayException, SomeException(..)) import System.Exit (exitFailure) import System.FilePath ( takeExtension , takeBaseName , (&lt;.&gt;) , (&lt;/&gt;) , takeFileName ) import System.Directory ( createDirectory , removeDirectoryRecursive , listDirectory , doesDirectoryExist , copyFile )  If you are unsure what a specific function we're using does, look it up atHoogle, read the type signature and the documentation, and play around with it in ghci. "},{"title":"Converting a directory​","type":1,"pageTitle":"Lets code already!","url":"/learn-haskell-blog-generator/errors_and_files/implementation#converting-a-directory","content":"We can start by describing the high-level function convertDirectory which encapsulates many smaller functions, each responsible for doing a specific thing.convertDirectory is quite imperative looking, and looks like a different way to describe the steps of completing our task: -- | Copy files from one directory to another, converting '.txt' files to -- '.html' files in the process. Recording unsuccessful reads and writes to stderr. -- -- May throw an exception on output directory creation. convertDirectory :: FilePath -&gt; FilePath -&gt; IO () convertDirectory inputDir outputDir = do DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir createOutputDirectoryOrExit outputDir let outputHtmls = txtsToRenderedHtml filesToProcess copyFiles outputDir filesToCopy writeFiles outputDir outputHtmls putStrLn &quot;Done.&quot;  Here we trust that each IO function handles errors responsibly, and terminates the project when necessary. Let's examine the steps in order. "},{"title":"getDirFilesAndContent​","type":1,"pageTitle":"Lets code already!","url":"/learn-haskell-blog-generator/errors_and_files/implementation#getdirfilesandcontent","content":"-- | The relevant directory content for our application data DirContents = DirContents { dcFilesToProcess :: [(FilePath, String)] -- ^ File paths and their content , dcFilesToCopy :: [FilePath] -- ^ Other file paths, to be copied directly } -- | Returns the directory content getDirFilesAndContent :: FilePath -&gt; IO DirContents  getDirFilesAndContent is responsible for providing the relevant files for processing -- both the ones we need to convert to markup (and their textual content) and other files we might want to copy as-is (such as images and style-sheets): -- | Returns the directory content getDirFilesAndContent :: FilePath -&gt; IO DirContents getDirFilesAndContent inputDir = do files &lt;- map (inputDir &lt;/&gt;) &lt;$&gt; listDirectory inputDir let (txtFiles, otherFiles) = partition ((== &quot;.txt&quot;) . takeExtension) files txtFilesAndContent &lt;- applyIoOnList readFile txtFiles &gt;&gt;= filterAndReportFailures pure $ DirContents { dcFilesToProcess = txtFilesAndContent , dcFilesToCopy = otherFiles }  This function does 4 important things: Lists all the files in the directorySplits the files into 2 groups according to their file extensionReads the contents of the .txt files and report when files fail to be readReturns the results. We've defined a data type to make the result content more obvious Part (3) is a little bit more involved than the rest, let's explore it. applyIoOnList​  applyIoOnList has the following type signature: applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)]  It tries to apply an IO function on a list of values, and document successes and failures. Try to implement it! If you need a hint for which functions to use, see the import list we wrote earlier. Answer -- | Try to apply an IO function on a list of values, document successes and failures applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)] applyIoOnList action inputs = do for inputs $ \\input -&gt; do maybeResult &lt;- catch (Right &lt;$&gt; action input) ( \\(SomeException e) -&gt; do pure $ Left (displayException e) ) pure (input, maybeResult)   applyIoOnList is a higher order function that applies a particular IO function (in our case readFile) on a list of things (in our case FilePaths). For each thing, it returns the thing itself along with the result of applying the IO function as an Either, where the Left side is a Stringrepresentation of an error if one occurred. Notice how much the type of this function tells us about what it might do. Because the types are polymorphic, there is nothing else to do with the as other than apply them to the function, and nowhere to generate bfrom other than the result of the function. Note: when I first wrote this function, it was specialized to work only on readFile, take specifically [FilePath] and return IO [(FilePath, Either String String)]. But after running into other use cases where I could use it (writeFiles and copyFiles) I refactored out the action, the input type and the return type. This function uses exceptions to catch any error that might be thrown, and encodes both the failure and success cases in the type system using Either, delaying the handling of exceptions to the function caller while making sure it won't be forgotten! Next, let's look at the function that handles the errors by reporting and then filtering out all the cases that failed. filterAndReportFailures​  filterAndReportFailures has the following type signature: filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)]  It filters out unsuccessful operations on files and reports errors to the stderr. Try to implement it! Answer -- | Filter out unsuccessful operations on files and report errors to stderr. filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)] filterAndReportFailures = foldMap $ \\(file, contentOrErr) -&gt; case contentOrErr of Left err -&gt; do hPutStrLn stderr err pure [] Right content -&gt; pure [(file, content)] This code may seem a bit surprising - how come we can use foldMap here? Reminder, the type of foldMap is: foldMap :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m If we specialize this function for our use case, substituting the general type with the types we are using, we learn that IO [(a, b)] is a monoid. And indeed - [a] is a monoid for any a with [] (the empty list) as memptyand ++ as &lt;&gt;, but also IO a is a monoid for any a that is itself a monoid with pure mempty as mempty and liftA2 (&lt;&gt;) as &lt;&gt;! Using these instances, we can map over the content, handle errors, and return an empty list to filter out a failed case, or a singleton list to keep the result. And the fold in foldMap will concatenate the resulting list where we return all of the successful cases! If you've written this in a different way that does the same thing, that's fine too! It's just nice to see how sometimes abstractions can be used to write concise code.  These functions are responsible for fetching the right information. Next, let's look at the code for creating a new directory. "},{"title":"createOutputDirectoryOrExit​","type":1,"pageTitle":"Lets code already!","url":"/learn-haskell-blog-generator/errors_and_files/implementation#createoutputdirectoryorexit","content":"-- | Creates an output directory or terminates the program createOutputDirectoryOrExit :: FilePath -&gt; IO () createOutputDirectoryOrExit outputDir = whenIO (not &lt;$&gt; createOutputDirectory outputDir) (hPutStrLn stderr &quot;Cancelled.&quot; *&gt; exitFailure) -- | Creates the output directory. -- Returns whether the directory was created or not. createOutputDirectory :: FilePath -&gt; IO Bool createOutputDirectory dir = do dirExists &lt;- doesDirectoryExist dir create &lt;- if dirExists then do override &lt;- confirm &quot;Output directory exists. Override?&quot; when override (removeDirectoryRecursive dir) pure override else pure True when create (createDirectory dir) pure create  createOutputDirectoryOrExit itself is not terribly exciting, it does what it is named -- it tries to create the output directory, and exits the program in case it didn't succeed. createOutputDirectory is the function that actually does the heavy lifting. It checks if the directory already exists, and checks if the user would like to override it. If they do, we remove it and create the new directory; if they don't, we do nothing and report their decision. "},{"title":"txtsToRenderedHtml​","type":1,"pageTitle":"Lets code already!","url":"/learn-haskell-blog-generator/errors_and_files/implementation#txtstorenderedhtml","content":"let outputHtmls = txtsToRenderedHtml filesToProcess   In this part of the code we convert files to markup and change the input file paths to their respective output file paths (.txt -&gt; .html). We then build the index page, and convert everything to HTML. Implement txtsToRenderedHtml, which has the following type signature: txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]  Hint I implemented this by defining three functions: txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)] toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document) convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)  . Answer -- | Convert text files to Markup, build an index, and render as html. txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)] txtsToRenderedHtml txtFiles = let txtOutputFiles = map toOutputMarkupFile txtFiles index = (&quot;index.html&quot;, buildIndex txtOutputFiles) in map (fmap Html.render) (index : map convertFile txtOutputFiles) toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document) toOutputMarkupFile (file, content) = (takeBaseName file &lt;.&gt; &quot;html&quot;, Markup.parse content) convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html) convertFile (file, doc) = (file, convert file doc) One possibly surprising thing about this code could be the map (fmap Html.render)part. We can use fmap on the tuple because it is a Functor on the second argument, just like Either!  "},{"title":"copyFiles and writeFiles​","type":1,"pageTitle":"Lets code already!","url":"/learn-haskell-blog-generator/errors_and_files/implementation#copyfiles-and-writefiles","content":"The only thing left to do is to write the directory content, after the processing is completed, to the newly created directory: -- | Copy files to a directory, recording errors to stderr. copyFiles :: FilePath -&gt; [FilePath] -&gt; IO () copyFiles outputDir files = do let copyFromTo file = copyFile file (outputDir &lt;/&gt; takeFileName file) void $ applyIoOnList copyFromTo files &gt;&gt;= filterAndReportFailures  Here we use applyIoOnList again to do something a bit more complicated, instead of reading from a file, it copies from the input path to a newly generated output path. Then we pass the result (which has the type [(FilePath, Either String ())]) to filterAndReportFailures to print the errors and filter out the unsuccessful copies. Because we are not really interested in the output of filterAndReportFailures, we discard it with void, returning () as a result instead: -- | Write files to a directory, recording errors to stderr. writeFiles :: FilePath -&gt; [(FilePath, String)] -&gt; IO () writeFiles outputDir files = do let writeFileContent (file, content) = writeFile (outputDir &lt;/&gt; file) content void $ applyIoOnList writeFileContent files &gt;&gt;= filterAndReportFailures  Once again, this code looks almost exactly like copyFiles, but the types are different. Haskell's combination of parametric polymorphism + type class for abstractions is really powerful, and has helped us reduce quite a bit of code.  This pattern of using applyIoOnList and then filterAndReportFailureshappens more than once. It might be a good candidate for refactoring. Try it! What do you think about the resulting code? Is it easier or more difficult to understand? Is it more modular or less? What are the pros and cons?  "},{"title":"Summary​","type":1,"pageTitle":"Lets code already!","url":"/learn-haskell-blog-generator/errors_and_files/implementation#summary","content":"With that, we have completed our HsBlog.Directory module that is responsible for converting a directory safely. Note that the code could probably be simplified quite a bit if we were fine with errors crashing the entire program altogether, but sometimes this is the price we pay for robustness. It is up to you to choose what you can live with and what not, but I hope this saga has taught you how to approach error handling in Haskell in case you need to. View the full module: HsBlog.Directory -- | Process multiple files and convert directories module HsBlog.Directory ( convertDirectory , buildIndex ) where import qualified HsBlog.Markup as Markup import qualified HsBlog.Html as Html import HsBlog.Convert (convert, convertStructure) import Data.List (partition) import Data.Traversable (for) import Control.Monad (void, when) import System.IO (hPutStrLn, stderr) import Control.Exception (catch, displayException, SomeException(..)) import System.Exit (exitFailure) import System.FilePath ( takeExtension , takeBaseName , (&lt;.&gt;) , (&lt;/&gt;) , takeFileName ) import System.Directory ( createDirectory , removeDirectoryRecursive , listDirectory , doesDirectoryExist , copyFile ) -- | Copy files from one directory to another, converting '.txt' files to -- '.html' files in the process. Recording unsuccessful reads and writes to stderr. -- -- May throw an exception on output directory creation. convertDirectory :: FilePath -&gt; FilePath -&gt; IO () convertDirectory inputDir outputDir = do DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir createOutputDirectoryOrExit outputDir let outputHtmls = txtsToRenderedHtml filesToProcess copyFiles outputDir filesToCopy writeFiles outputDir outputHtmls putStrLn &quot;Done.&quot; ------------------------------------ -- * Read directory content -- | Returns the directory content getDirFilesAndContent :: FilePath -&gt; IO DirContents getDirFilesAndContent inputDir = do files &lt;- map (inputDir &lt;/&gt;) &lt;$&gt; listDirectory inputDir let (txtFiles, otherFiles) = partition ((== &quot;.txt&quot;) . takeExtension) files txtFilesAndContent &lt;- applyIoOnList readFile txtFiles &gt;&gt;= filterAndReportFailures pure $ DirContents { dcFilesToProcess = txtFilesAndContent , dcFilesToCopy = otherFiles } -- | The relevant directory content for our application data DirContents = DirContents { dcFilesToProcess :: [(FilePath, String)] -- ^ File paths and their content , dcFilesToCopy :: [FilePath] -- ^ Other file paths, to be copied directly } ------------------------------------ -- * Build index page buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html buildIndex files = let previews = map ( \\(file, doc) -&gt; case doc of Markup.Heading 1 heading : article -&gt; Html.h_ 3 (Html.link_ file (Html.txt_ heading)) &lt;&gt; foldMap convertStructure (take 2 article) &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;)) _ -&gt; Html.h_ 3 (Html.link_ file (Html.txt_ file)) ) files in Html.html_ &quot;Blog&quot; ( Html.h_ 1 (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;)) &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;) &lt;&gt; mconcat previews ) ------------------------------------ -- * Conversion -- | Convert text files to Markup, build an index, and render as html. txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)] txtsToRenderedHtml txtFiles = let txtOutputFiles = map toOutputMarkupFile txtFiles index = (&quot;index.html&quot;, buildIndex txtOutputFiles) in map (fmap Html.render) (index : map convertFile txtOutputFiles) toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document) toOutputMarkupFile (file, content) = (takeBaseName file &lt;.&gt; &quot;html&quot;, Markup.parse content) convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html) convertFile (file, doc) = (file, convert file doc) ------------------------------------ -- * Output to directory -- | Creates an output directory or terminates the program createOutputDirectoryOrExit :: FilePath -&gt; IO () createOutputDirectoryOrExit outputDir = whenIO (not &lt;$&gt; createOutputDirectory outputDir) (hPutStrLn stderr &quot;Cancelled.&quot; *&gt; exitFailure) -- | Creates the output directory. -- Returns whether the directory was created or not. createOutputDirectory :: FilePath -&gt; IO Bool createOutputDirectory dir = do dirExists &lt;- doesDirectoryExist dir create &lt;- if dirExists then do override &lt;- confirm &quot;Output directory exists. Override?&quot; when override (removeDirectoryRecursive dir) pure override else pure True when create (createDirectory dir) pure create -- | Copy files to a directory, recording errors to stderr. copyFiles :: FilePath -&gt; [FilePath] -&gt; IO () copyFiles outputDir files = do let copyFromTo file = copyFile file (outputDir &lt;/&gt; takeFileName file) void $ applyIoOnList copyFromTo files &gt;&gt;= filterAndReportFailures -- | Write files to a directory, recording errors to stderr. writeFiles :: FilePath -&gt; [(FilePath, String)] -&gt; IO () writeFiles outputDir files = do let writeFileContent (file, content) = writeFile (outputDir &lt;/&gt; file) content void $ applyIoOnList writeFileContent files &gt;&gt;= filterAndReportFailures ------------------------------------ -- * IO work and handling errors -- | Try to apply an IO function on a list of values, document successes and failures applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)] applyIoOnList action inputs = do for inputs $ \\input -&gt; do maybeResult &lt;- catch (Right &lt;$&gt; action input) ( \\(SomeException e) -&gt; do pure $ Left (displayException e) ) pure (input, maybeResult) -- | Filter out unsuccessful operations on files and report errors to stderr. filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)] filterAndReportFailures = foldMap $ \\(file, contentOrErr) -&gt; case contentOrErr of Left err -&gt; do hPutStrLn stderr err pure [] Right content -&gt; pure [(file, content)] ------------------------------------ -- * Utilities confirm :: String -&gt; IO Bool confirm question = do putStrLn (question &lt;&gt; &quot; (y/n)&quot;) answer &lt;- getLine case answer of &quot;y&quot; -&gt; pure True &quot;n&quot; -&gt; pure False _ -&gt; do putStrLn &quot;Invalid response. Use y or n.&quot; confirm question whenIO :: IO Bool -&gt; IO () -&gt; IO () whenIO cond action = do result &lt;- cond if result then action else pure ()  "},{"title":"Converting Markup to HTML","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/glue/markup-to-html","content":"","keywords":""},{"title":"Qualified Imports​","type":1,"pageTitle":"Converting Markup to HTML","url":"/learn-haskell-blog-generator/glue/markup-to-html#qualified-imports","content":"This time, we've imported the modules qualified. Qualified imports means that instead of exposing the names that we've defined in the imported module to the general module name space, they now have to be prefixed with the module name. For example, parse becomes Markup.parse. If we would've imported Html.Internal qualified, we'd have to writeHtml.Internal.el which is a bit long. We can also give the module a new name with the as keyword: import qualified Html.Internal as HI  And write HI.el instead. I like using qualified imports because readers do not have to guess where a name comes from. Some modules are even designed to be imported qualified. For example, the APIs of many container types such as maps, sets, and vectors, are very similar. If we want to use multiple containers in a single module we pretty much have to use qualified imports so that when we write a function such as singleton, which creates a container with a single value, GHC will know which singletonfunction we are referring to. Some people prefer to use import lists instead of qualified imports, because qualified names can be a bit verbose and noisy. I will often prefer qualified imports to import lists, but feel free to try both solutions and see which fits you better. For more information about imports, see this wiki article. "},{"title":"Converting Markup.Structure to Html.Structure​","type":1,"pageTitle":"Converting Markup to HTML","url":"/learn-haskell-blog-generator/glue/markup-to-html#converting-markupstructure-to-htmlstructure","content":"Converting a markup structure to an HTML structure is mostly straightforward at this point, we need to pattern match on the markup structure and use the relevant HTML API. convertStructure :: Markup.Structure -&gt; Html.Structure convertStructure structure = case structure of Markup.Heading 1 txt -&gt; Html.h1_ txt Markup.Paragraph p -&gt; Html.p_ p Markup.UnorderedList list -&gt; Html.ul_ $ map Html.p_ list Markup.OrderedList list -&gt; Html.ol_ $ map Html.p_ list Markup.CodeBlock list -&gt; Html.code_ (unlines list)  Notice that running this code with -Wall will reveal that the pattern matching is non-exhaustive. This is because we don't currently have a way to build headings that are not h1. There are a few ways to handle this: Ignore the warning - this will likely fail at runtime one day and the user will be sadPattern match other cases and add a nice error with the error function - it has the same disadvantage above, but will also no longer notify of the unhandled cases at compile timePattern match and do the wrong thing - user is still sadEncode errors in the type system using Either, we'll see how to do this in later chaptersRestrict the input - change Markup.Heading to not include a number but rather specific supported headings. This is a reasonable approachImplement an HTML function supporting arbitrary headings. Should be straightforward to do  Exercise: Implement h_ :: Natural -&gt; String -&gt; Structurewhich we'll use to define arbitrary headings (such as &lt;h1&gt;, &lt;h2&gt;, and so on). Solution import Numeric.Natural h_ :: Natural -&gt; String -&gt; Structure h_ n = Structure . el (&quot;h&quot; &lt;&gt; show n) . escape Don't forget to export it from Html.hs! Exercise: Fix convertStructure using h_. Solution convertStructure :: Markup.Structure -&gt; Html.Structure convertStructure structure = case structure of Markup.Heading n txt -&gt; Html.h_ n txt Markup.Paragraph p -&gt; Html.p_ p Markup.UnorderedList list -&gt; Html.ul_ $ map Html.p_ list Markup.OrderedList list -&gt; Html.ol_ $ map Html.p_ list Markup.CodeBlock list -&gt; Html.code_ (unlines list)   "},{"title":"Document -> Html​","type":1,"pageTitle":"Converting Markup to HTML","url":"/learn-haskell-blog-generator/glue/markup-to-html#document---html","content":"In order to create an Html document, we need to use the html_ function. This function expects two things: a Title, and a Structure. For a title we could just supply it from outside using the file name. In order to convert our markup Document (which is a list of markup Structure) to an HTML Structure, we need to convert each markup Structure and then concatenate them together. We already know how to convert each markup Structure, we can use theconvertStructure function we wrote and map. This will provide us with the following function: map convertStructure :: Markup.Document -&gt; [Html.Structure]  To concatenate all of the Html.Structure, we could try to write a recursive function. However we will quickly run into an issue with the base case, what to do when the list is empty? We could just provide dummy Html.Structure that represents an empty HTML structure. Let's add this to Html.Internal: empty_ :: Structure empty_ = Structure &quot;&quot;   Now we can write our recursive function. Try it! Solution concatStructure :: [Structure] -&gt; Structure concatStructure list = case list of [] -&gt; empty_ x : xs -&gt; x &lt;&gt; concatStructure xs   Remember the &lt;&gt; function we implemented as an instance of the Semigrouptype class? We mentioned that Semigroup is an abstraction for things that implements (&lt;&gt;) :: a -&gt; a -&gt; a, where &lt;&gt; is associative (a &lt;&gt; (b &lt;&gt; c) = (a &lt;&gt; b) &lt;&gt; c). It turns out that having an instance of Semigroup and also having a value that represents an &quot;empty&quot; value is a fairly common pattern. For example a string can be concatenated, and the empty string can serve as an &quot;empty&quot; value. And this is actually a well known abstraction called monoid. "},{"title":"Monoids​","type":1,"pageTitle":"Converting Markup to HTML","url":"/learn-haskell-blog-generator/glue/markup-to-html#monoids","content":"Actually, &quot;empty&quot; isn't a very good description of what we want, and isn't very useful as an abstraction. Instead, we can describe it as an &quot;identity&quot; element, which satisfies the following laws: x &lt;&gt; &lt;identity&gt; = x&lt;identity&gt; &lt;&gt; x = x In other words, if we try to use this &quot;empty&quot; - this identity value, as one argument to &lt;&gt;, we will always get the other argument back. For String, the empty string, &quot;&quot;, satisfies this: &quot;&quot; &lt;&gt; &quot;world&quot; = &quot;world&quot; &quot;hello&quot; &lt;&gt; &quot;&quot; = &quot;hello&quot;  This is of course true for any value we'd write and not just &quot;world&quot; and &quot;hello&quot;. Actually, if we move out of the Haskell world for a second, even integers with + as the associative binary operations + (in place of &lt;&gt;) and 0 in place of the identity member form a monoid: 17 + 0 = 17 0 + 99 = 99  So integers together with the + operation form a semigroup, and together with 0 form a monoid. We learn new things from this: A monoid is a more specific abstraction over semigroup, it builds on it by adding a new condition (the existence of an identity member)This abstraction can be useful! We can write a general concatStructurethat could work for any monoid And indeed, there exists a type class in base called Monoid which hasSemigroup as a super class. class Semigroup a =&gt; Monoid a where mempty :: a  Note: this is actually a simplified version. Theactualis a bit more complicated because of backwards compatibility and performance reasons.Semigroup was actually introduced in Haskell after Monoid! We could add an instance of Monoid for our HTML Structure data type: instance Monoid Structure where mempty = empty_  And now, instead of using our own concatStructure, we can use the library function: mconcat :: Monoid a =&gt; [a] -&gt; a  Which could theoretically be implemented as: mconcat :: Monoid a =&gt; [a] -&gt; a mconcat list = case list of [] -&gt; mempty x : xs -&gt; x &lt;&gt; mconcat xs  Notice that because Semigroup is a super class of Monoid, we can still use the &lt;&gt; function from the Semigroup class without adding the Semigroup a constraint to the left side of =&gt;. By adding the Monoid a constraint we implicitly add a Semigroup aconstraint as well! This mconcat function is very similar to the concatStructure function, but this one works for any Monoid, including Structure! Abstractions help us identify common patterns and reuse code! Side note: integers with + and 0 aren't actually an instance of Monoid in Haskell. This is because integers can also form a monoid with * and 1! But there can only be one instance per type. Instead, two other newtypes exist that provide that functionality, Sumand Product. See how they can be used in ghci: ghci&gt; import Data.Monoid ghci&gt; Product 2 &lt;&gt; Product 3 -- note, Product is a data constructor Product {getProduct = 6} ghci&gt; getProduct (Product 2 &lt;&gt; Product 3) 6 ghci&gt; getProduct $ mconcat $ map Product [1..5] 120  "},{"title":"Another abstraction?​","type":1,"pageTitle":"Converting Markup to HTML","url":"/learn-haskell-blog-generator/glue/markup-to-html#another-abstraction","content":"We've used map and then mconcat twice now. Surely there has to be a function that unifies this pattern. And indeed, it is calledfoldMap, and it works not only for lists, but also for any data structure that can be &quot;folded&quot;, or &quot;reduced&quot;, into a summary value. This abstraction and type class is called Foldable. For a simpler understanding of Foldable, we can look at fold: fold :: (Foldable t, Monoid m) =&gt; t m -&gt; m -- compare with mconcat :: Monoid m =&gt; [m] -&gt; m  mconcat is just a specialized version of fold for lists. And fold can be a used for any pair of a data structure that implementsFoldable and a payload type that implements Monoid. This could be [] with Structure, or Maybe with Product Int, or your new shiny binary tree with String as the payload type. But note that the Foldable type must be of kind * -&gt; *. So for example Htmlcannot be a Foldable. foldMap is a function that allows us to apply a function to the payload type of the Foldable type right before combining them with the &lt;&gt; function. foldMap :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m -- compare to a specialized version with: -- - t ~ [] -- - m ~ Html.Structure -- - a ~ Markup.Structure foldMap :: (Markup.Structure -&gt; Html.Structure) -&gt; [Markup.Structure] -&gt; Html.Structure  True to its name, it really &quot;maps&quot; before it &quot;folds&quot;. You might pause here and think &quot;this 'map' we are talking about isn't specific for lists, maybe that's another abstraction?&quot;, yes. It is actually a very important and fundamental abstraction called Functor. But I think we had enough abstractions for this chapter. We'll cover it in a later chapter! "},{"title":"Finishing our conversion module​","type":1,"pageTitle":"Converting Markup to HTML","url":"/learn-haskell-blog-generator/glue/markup-to-html#finishing-our-conversion-module","content":"Let's finish our code by writing convert: convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html convert title = Html.html_ title . foldMap convertStructure  Now we have a full implementation and are able to convert markup documents to HTML: -- Convert.hs module Convert where import qualified Markup import qualified Html convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html convert title = Html.html_ title . foldMap convertStructure convertStructure :: Markup.Structure -&gt; Html.Structure convertStructure structure = case structure of Markup.Heading n txt -&gt; Html.h_ n txt Markup.Paragraph p -&gt; Html.p_ p Markup.UnorderedList list -&gt; Html.ul_ $ map Html.p_ list Markup.OrderedList list -&gt; Html.ol_ $ map Html.p_ list Markup.CodeBlock list -&gt; Html.code_ (unlines list)  "},{"title":"Summary​","type":1,"pageTitle":"Converting Markup to HTML","url":"/learn-haskell-blog-generator/glue/markup-to-html#summary","content":"We learned about: Qualified importsWays to handle errorsThe Monoid type class and abstractionThe Foldable type class and abstraction Next, we are going to glue our functionality together and learn about I/O in Haskell! You can view the git commit ofthe changes we've madeand the code up until now. "},{"title":"Defining a project description","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/glue/project","content":"","keywords":""},{"title":"Creating a project​","type":1,"pageTitle":"Defining a project description","url":"/learn-haskell-blog-generator/glue/project#creating-a-project","content":"Using external packages can be done in multiple ways. For quick experimentation, we can justask stack or cabalto build or even run our program with external packages. But as programs get larger, use more dependencies, and require more functionality, it is better to create a project description for our programs and libraries. Project description is done in a cabal file. We can ask cabal or stack to generate one for us using cabal init --libandexe or stack new, along with many other files, but we will likely need to edit the file by hand later. For now let's just paste an initial example in hs-blog.cabal and edit it. cabal-version: 2.4 name: name should match with &lt;name&gt;.cabal version: version should use PvP synopsis: Synopsis will appear in the hackage package listing and search description: The description will appear at the top of a library homepage: Homepage url bug-reports: issue-tracker url license: License name license-file: License file author: Author name maintainer: Maintainer email category: Hackage categories, separated by commas extra-doc-files: README.md common common-settings default-language: Haskell2010 ghc-options: -Wall library import: common-settings hs-source-dirs: src build-depends: base , directory exposed-modules: HsBlog HsBlog.Convert HsBlog.Html HsBlog.Html.Internal HsBlog.Markup -- other-modules: executable hs-blog-gen import: common-settings hs-source-dirs: app main-is: Main.hs build-depends: base , &lt;package-name&gt; ghc-options: -O  Let's break it down to a few parts, thepackage metadata,common settings,library andexecutable. "},{"title":"Package metadata​","type":1,"pageTitle":"Defining a project description","url":"/learn-haskell-blog-generator/glue/project#package-metadata","content":"The first part should be fairly straightforward from the comments, maybe except for: cabal-version: Defines which cabal versions can build this project. We've specified 2.4 and above.More info on different versions.name: The name of your library and package. Must match with the .cabal filename. Usually starts with a lowercase. Check if your package name is already taken on Hackage.version: Some Haskell packages use semver, most use PvP.license: Most Haskell packages use BSD-3-Clause. Neil Mitchell blogged about this. You can find more licenses if you'd like at choosealicense.com.extra-doc-files: Include extra doc files here, such as README or CHANGELOG. Let's fill this with the metadata of our project: cabal-version: 2.4 name: hs-blog version: 0.1.0.0 synopsis: A custom blog generator from markup files description: This package provides a static blog generator from a custom markup format to HTML. It defines a parser for this custom markup format as well as an html pretty printer EDSL. It is used as the example project in the online book 'Learn Haskell Blog Generator'. See the README for more details. homepage: https://github.com/soupi/learn-haskell-blog-generator bug-reports: https://github.com/soupi/learn-haskell-blog-generator/issues license: BSD-3-Clause license-file: LICENSE.txt author: Gil Mizrahi maintainer: gilmi@posteo.net category: Learning, Web extra-doc-files: README.md  "},{"title":"Common settings​","type":1,"pageTitle":"Defining a project description","url":"/learn-haskell-blog-generator/glue/project#common-settings","content":"Cabal package descriptions can include multiple &quot;targets&quot;: libraries, executables, and test suites. Since Cabal 2.2, we can usecommon stanzasto group settings to be shared between different targets, so we don't have to repeat them for each target. In our case we've created a new common stanza (or block) called common-settings and defined the default language (Haskell has two standards, 98 and 2010), and instructed GHC to compile with -Wall. common common-settings default-language: Haskell2010 ghc-options: -Wall  Later, in our targets' descriptions, we can add import: common-settings , and all of these settings will be automatically added. "},{"title":"Library​","type":1,"pageTitle":"Defining a project description","url":"/learn-haskell-blog-generator/glue/project#library","content":"In a library target, we define: The settings with which to build the library (in this case we just import common-settings)The directory in which the source files can be foundThe packages we require to build the libraryThe modules exposed from the library and can be used by othersThe modules not exposed from the library and which cannot be used by others; these could be any module you don't wish to export, such as an internal utility functions module. In our case we don't have anything like this, so we commented out the other-moduleslabel. Note that it is common to specify version bounds for packages. Version bounds specify which package versions this library works with. These can also be generated using cabal with the cabal gen-bounds command. library import: common-settings hs-source-dirs: src build-depends: base , directory exposed-modules: HsBlog HsBlog.Convert HsBlog.Html HsBlog.Html.Internal HsBlog.Markup -- other-modules:  Also note that we've added an additional hierarchy for our modules and defined a different source directory. This means we will need to move the files around a bit and change the module name in each file and the import statements. This is to avoid conflict with other packages that a user might import.  Do this now. Solution Main.hs -&gt; src/HsBlog.hs module HsBlog ( main , process ) where import qualified HsBlog.Markup as Markup import qualified HsBlog.Html as Html import HsBlog.Convert (convert) Convert.hs -&gt; src/HsBlog/Convert.hs module HsBlog.Convert where import qualified HsBlog.Markup as Markup import qualified HsBlog.Html as Html Html.hs -&gt; src/HsBlog/Html.hs module HsBlog.Html ... import HsBlog.Html.Internal Html/Internal.hs -&gt; src/HsBlog/Html/Internal.hs module HsBlog.Html.Internal where Markup.hs -&gt; src/HsBlog/Markup.hs module HsBlog.Markup   "},{"title":"Executable​","type":1,"pageTitle":"Defining a project description","url":"/learn-haskell-blog-generator/glue/project#executable","content":"We have separated our code into two sections: a library and an executable, why? First, libraries can be used by others. If we publish our code and someone wants to use it and build upon it, they can. Executables can't be imported by other projects. Second, we can write unit tests for libraries. It is usually beneficial to write most, if not all, of our logic as a library, and provide a thin executable over it. Executables' descriptions are very similar to libraries, here we define: The name of the executableWhere the source directory for this application isWhich file is the 'Main' fileImport our library, which is named hs-blogAdditional flags for GHC, e.g., -O to compile with optimizations executable hs-blog-gen import: common-settings hs-source-dirs: app main-is: Main.hs build-depends: base , hs-blog ghc-options: -O  We can write many executables descriptions. In this case we only have one.  Exercise: Add a new file: app/Main.hs which imports HsBlog and runs main. Solution -- app/Main.hs module Main where import qualified HsBlog main :: IO () main = HsBlog.main   "},{"title":"Test-suites​","type":1,"pageTitle":"Defining a project description","url":"/learn-haskell-blog-generator/glue/project#test-suites","content":"test-suite defines a target for running package tests. We will get back to it in a later chapter. "},{"title":"Our complete .cabal file​","type":1,"pageTitle":"Defining a project description","url":"/learn-haskell-blog-generator/glue/project#our-complete-cabal-file","content":"cabal-version: 2.4 name: hs-blog version: 0.1.0.0 synopsis: A custom blog generator from markup files description: This package provides a static blog generator from a custom markup format to HTML. It defines a parser for this custom markup format as well as an html pretty printer EDSL. It is used as the example project in the online book 'Learn Haskell Blog Generator'. See the README for more details. homepage: https://github.com/soupi/learn-haskell-blog-generator bug-reports: https://github.com/soupi/learn-haskell-blog-generator/issues license: BSD-3-Clause license-file: LICENSE.txt author: Gil Mizrahi maintainer: gilmi@posteo.net category: Learning, Web extra-doc-files: README.md common common-settings default-language: Haskell2010 ghc-options: -Wall library import: common-settings hs-source-dirs: src build-depends: base , directory exposed-modules: HsBlog HsBlog.Convert HsBlog.Html HsBlog.Html.Internal HsBlog.Markup -- other-modules: executable hs-blog-gen import: common-settings hs-source-dirs: app main-is: Main.hs build-depends: base , hs-blog ghc-options: -O  We'll also add a README.md file and a LICENSE.txt file: README.md Just write whatever you want here: # hs-blog One day it will be a static blog generator. [Read the book](https://lhbg-book.link).  LICENSE.txt This is BSD-3-Clause with me as the author. Please write your own name for your projects :) BSD 3-Clause License Copyright (c) 2021-2022, Gil Mizrahi All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  "},{"title":"cabal.project and stack.yaml​","type":1,"pageTitle":"Defining a project description","url":"/learn-haskell-blog-generator/glue/project#cabalproject-and-stackyaml","content":"The cabal.project andstack.yamlfiles are used by cabal and stack respectively to add additional information on how to build the package. While cabal.project isn't necessary to use cabal, stack.yamlis necessary in order to use stack, so we will cover it briefly. There are two important fields a stack.yaml file must have: resolver: Describes which snapshot to use for packages and ghc version. We will choose the latest (at time of writing) on the lts branch: lts-18.22. Visit this link to find out which packages this snapshot includes, what their versions are, and which GHC version is used with this snapshotpackages: Describes the location of packages we plan to build. In our case we have only one and it can be found in the current directory We'll add stack.yaml to our project directory: resolver: lts-18.22 packages: - .  For additional options and configurations, please consult the relevant user guides. "},{"title":"Usage​","type":1,"pageTitle":"Defining a project description","url":"/learn-haskell-blog-generator/glue/project#usage","content":"Now, instead of manually running runghc Main.hs, we will use either stackor cabal to build and run our program and package (I mostly use stack, but it's up to you). "},{"title":"For cabal:​","type":1,"pageTitle":"Defining a project description","url":"/learn-haskell-blog-generator/glue/project#for-cabal","content":"Building the project - on the first run, cabal will download the package dependencies and use the GHC on PATH to build the project. Cabal caches packages between projects, so if a new project uses the same packages with the same versions (and the same flag settings) they will not need to be reinstalled. In older versions of cabal, packages could be installed either globally, or in sandboxes. In each sandbox (and globally) there could only be one version of a package installed, and users would usually create different sandboxes for different projects, without caching packages between projects. With the new build system implementation, multiple versions of the same package can be installed globally, and for each project cabal will (try to) choose a specific version for each package dependency such that they all work together, without needing sandboxing. This change helps us increase sharing of built packages while avoiding conflicts and manual handling of sandboxes. Note: The new build system implementation is now the default and Cabal commands do not need to be prefixed with v2-, but the Cabal documentation will still mention the prefix to refer to the new commands. A few important commands we should be familiar with: cabal update  updatefetches information from remote package repositories (specifically Hackage unless specified otherwise) and updates the local package index which includes various information about available packages such as their names, versions and dependencies. cabal update is usually the first command to run before fetching package dependencies. cabal build  buildcompiles the various targets (such as library and executables). It will also fetch and install the package dependencies when they're not already installed. When building executables, cabal build will report where the executable has been created, and it is also possible to find the path to the executable using cabal exec -- which hs-blog-gen. cabal run hs-blog-gen -- &lt;program arguments&gt;  runCan be used to compile and then run a target (in our case our executable which we named hs-blog-gen). We separate arguments passed to cabal and arguments passed to our target program with --. cabal repl hs-blog  replruns ghci in the context of the target (in our case our library which we named hs-blog) - it will load the target's package dependencies and modules to be available in ghci. cabal clean  cleanDeletes the build artifacts that we built. There are more interesting commands we could use, such as cabal freeze to generate a file which records the packages versions and flags we used to build this project, and cabal sdist to bundle the project source to a package tarball which can be uploaded to Hackage. If you'd like to learn more visit theCabal user guide. "},{"title":"For stack:​","type":1,"pageTitle":"Defining a project description","url":"/learn-haskell-blog-generator/glue/project#for-stack","content":"Building the project - on the first run, stack will install the right GHC for this project which is specified by the resolver field in the stack.yaml file, download the package dependencies, and compile the project. Stack caches these installations between projects that use the same resolver, so future projects with the same resolver and future runs of this project won't require reinstallation. This approach is kind of a middle ground between full packages sharing and sandboxes. Let's look at the (somewhat) equivalent commands for Stack: stack build  buildwill compile the project as described above - installing GHC and package dependencies if they are not installed. When building executables, stack build will report where the executable has been created, and it is also possible to find the path to the executable using stack exec -- which hs-blog-gen. stack exec hs-blog-gen -- &lt;program arguments&gt;  execwill run the executable passing the program arguments to our executable. stack ghci hs-blog  ghciruns ghci in the context of our library hs-blog - loading the library modules and packages. stack clean  cleancleans up build artifacts. The Stack user guide contains more information about how stack works and how to use it effectively. "},{"title":"Build artifacts​","type":1,"pageTitle":"Defining a project description","url":"/learn-haskell-blog-generator/glue/project#build-artifacts","content":"Both stack and cabal create build artifacts that we will not want to track using our version control. These build artifacts are found in the dist, dist-newstyleand .stack-work directories. We can add these to a .gitignore file (or similar for other version control programs) to ignore them: dist dist-newstyle .stack-work  "},{"title":"Finding packages​","type":1,"pageTitle":"Defining a project description","url":"/learn-haskell-blog-generator/glue/project#finding-packages","content":"Finding packages isn't a very straightforward process at the moment. People have written onhow they choose packages,recommendation lists, books, and more. My suggestion is: Search for a tutorial on something you'd like to do, and see which packages come upUse the download amount on Hackage as an indication of package popularityUse Stackage package synopses to locate a relevant packageCheck social network channels for recommendations, but know that sometimes people tend to recommend inappropriate solutions and packages that might be too complicated or still experimental It's also important to note the amount of dependencies a package has. Adding many dependencies will affect compilation time and code size. And it can sometimes be a good thing to consider when comparing packages, or considering whether a package is needed at all. "},{"title":"Summary​","type":1,"pageTitle":"Defining a project description","url":"/learn-haskell-blog-generator/glue/project#summary","content":"We've created a package description for our library and used stack and/or cabalto build our program. In future chapters we'll start adding external packages, we'll only have to add them to the build-depends section in the cabal file and our package manager will download and install the required package for us! We've made some change to our project directory, and it should now look like this: . ├── app │ └── Main.hs ├── hs-blog.cabal ├── LICENSE.txt ├── README.md ├── src │ ├── HsBlog │ │ ├── Convert.hs │ │ ├── Html │ │ │ └── Internal.hs │ │ ├── Html.hs │ │ └── Markup.hs │ └── HsBlog.hs └── stack.yaml 4 directories, 10 files  Note that this package format could be released on Hackagefor other Haskell developers to use! You can view the git commit ofthe changes we've madeand the code up until now. "},{"title":"Fancy options parsing","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/glue/optparse","content":"","keywords":""},{"title":"Building a command-line parser​","type":1,"pageTitle":"Fancy options parsing","url":"/learn-haskell-blog-generator/glue/optparse#building-a-command-line-parser","content":"The optparse-applicative package has pretty decentdocumentation, but we will cover a few important things to pay attention to in this chapter. In general, there are four important things we need to do: Define our model - we want to define an ADT that describes the various options and commands for our program Define a parser that will produce a value of our model type when run Run the parser on our program arguments input Pattern match on the model and call the right operations according to the options "},{"title":"Define a model​","type":1,"pageTitle":"Fancy options parsing","url":"/learn-haskell-blog-generator/glue/optparse#define-a-model","content":"Let's envision our command-line interface for a second, what should it look like? We want to be able to convert a single file or input stream to either a file or an output stream, or we want to process a whole directory and create a new directory. We can model it in an ADT like this: data Options = ConvertSingle SingleInput SingleOutput | ConvertDir FilePath FilePath deriving Show data SingleInput = Stdin | InputFile FilePath deriving Show data SingleOutput = Stdout | OutputFile FilePath deriving Show  Note that we could technically also use Maybe FilePath to encode both SingleInputand SingleOutput, but then we would have to remember what Nothing means in each context. By creating a new type with properly named constructors for each option we make it easier for readers of the code to understand the meaning of our code. In terms of interface, we could decide that when a user would like to convert a single input source, they would use the convert command, and supply the optional flags--input FILEPATH and --output FILEPATH to read or write from a file. When the user does not supply one or both flags, we will read or write from the standard input/output accordingly. If the user would like to convert a directory, they can use the convert-dircommand and supply the two mandatory flags --input FILEPATH and--output FILEPATH. "},{"title":"Build a parser​","type":1,"pageTitle":"Fancy options parsing","url":"/learn-haskell-blog-generator/glue/optparse#build-a-parser","content":"This is the most interesting part of the process. How do we build a parser that fits our model? The optparse-applicative library introduces a new type called Parser.Parser, similar to Maybe and IO, has the kind * -&gt; * - when it is supplied with a saturated (or concrete) type such as Int, Bool orOptions, it can become a saturated type (one that has values). A Parser a represents a specification of a command-line options parser that produces a value of type a when the command-line arguments are successfully parsed. This is similar to how IO a represents a description of a program that can produce a value of type a. The main difference between these two types is that while we can't convert an IO a to an a(we just chain IO operations and have the Haskell runtime execute them), we can convert a Parser a to a function that takes a list of strings representing the program arguments and produces an a if it manages to parse the arguments. As we've seen with the previous EDSLs, this library uses the combinator patternas well. We need to consider the basic primitives for building a parser, and the methods of composing small parsers into bigger parsers. Let's see an example for a small parser: inp :: Parser FilePath inp = strOption ( long &quot;input&quot; &lt;&gt; short 'i' &lt;&gt; metavar &quot;FILE&quot; &lt;&gt; help &quot;Input file&quot; ) out :: Parser FilePath out = strOption ( long &quot;output&quot; &lt;&gt; short 'o' &lt;&gt; metavar &quot;FILE&quot; &lt;&gt; help &quot;Output file&quot; )  strOption is a parser builder. It is a function that takes a combinedoption modifiers as an argument, and returns a parser that will parse a string. We can specify the type to be FilePath because FilePath is an alias to String. The parser builder describes how to parse the value, and the modifiers describe its properties, such as the flag name, the shorthand of the flag name, and how it would be described in the usage and help messages. Actually strOption can return any string type that implements the interface IsString. There are a few such types, for example Text, a much more efficient Unicode text type from the text package. It is more efficient than String because while String is implemented as a linked list of Char, Text is implemented as an array of bytes.Text is usually what we should use for text values instead of String. We haven't been using it up until now because it is slightly less ergonomic to use than String. But it is often the preferred type to use for text! As you can see, modifiers can be composed using the &lt;&gt; function, which means modifiers implement an instance of the Semigroup type class! With such an interface we don't have to supply all the modifier options, but only the relevant ones. So if we don't want to have a shortened flag name, we don't have to add it. Functor​ For the data type we've defined, having Parser FilePath takes us a good step in the right direction, but it is not exactly what we need for a ConvertSingle. We need a Parser SingleInput and aParser SingleOutput. If we had a FilePath, we could convert it into SingleInput by using the InputFile constructor. Remember, InputFile is also a function: InputFile :: FilePath -&gt; SingleInput OutputFile :: FilePath -&gt; SingleOutput  However, to convert a parser, we need functions with these types: f :: Parser FilePath -&gt; Parser SingleInput g :: Parser FilePath -&gt; Parser SingleOutput  Fortunately, the Parser interface provides us with a function to &quot;lift&quot; a function like FilePath -&gt; SingleInput to work on parsers, making it a function with the type Parser FilePath -&gt; Parser SingleInput. Of course, this function will work for any input and output, so if we have a function with the type a -&gt; b, we can pass it to that function and get a new function of the type Parser a -&gt; Parser b. This function is called fmap: fmap :: (a -&gt; b) -&gt; Parser a -&gt; Parser b -- Or with its infix version (&lt;$&gt;) :: (a -&gt; b) -&gt; Parser a -&gt; Parser b  We've seen fmap before in the interface of other types: fmap :: (a -&gt; b) -&gt; [a] -&gt; [b] fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b  fmap is a type class function like &lt;&gt; and show. It belongs to the type class Functor: class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b  And it has the following laws: -- 1. Identity law: -- if we don't change the values, nothing should change fmap id = id -- 2. Composition law: -- Composing the lifted functions is the same a composing -- them after fmap fmap (f . g) == fmap f . fmap g  Any type f that can implement fmap and follow these laws can be a valid instance of Functor. Notice how f has a kind * -&gt; *, we can infer the kind of fby looking at the other types in the type signature of fmap: a and b have the kind * because they are used as arguments/return types of functionsf a has the kind * because it is used as an argument to a function, thereforef has the kind * -&gt; * Let's choose a data type and see if we can implement a Functor instance. We need to choose a data type that has the kind * -&gt; *. Maybe fits the bill. We need to implement a function fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b. Here's one very simple (and wrong) implementation: mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b mapMaybe func maybeX = Nothing  Check it yourself! It compiles successfully! But unfortunately it does not satisfy the first law. fmap id = id means thatmapMaybe id (Just x) == Just x, however from the definition we can clearly see that mapMaybe id (Just x) == Nothing. This is a good example of how Haskell doesn't help us make sure the laws are satisfied, and why they are important. Unlawful Functor instances will behave differently from what we'd expect a Functor to behave. Let's try again! mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b mapMaybe func maybeX = case maybeX of Nothing -&gt; Nothing Just x -&gt; Just (func x)  This mapMaybe will satisfy the functor laws. This can be proved by doing algebra - if we can do substitution and reach the other side of the equation in each law, then the law holds. Functor is a very important type class, and many types implement this interface. As we know, IO, Maybe, [] and Parser all have the kind * -&gt; *, and all allows us to map over their &quot;payload&quot; type. Often people try to look for analogies and metaphors to what a type class mean, but type classes with funny names like Functor don't usually have an analogy or a metaphor that fits them in all cases. It is easier to give up on the metaphor and think about it as it is - an interface with laws. We can use fmap on Parser to make a parser that returns FilePath to return a SingleInput or SingleOutput instead: pInputFile :: Parser SingleInput pInputFile = fmap InputFile parser where parser = strOption ( long &quot;input&quot; &lt;&gt; short 'i' &lt;&gt; metavar &quot;FILE&quot; &lt;&gt; help &quot;Input file&quot; ) pOutputFile :: Parser SingleOutput pOutputFile = OutputFile &lt;$&gt; parser -- fmap and &lt;$&gt; are the same where parser = strOption ( long &quot;output&quot; &lt;&gt; short 'o' &lt;&gt; metavar &quot;FILE&quot; &lt;&gt; help &quot;Output file&quot; )  Applicative​ Now that we have two parsers,pInputFile :: Parser SingleInputand pOutputFile :: Parser SingleOutput, we want to combine them as Options. Again, if we only hadSingleInput and SingleOutput, we could use the constructor ConvertSingle: ConvertSingle :: SingleInput -&gt; SingleOutput -&gt; Options  Can we do a similar trick to the one we saw before with fmap? Does a function exist that can lift a binary function to work on Parsers instead? One with this type signature: ??? :: (SingleInput -&gt; SingleOutput -&gt; Options) -&gt; (Parser SingleInput -&gt; Parser SingleOutput -&gt; Parser Options)  Yes. This function is called liftA2 and it is from the Applicativetype class. Applicative (also known as applicative functor) has three primary functions: class Functor f =&gt; Applicative f where pure :: a -&gt; f a liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b  Applicativeis another very popular type class with many instances. Just like any Monoid is a Semigroup, any Applicativeis a Functor. This means that any type that wants to implement the Applicative interface should also implement the Functor interface. Beyond what a regular functor can do, which is to lift a function over a certain f, applicative functors allow us to apply a function tomultiple instances of a certain f, as well as &quot;lift&quot; any value of type a into an f a. You should already be familiar with pure, we've seen it when we talked about IO. For IO, pure lets us create an IO action with a specific return value without doing IO. With pure for Parser, we can create a Parser that when run will return a specific value as output without doing any parsing. liftA2 and &lt;*&gt; are two functions that can be implemented in terms of one another. &lt;*&gt; is actually the more useful one between the two. Because when combined with fmap (or rather the infix version &lt;$&gt;), it can be used to apply a function with many arguments, instead of just two. To combine our two parsers to one, we can use either liftA2 or a combination of &lt;$&gt; and &lt;*&gt;: -- with liftA2 pConvertSingle :: Parser Options pConvertSingle = liftA2 ConvertSingle pInputFile pOutputFile -- with &lt;$&gt; and &lt;*&gt; pConvertSingle :: Parser Options pConvertSingle = ConvertSingle &lt;$&gt; pInputFile &lt;*&gt; pOutputFile  Note that both &lt;$&gt; and &lt;*&gt; associate to the left, so we have invisible parenthesis that look like this: pConvertSingle :: Parser Options pConvertSingle = (ConvertSingle &lt;$&gt; pInputFile) &lt;*&gt; pOutputFile  Let's take a deeper look at the types of the sub-expressions we have here, to prove that this type-checks: pConvertSingle :: Parser Options pInputFile :: Parser SingleInput pOutputFile :: Parser SingleOutput ConvertSingle :: SingleInput -&gt; SingleOutput -&gt; Options (&lt;$&gt;) :: (a -&gt; b) -&gt; Parser a -&gt; Parser b -- Specifically, here `a` is `SingleInput` -- and `b` is `SingleOutput -&gt; Options`, ConvertSingle &lt;$&gt; pInputFile :: Parser (SingleOutput -&gt; Options) (&lt;*&gt;) :: Parser (a -&gt; b) -&gt; Parser a -&gt; Parser b -- Specifically, here `a -&gt; b` is `SingleOutput -&gt; Options` -- so `a` is `SingleOutput` and `b` is `Options` -- So we get: (ConvertSingle &lt;$&gt; pInputFile) &lt;*&gt; pOutputFile :: Parser Options  With &lt;$&gt; and &lt;*&gt; we can chain as many parsers (or any applicative really) as we want. This is because of two things: currying and parametric polymorphism. Because functions in Haskell take exactly one argument and return exactly one, any multiple argument function can be represented as a -&gt; b. You can find the laws for the applicative functors in this article calledTypeclassopedia, which talks about various useful type classes and their laws. Applicative functor is a very important concept and will appear in various parser interfaces (not just for command-line arguments, but also JSON parsers and general parsers), I/O, concurrency, non-determinism, and more. The reason this library is called optparse-applicative is because it uses the Applicative interface as the main API for constructing parsers.  Exercise: create a similar interface for the ConvertDir constructor of Options. Solution pInputDir :: Parser FilePath pInputDir = strOption ( long &quot;input&quot; &lt;&gt; short 'i' &lt;&gt; metavar &quot;DIRECTORY&quot; &lt;&gt; help &quot;Input directory&quot; ) pOutputDir :: Parser FilePath pOutputDir = strOption ( long &quot;output&quot; &lt;&gt; short 'o' &lt;&gt; metavar &quot;DIRECTORY&quot; &lt;&gt; help &quot;Output directory&quot; ) pConvertDir :: Parser Options pConvertDir = ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir   Alternative​ One thing we forgot about is that each input and output forConvertSingle could also potentially use the standard input and output instead. Up until now we only offered one option: reading from or writing to a file by specifying the flags --input and --output. However, we'd like to make these flags optional, and when they are not specified, use the alternative standard i/o. We can do that by using the function optional from Control.Applicative: optional :: Alternative f =&gt; f a -&gt; f (Maybe a)  optional works on types which implement instances of theAlternative type class: class Applicative f =&gt; Alternative f where (&lt;|&gt;) :: f a -&gt; f a -&gt; f a empty :: f a  Alternative looks very similar to the Monoid type class, but it works on applicative functors. This type class isn't very common and is mostly used for parsing libraries as far as I know. It provides us with an interface to combine two Parsers - if the first one fails to parse, try the other. It also provides other useful functions such as optional, which will help us with our case: pSingleInput :: Parser SingleInput pSingleInput = fromMaybe Stdin &lt;$&gt; optional pInputFile pSingleOutput :: Parser SingleOutput pSingleOutput = fromMaybe Stdout &lt;$&gt; optional pOutputFile  Note that with fromMaybe :: a -&gt; Maybe a -&gt; a we can extract the a out of the Maybe by supplying a value for the Nothing case. Now we can use these more appropriate functions in pConvertSingle instead: pConvertSingle :: Parser Options pConvertSingle = ConvertSingle &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput  Commands and subparsers​ We currently have two possible operations in our interface, convert a single source, or convert a directory. A nice interface for selecting the right operation would be via commands. If the user would like to convert a single source, they can useconvert, for a directory, convert-dir. We can create a parser with commands with the subparser and commandfunctions: subparser :: Mod CommandFields a -&gt; Parser a command :: String -&gt; ParserInfo a -&gt; Mod CommandFields a  subparser takes command modifiers (which can be constructed with the command function) as input, and produces a Parser.command takes the command name (in our case &quot;convert&quot; or &quot;convert-dir&quot;) and a ParserInfo a, and produces a command modifier. As we've seen before these modifiers have a Monoid instance and they can be composed, meaning that we can append multiple commands to serve as alternatives. A ParserInfo a can be constructed with the info function: info :: Parser a -&gt; InfoMod a -&gt; ParserInfo a  This function wraps a Parser with some additional information such as a helper message, description, and more, so that the program itself and each sub command can print some additional information. Let's see how to construct a ParserInfo: pConvertSingleInfo :: ParserInfo Options pConvertSingleInfo = info (helper &lt;*&gt; pConvertSingle) (progDesc &quot;Convert a single markup source to html&quot;)  Note that helper adds a helper output screen in case the parser fails. Let's also build a command: pConvertSingleCommand :: Mod CommandFields Options pConvertSingleCommand = command &quot;convert&quot; pConvertSingleInfo  Try creating a Parser Options combining the two options with subparser. Solution pOptions :: Parser Options pOptions = subparser ( command &quot;convert&quot; ( info (helper &lt;*&gt; pConvertSingle) (progDesc &quot;Convert a single markup source to html&quot;) ) &lt;&gt; command &quot;convert-dir&quot; ( info (helper &lt;*&gt; pConvertDir) (progDesc &quot;Convert a directory of markup files to html&quot;) ) )  ParserInfo​ Since we finished building a parser, we should wrap it up in a ParserInfoand add some information to it to make it ready to run: opts :: ParserInfo Options opts = info (helper &lt;*&gt; pOptions) ( fullDesc &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot; &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot; )  "},{"title":"Running a parser​","type":1,"pageTitle":"Fancy options parsing","url":"/learn-haskell-blog-generator/glue/optparse#running-a-parser","content":"optparse-applicative provides a non-IO interface to parse arguments, but the most convenient way to use it is to let it take care of fetching program arguments, try to parse them, and throw errors and help messages in case it fails. This can be done with the function execParser :: ParserInfo a -&gt; IO a. We can place all this options parsing stuff in a new module and then import it from app/Main.hs. Let's do that. Here's what we have up until now: app/OptParse.hs -- | Command-line options parsing module OptParse ( Options(..) , SingleInput(..) , SingleOutput(..) , parse ) where import Data.Maybe (fromMaybe) import Options.Applicative ------------------------------------------------ -- * Our command-line options model -- | Model data Options = ConvertSingle SingleInput SingleOutput | ConvertDir FilePath FilePath deriving Show -- | A single input source data SingleInput = Stdin | InputFile FilePath deriving Show -- | A single output sink data SingleOutput = Stdout | OutputFile FilePath deriving Show ------------------------------------------------ -- * Parser -- | Parse command-line options parse :: IO Options parse = execParser opts opts :: ParserInfo Options opts = info (pOptions &lt;**&gt; helper) ( fullDesc &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot; &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot; ) -- | Parser for all options pOptions :: Parser Options pOptions = subparser ( command &quot;convert&quot; ( info (helper &lt;*&gt; pConvertSingle) (progDesc &quot;Convert a single markup source to html&quot;) ) &lt;&gt; command &quot;convert-dir&quot; ( info (helper &lt;*&gt; pConvertDir) (progDesc &quot;Convert a directory of markup files to html&quot;) ) ) ------------------------------------------------ -- * Single source to sink conversion parser -- | Parser for single source to sink option pConvertSingle :: Parser Options pConvertSingle = ConvertSingle &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput -- | Parser for single input source pSingleInput :: Parser SingleInput pSingleInput = fromMaybe Stdin &lt;$&gt; optional pInputFile -- | Parser for single output sink pSingleOutput :: Parser SingleOutput pSingleOutput = fromMaybe Stdout &lt;$&gt; optional pOutputFile -- | Input file parser pInputFile :: Parser SingleInput pInputFile = fmap InputFile parser where parser = strOption ( long &quot;input&quot; &lt;&gt; short 'i' &lt;&gt; metavar &quot;FILE&quot; &lt;&gt; help &quot;Input file&quot; ) -- | Output file parser pOutputFile :: Parser SingleOutput pOutputFile = OutputFile &lt;$&gt; parser where parser = strOption ( long &quot;output&quot; &lt;&gt; short 'o' &lt;&gt; metavar &quot;FILE&quot; &lt;&gt; help &quot;Output file&quot; ) ------------------------------------------------ -- * Directory conversion parser pConvertDir :: Parser Options pConvertDir = ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir -- | Parser for input directory pInputDir :: Parser FilePath pInputDir = strOption ( long &quot;input&quot; &lt;&gt; short 'i' &lt;&gt; metavar &quot;DIRECTORY&quot; &lt;&gt; help &quot;Input directory&quot; ) -- | Parser for output directory pOutputDir :: Parser FilePath pOutputDir = strOption ( long &quot;output&quot; &lt;&gt; short 'o' &lt;&gt; metavar &quot;DIRECTORY&quot; &lt;&gt; help &quot;Output directory&quot; )  "},{"title":"Pattern matching on Options​","type":1,"pageTitle":"Fancy options parsing","url":"/learn-haskell-blog-generator/glue/optparse#pattern-matching-on-options","content":"After running the command-line arguments parser, we can pattern match on our model and call the right functions. Currently, our program does not expose this kind of API. So let's go to our src/HsBlog.hsmodule and change the API. We can delete main from that file and add two new functions instead: convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO () convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()  Handleis an I/O abstraction over file system objects, including stdin and stdout. Before, we used writeFile and getContents - these functions either get a FilePath to open and work on, or they assume the Handle is the standard I/O. We can use the explicit versions that take a Handle from System.IO instead: convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO () convertSingle title input output = do content &lt;- hGetContents input hPutStrLn output (process title content)  We will leave convertDirectory unimplemented for now and implement it in the next chapter. In app/Main.hs, we will need to pattern match on the Options and prepare to call the right functions from HsBlog. Let's look at our full app/Main.hs and src/HsBlog.hs: app/Main.hs -- | Entry point for the hs-blog-gen program module Main where import OptParse import qualified HsBlog import System.Exit (exitFailure) import System.Directory (doesFileExist) import System.IO main :: IO () main = do options &lt;- parse case options of ConvertDir input output -&gt; HsBlog.convertDirectory input output ConvertSingle input output -&gt; do (title, inputHandle) &lt;- case input of Stdin -&gt; pure (&quot;&quot;, stdin) InputFile file -&gt; (,) file &lt;$&gt; openFile file ReadMode outputHandle &lt;- case output of Stdout -&gt; pure stdout OutputFile file -&gt; do exists &lt;- doesFileExist file shouldOpenFile &lt;- if exists then confirm else pure True if shouldOpenFile then openFile file WriteMode else exitFailure HsBlog.convertSingle title inputHandle outputHandle hClose inputHandle hClose outputHandle ------------------------------------------------ -- * Utilities -- | Confirm user action confirm :: IO Bool confirm = putStrLn &quot;Are you sure? (y/n)&quot; *&gt; getLine &gt;&gt;= \\answer -&gt; case answer of &quot;y&quot; -&gt; pure True &quot;n&quot; -&gt; pure False _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt; confirm  src/HsBlog.hs -- HsBlog.hs module HsBlog ( convertSingle , convertDirectory , process ) where import qualified HsBlog.Markup as Markup import qualified HsBlog.Html as Html import HsBlog.Convert (convert) import System.IO convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO () convertSingle title input output = do content &lt;- hGetContents input hPutStrLn output (process title content) convertDirectory :: FilePath -&gt; FilePath -&gt; IO () convertDirectory = error &quot;Not implemented&quot; process :: Html.Title -&gt; String -&gt; String process title = Html.render . convert title . Markup.parse  We need to make a few small changes to the .cabal file. First, we need to add the dependency directory to the executable, because we use the library System.Directory in Main. Second, we need to list OptParse in the list of modules in the executable.  executable hs-blog-gen import: common-settings hs-source-dirs: app main-is: Main.hs + other-modules: + OptParse build-depends: base + , directory , optparse-applicative , hs-blog ghc-options: -O  "},{"title":"Summary​","type":1,"pageTitle":"Fancy options parsing","url":"/learn-haskell-blog-generator/glue/optparse#summary","content":"We've learned about a new fancy library called optparse-applicativeand used it to create a fancier command-line interface in a declarative way. See the result of running hs-blog-gen --help (or the equivalentcabal/stack commands we discussed in the last chapter): hs-blog-gen - a static blog generator Usage: hs-blog-gen COMMAND Convert markup files or directories to html Available options: -h,--help Show this help text Available commands: convert Convert a single markup source to html convert-dir Convert a directory of markup files to html  Along the way we've learned two powerful new abstractions, Functorand Applicative, as well as revisited an abstraction called Monoid. With this library we've seen another example of the usefulness of these abstractions for constructing APIs and EDSLs. We will continue to meet these abstractions in the rest of the book.  Bonus exercise: Add another flag named --replace to indicate that if the output file or directory already exists, it's okay to replace them.  You can view the git commit ofthe changes we've madeand the code up until now. "},{"title":"Hello, world!","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/hello","content":"","keywords":""},{"title":"하스켈 소스 파일​","type":1,"pageTitle":"Hello, world!","url":"/learn-haskell-blog-generator/hello#하스켈-소스-파일","content":"하스켈 소스 파일은 여러 정의들로 구성됩니다. 가장 일반적인 형태의 정의는 다음과 같습니다: &lt;이름&gt; = &lt;표현식&gt;  다음과 같은 제약사항이 있습니다: 이름은 소문자로 시작해야 합니다파일 내에서 이름은 한 번만 사용할 수 있습니다 어떤 파일이 main이라는 정의를 가지고 있다면, 해당 파일은 실행 가능한 파일로 간주됩니다. 또한 main의 표현식은 프로그램의 시작점이 됩니다. 첫 번째 하스켈 소스코드 파일을 작성해 보겠습니다. hello.hs라는 이름의 새로운 파일을 만들고 다음과 같이 작성하세요: main = putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;  위 코드에서 main이라는 이름을 정의하고 putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;라는 표현식을 바인딩했습니다. main의 정의는 &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot; 값을 입력으로 putStrLn 함수를 호출한다는 의미입니다.putStrLn 함수는 하나의 문자열을 입력으로 받고 표준 출력으로 해당 문자열을 출력합니다. 주의 하스켈에서 함수에 인자를 전달할 때 괄호를 사용하지 않아도 됩니다. 이 프로그램을 실행하면 다음과 같은 텍스트가 화면에 출력됩니다: &lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;  주의할 점은 main = 부분을 생략하고 단순히 putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;만 작성할 수는 없습니다. 왜나하면 이는 정의가 아니기 때문입니다. 파이썬이나 OCaml과 같은 언어에서는 허용되지만 하스켈이나 C와 같은 언어에서는 허용되지 않습니다. "},{"title":"프로그램 컴파일하기​","type":1,"pageTitle":"Hello, world!","url":"/learn-haskell-blog-generator/hello#프로그램-컴파일하기","content":"프로그램을 실행하기 위해, ghc라는 커맨드라인 프로그램을 사용하여 hello.hs라는 파일을 컴파일할 수 있습니다: &gt; ghc hello.hs [1 of 1] Compiling Main ( hello.hs, hello.o ) Linking hello ...  hello.hs 파일을 ghc에 전달하면 다음과 같은 파일들이 생성됩니다: hello.o - 오브젝트 파일hello.hi - 하스켈 인터페이스 파일hello - 네이티브 실행 파일 컴파일 이후에, hello라는 파일을 실행할 수 있습니다: &gt; ./hello &lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;  "},{"title":"인터프리터로 실행하기​","type":1,"pageTitle":"Hello, world!","url":"/learn-haskell-blog-generator/hello#인터프리터로-실행하기","content":"다른 방법으로, 컴파일과 아티팩트 파일 생성 단계를 생략하고 runghc라는 커맨드라인 프로그램을 사용하여 소스 파일을 직접 실행할 수 있습니다: &gt; runghc hello.hs &lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;  프로그램 실행 결과를 파일로 저장하고 Firefox 브라우저를 사용하여 해당 파일을 열 수도 있습니다. &gt; runghc hello.hs &gt; hello.html &gt; firefox hello.html  위 명령어는 Firefox를 실행하고 Hello, world!라는 텍스트가 있는 웹 페이지를 표시합니다. 이번 튜토리얼에서는 runghc를 사용하는 것을 추천합니다. 컴파일 하는것이 더 빠른 프로그램을 생성하지만, 프로그램을 개발하고 자주 변경하는 동안에는 인터프리터를 사용하는 것이 피드백을 더 빠르게 받을 수 있기 때문입니다. 하스켈 툴체인에 대해 더 자세히 알고 싶다면 이 글을 참고하세요. 하지만 지금 당장은 위 내용만 알아도 충분합니다. "},{"title":"더 많은 바인딩​","type":1,"pageTitle":"Hello, world!","url":"/learn-haskell-blog-generator/hello#더-많은-바인딩","content":"putStrLn 함수에 직접 문자열을 전달하는 대신, HTML 문자열을 정의하는 새로운 이름을 만들어서 전달할 수도 있습니다. 이전에 만든 hello.hs 파일을 다음과 같이 수정하세요: main = putStrLn myhtml myhtml = &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;  참고: 바인딩의 정의 순서는 중요하지 않습니다. "},{"title":"HTML 출력 라이브러리 만들기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html","content":"HTML 출력 라이브러리 만들기 이번 장에서는 함수, 타입, 모듈과 같은 기본적인 하스켈 빌딩 블록을 살펴보고, 이를 사용하여 마크업 블로그 포스트를 HTML 페이지로 변환하는 라이브러리를 만들어 보겠습니다. 아직 HTML에 대한 지식이 없다면 MDN의 HTML 튜토리얼을 먼저 읽어 보는 것을 추천합니다.","keywords":""},{"title":"내장 도메인 특화 언어","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/edsls","content":"내장 도메인 특화 언어 이번 장에서는 하스켈에서 자주 볼 수 있는 패턴 중 하나인 &quot;내장 도메인 특화 언어(Embedded Domain Specific Languages, 줄여서 EDSLs)&quot;를 만들어 보겠습니다. 도메인 특화 언어(Domain Specific Languages)는 특정 도메인에 맞춰 특화된 프로그래밍 언어입니다. 반대로, 일반적인 프로그래밍 언어는 여러 도메인에서 잘 동작하도록 만들어져 있습니다. DLS의 예로는 다음과 같은 것들이 있습니다: make - 빌드 시스템을 정의하는 데 사용됩니다.DOT - 그래프를 정의하는 데 사용됩니다.Sed - 텍스트 변환을 정의하는 데 사용됩니다.CSS - 스타일링을 정의하는 데 사용됩니다.HTML - 웹 페이지를 정의하는 데 사용됩니다. 내장 도메인 특화 언어(EDSL)는 다른 프로그래밍 언어에 내장된 작은 언어입니다. EDSL로 작성된 프로그램은 해당 프로그래밍 언어에서 유효한 프로그램입니다. 예를 들어, 우리가 지금까지 작성한 HTML 라이브러리도 EDSL이라고 할 수 있습니다. 이 라이브러리는 (HTML 문자열을 반환하여) 웹 페이지를 만드는 데 사용되며, 유효한 하스켈 코드입니다! 하스켈에서는 도메인에 특화된 로직을 표현하기 위해 EDSL을 자주 만들고 사용합니다. 예를들면 동시성, 커맨드 라인 옵션 파싱, JSON, HTML, 빌드 시스템 작성, 테스트 작성 등을 위한 EDSL을 가지고 있습니다. 이런 특화된 언어는 특정 문제를 간결하고 (그리고 종종 안전하게) 해결할 수 있기 때문에 유용합니다. 또한 문법 강조, 호스트 언어의 다양한 도구 등과 같은 언어의 모든 기능을 사용할 수 있습니다. 하지만 EDSL을 만들 때 호스트 언어의 문법과 의미론과 같은 규칙을 준수해야 하는 단점이 있습니다. 몇몇 언어는 이러한 단점을 해결하기 위해 매크로나 언어 확장 기능과 같은 메타 프로그래밍 기능을 제공합니다. 하스켈도 이와 같은 기능을 제공하지만, 많은 EDSLs에서는 이러한 기능이 필요하지 않을 정도로 충분히 표현력이 있고 간결합니다. 대신, 많은 하스켈 EDSL은 조합자 패턴(combinator pattern) 이라는 것을 주로 사용합니다. 이 패턴에서는 원시(primitive) 와 조합자(combinator) 를 정의합니다. 원시는 언어의 기본적인 구성 요소이고, 조합자는 원시를 조합하여 더 복잡한 구조를 만드는 함수입니다. 지금까지 작성한 HTML EDSL에서 원시는 html_, title_ 등의 함수입니다. 이 함수들은 단일 HTML 노드를 생성하는 데 사용되며, 다른 생성된 노드를 입력으로 전달하고&lt;&gt; 함수를 사용하여 더 복잡한 구조를 만듭니다. 우리의 HTML EDSL을 개선할 수 있는 몇 가지 방법이 있습니다: 하스켈의 타입 시스템을 사용하여 유효한 HTML만 생성할 수 있도록 할 수 있습니다. 예를 들어, &lt;head&gt; 노드 없이 &lt;title&gt; 노드를 생성하지 못하게 하거나, 사용자 콘텐츠에 특수 문자를 포함할 수 있으며, 사용자가 유효하지 않은 작업을 시도할 때 타입 오류를 발생시킬 수 있습니다. HTML EDSL을 모듈로 만들어서 다른 모듈에서 재사용할 수 있도록 할 수 있습니다. 이후 섹션에서는 커스텀 타입을 정의하고 모듈을 사용하여 오류를 줄이는 방법을 살펴보고, 하스켈의 연결 리스트에 대해 살펴보겠습니다.","keywords":""},{"title":"Exercises","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/exercises","content":"","keywords":""},{"title":"1. Unordered lists​","type":1,"pageTitle":"Exercises","url":"/learn-haskell-blog-generator/html/exercises#1-unordered-lists","content":"These lists have the form: &lt;ul&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;/ul&gt;  We want in our library a new function: ul_ :: [Structure] -&gt; Structure  So that users can write this: ul_ [ p_ &quot;item 1&quot; , p_ &quot;item 2&quot; , p_ &quot;item 3&quot; ]  and get this: &lt;ul&gt; &lt;li&gt;&lt;p&gt;item 1&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;item 2&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;item 3&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt;  "},{"title":"2. Ordered lists​","type":1,"pageTitle":"Exercises","url":"/learn-haskell-blog-generator/html/exercises#2-ordered-lists","content":"Very similar to unordered lists, but instead of &lt;ul&gt; we use &lt;ol&gt; "},{"title":"3. Code blocks​","type":1,"pageTitle":"Exercises","url":"/learn-haskell-blog-generator/html/exercises#3-code-blocks","content":"Very similar to &lt;p&gt;, but use the &lt;pre&gt; tag. Call this function code_. "},{"title":"Solutions​","type":1,"pageTitle":"Exercises","url":"/learn-haskell-blog-generator/html/exercises#solutions","content":"Unordered lists ul_ :: [Structure] -&gt; Structure ul_ = Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString)  Ordered lists ol_ :: [Structure] -&gt; Structure ol_ = Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString) Note: the two functions above could be unified. Code blocks code_ :: String -&gt; Structure code_ = Structure . el &quot;pre&quot; . escape  "},{"title":"유연한 HTML 콘텐츠 (함수)","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/html-content","content":"","keywords":""},{"title":"들여쓰기​","type":1,"pageTitle":"유연한 HTML 콘텐츠 (함수)","url":"/learn-haskell-blog-generator/html/html-content#들여쓰기","content":"하스켈은 어떻게 정의가 완료되었는지 알 수 있을까요? 정답은 하스켈은 들여쓰기를 사용하여 표현식이 어떻게 그룹화되어야 하는지 알 수 있다는 것입니다. 하스켈의 들여쓰기 법칙은 약간 까다로울 수 있지만, 일반적으로 다음과 같습니다: 표현식의 일부가 되어야 하는 코드는 해당 표현식의 시작보다 더 들여쓰기되어야 합니다. 만약 두 표현식이 동일한 들여쓰기를 가지고 있다면, 이들은 서로 독립적이라고 할 수 있습니다. "},{"title":"들여쓰기 팁​","type":1,"pageTitle":"유연한 HTML 콘텐츠 (함수)","url":"/learn-haskell-blog-generator/html/html-content#들여쓰기-팁","content":"들여쓰기할 공백의 개수를 선택하고 (2개, 4개 등) 이를 유지하세요. 탭보다는 공백을 사용하세요.한 번에 두 번 이상 들여쓰기를 하지 마십시오.확실하지 않은 경우 필요에 따라 줄을 삭제하고 한 번 들여쓰기합니다. 다음과 같은 예제가 있습니다: main = putStrLn &quot;Hello, world!&quot;  또는: main = putStrLn (wrapHtml &quot;Hello, world!&quot;)  다음 스타일은 피하세요. 들여쓰기 단계를 두 개 이상 사용하거나 완전히 무시하고 있습니다: main = putStrLn (wrapHtml &quot;Hello, world!&quot;)  main = putStrLn (wrapHtml &quot;Hello, world!&quot;)  "},{"title":"문자 이스케이프 처리하기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/escaping-characters","content":"","keywords":""},{"title":"연결 리스트​","type":1,"pageTitle":"문자 이스케이프 처리하기","url":"/learn-haskell-blog-generator/html/escaping-characters#연결-리스트","content":"하스켈에서 연결 리스트(linked lists)는 매우 일반적인 데이터 구조입니다. 그래서 이를 위한 특별한 구문(syntax)이 존재합니다: 리스트의 유형은 대괄호로 표시되며 대괄호 안에는 요소의 타입이 있습니다. 예를 들어: [Int] - 정수의 리스트[Char] - 문자의 리스트[String] - 문자열의 리스트[[String]] - 문자열의 리스트의 리스트[a] - 임의의 단일 유형의 리스트 (모든 요소는 동일한 타입이어야 함) 빈 리스트는 다음과 같이 작성됩니다: []리스트에 요소를 추가하는 것은 : 연산자를 사용하여 수행합니다 (이를 cons라고 함). 이 연산자는 오른쪽 결합성(right-associative)을 가집니다 (예: -&gt;). 예를 들어: 1 : [], 또는 1 : 2 : 3 : [].위 목록은 다음과 같이 작성할 수 있습니다: [1] 및 [1, 2, 3]. 또한, 문자열은 문자의 연결 리스트입니다 - 문자열은 다음과 같이 정의됩니다:type String = [Char]이므로 우리는 문자열을 리스트와 동일한 방식으로 사용할 수 있습니다. 노트 연결 리스트는 편리한 데이터 구조이지만, 모든 경우에 적합한 것은 아닙니다. 특히 공간 효율성이 떨어지고, 데이터 추가, 임의 접근(random access) 등에 느립니다. 따라서 String을 사용하는 것이 효율적이지 않을 수 있습니다. 그래서 외부 패키지에서 제공하는 Text라는 다른 문자열 타입을 사용하는 것을 권장합니다.Text와 다른 데이터 구조에 대해서는 이후에 다루겠습니다! 리스트에 대한 연산을 패턴 매칭과 재귀(recursion)를 사용하여 구현할 수 있습니다. 이에 대한 자세한 내용은 ADT를 소개할 때 다루겠습니다. 지금은, Data.List 모듈에 있는 다양한 함수를 사용하겠습니다. 그 중에서 map과concat 함수를 사용하겠습니다. "},{"title":"map​","type":1,"pageTitle":"문자 이스케이프 처리하기","url":"/learn-haskell-blog-generator/html/escaping-characters#map","content":"map을 사용하면 리스트의 각 요소에 함수를 적용할 수 있습니다. 이 함수의 타입 시그니처는 다음과 같습니다: map :: (a -&gt; b) -&gt; [a] -&gt; [b]  예를 들면: map not [False, True, False] == [True, False, True]  또는 이전에 정의한 escape 함수처럼, 각 문자열을 이스케이프할 때 사용할 수 있습니다: map escapeChar ['&lt;','h','1','&gt;'] == [&quot;&amp;lt;&quot;,&quot;h&quot;,&quot;1&quot;,&quot;&amp;gt;&quot;]  하지만 escapeChar의 타입은 Char -&gt; String이므로,map escapeChar ['&lt;','h','1','&gt;']의 반환 타입은 [String]이자만, 원하는 것은 String입니다. 그래서 리스트를 평평하게(flatten) 만들어 줄 concat 함수가 필요합니다. "},{"title":"concat​","type":1,"pageTitle":"문자 이스케이프 처리하기","url":"/learn-haskell-blog-generator/html/escaping-characters#concat","content":"concat의 타입은 다음과 같습니다: concat :: [[a]] -&gt; [a]  이 함수는 리스트의 리스트를 받아서 리스트를 반환합니다. 예제의 경우, concat은 [String]을 받아서 String을 반환합니다.String은 [Char]의 타입 별칭(type alias)이므로, 실제로는 [[Char]] -&gt; [Char]입니다. "},{"title":"GHCi​","type":1,"pageTitle":"문자 이스케이프 처리하기","url":"/learn-haskell-blog-generator/html/escaping-characters#ghci","content":"우리가 작성한 코드를 빠르게 확인하는 방법 중 하나는 GHCi라는 대화식 개발 환경(interactive development environment)을 사용하는 것입니다.ghci를 실행하면 대화식 프롬프트가 열리고, 하스켈 표현식을 작성하고 평가할 수 있습니다. 이를 &quot;Read-Evaluate-Print Loop&quot; (REPL)이라고 합니다. 예를 들면: ghci&gt; 1 + 1 2 ghci&gt; putStrLn &quot;Hello, world!&quot; Hello, world!  새로운 이름도 정의할 수 있습니다: ghci&gt; double x = x + x ghci&gt; double 2 4  :{와 :}로 코드 블록을 감싸면 여러 줄의 코드를 작성할 수 있습니다: ghci&gt; :{ | escape :: String -&gt; String | escape = | let | escapeChar c = | case c of | '&lt;' -&gt; &quot;&amp;lt;&quot; | '&gt;' -&gt; &quot;&amp;gt;&quot; | '&amp;' -&gt; &quot;&amp;amp;&quot; | '&quot;' -&gt; &quot;&amp;quot;&quot; | '\\'' -&gt; &quot;&amp;#39;&quot; | _ -&gt; [c] | in | concat . map escapeChar | :} ghci&gt; escape &quot;&lt;html&gt;&quot; &quot;&amp;lt;html&amp;gt;&quot;  하스켈 소스 파일은 :load(또는 :l로 줄여서) 명령어로 불러올 수 있습니다: ghci&gt; :load Html.hs [1 of 1] Compiling Html ( Html.hs, interpreted ) Ok, one module loaded. ghci&gt; render (html_ &quot;&lt;title&gt;&quot; (p_ &quot;&lt;body&gt;&quot;)) &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&amp;lt;title&amp;gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;  라이브러리 모듈도 불러올 수 있습니다: ghci&gt; import Data.Bits ghci&gt; shiftL 32 1 64 ghci&gt; clearBit 33 0 32  표현식의 타입을 알고 싶다면 :type(또는 :t로 줄여서) 명령어를 사용할 수도 있습니다: λ&gt; :type escape escape :: String -&gt; String  ghci를 종료하려면, :quit(또는 :q로 줄여서) 명령어를 사용합니다: ghci&gt; :quit Leaving GHCi.  GHCi는 빠른 실험과 탐색에 유용한 도구입니다. 위에서 몇 가지 예를 보았습니다 - escape 함수에 문자열 &quot;&lt;html&gt;&quot;을 전달하면 &quot;&amp;lt;html&amp;gt;&quot;라는 문자열을 반환합니다. 이 문자열은 브라우저에서 HTML 태그 대신 &lt;html&gt;로 렌더링됩니다. 만약 특정한 함수가 무엇을 하는지 이해하기 어렵다면, GHCi에서 테스트해보세요. 다양한 입력을 넣어보고, 예상한 결과와 일치하는지 확인하세요. 구체적인 예제를 실행하는 것은 코드를 이해하는 데 많은 도움이 될 수 있습니다! 팁 GHCi에 대해 더 자세히 알고 싶다면, GHC 사용자 가이드에서 더 자세한 소개를 찾을 수 있습니다. "},{"title":"이스케이프​","type":1,"pageTitle":"문자 이스케이프 처리하기","url":"/learn-haskell-blog-generator/html/escaping-characters#이스케이프","content":" 현재 우리가 작성한 라이브러리는 오직 다음 항목만 지원합니다: 페이지 제목문단제목 더 진행하기 전에, escape 함수를 적용해 HTML 생성을 안전하게 만들려고 합니다. escape 함수를 적용해보세요. 정답 html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; (escape title)) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot; . escape h1_ :: String -&gt; Structure h1_ = Structure . el &quot;h1&quot; . escape   수정된 Html.hs Html.hs module Html ( Html , Title , Structure , html_ , p_ , h1_ , append_ , render ) where -- * Types newtype Html = Html String newtype Structure = Structure String type Title = String -- * EDSL html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; (escape title)) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot; . escape h1_ :: String -&gt; Structure h1_ = Structure . el &quot;h1&quot; . escape append_ :: Structure -&gt; Structure -&gt; Structure append_ c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) -- * Render render :: Html -&gt; String render html = case html of Html str -&gt; str -- * Utilities el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; getStructureString :: Structure -&gt; String getStructureString content = case content of Structure str -&gt; str escape :: String -&gt; String escape = let escapeChar c = case c of '&lt;' -&gt; &quot;&amp;lt;&quot; '&gt;' -&gt; &quot;&amp;gt;&quot; '&amp;' -&gt; &quot;&amp;amp;&quot; '&quot;' -&gt; &quot;&amp;quot;&quot; '\\'' -&gt; &quot;&amp;#39;&quot; _ -&gt; [c] in concat . map escapeChar  hello.hs 파일에서 유효하지 않은 HTML을 제공하면 제대로 동작하는지 확인해보세요! 이제 우리는 작은 HTML 라이브러리를 안전하게 사용할 수 있습니다. 그러나 사용자가 예상하지 못한 유효한 사용 사례, 예를 들어 순서 없는 목록을 추가하려는 경우에는 어떻게 해야 할까요? 우리는 라이브러리를 확장하는 것을 완전히 막고 있습니다. 다음에는 이에 대해 이야기 해보겠습니다. "},{"title":"내부 기능 노출하기 (내부 모듈)","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/internal-modules","content":"","keywords":""},{"title":"내부 모듈​","type":1,"pageTitle":"내부 기능 노출하기 (내부 모듈)","url":"/learn-haskell-blog-generator/html/internal-modules#내부-모듈","content":"이를 위해 내부 모듈을 노출하여 고급 사용자에게 일부 유연성을 제공할 수 있습니다. 내부 모듈은 언어 개념이 아니라 하스켈에서 흔히 볼 수 있는 디자인 패턴(또는 관용구)입니다. 내부 모듈은 &lt;something&gt;.Internal과 같이 이름이 지정된 모듈로, 해당 모듈의 모든 기능과 구현 세부 사항을 노출합니다. 예를 들어, 내부 구현을 Html 모듈에 작성하는 대신 모든 항목을 내보내는 Html.Internal 모듈에 작성합니다. 그리고 해당 모듈을 Html 모듈에 가져와서 (이전처럼) 우리가 원하는 API만 명시적으로 내보냅니다. Internal 모듈은 관례적으로 불안정하고 사용하기 위험하다고 간주됩니다. 만약 외부 하스켈 라이브러리를 사용할 때 Internal 모듈을 사용하게 되면, 모든 문제를 해결하고 나서 라이브러리 저장소에 이슈를 열어주세요! "},{"title":"수정하기​","type":1,"pageTitle":"내부 기능 노출하기 (내부 모듈)","url":"/learn-haskell-blog-generator/html/internal-modules#수정하기","content":"이제 Html 이라는 디렉터리를 만들고 그 안에 Internal.hs라는 파일을 만듭니다. 이 모듈의 이름은 Html.Internal이어야 합니다. 이 모듈은 이전에 Html 모듈에 있었던 모든 코드를 포함하지만, 모듈 선언을을 수정해 내보내기 목록을 생략할 것입니다: Html/Internal.hs module Html.Internal where ...  이제 Html.hs 파일에서 Html/Internal.hs로 옮긴 코드를 제거하고 대신 내부 모듈을 가져옵니다: Html.hs module Html ( Html , Title , Structure , html_ , p_ , h1_ , append_ , render ) where import Html.Internal  이제 사용자는 Html 모듈을 가져와 안전하게 라이브러리를 사용할 수 있습니다. 만약 사용자가 라이브러리를 통해 순서없는 목록(ul, ui 태그)기능을 구현하고 싶다면, Html.Internal 모듈을 사용할 수 있습니다. 수정된 Html.hs 과 Html/Internal.hs Html.hs module Html ( Html , Title , Structure , html_ , p_ , h1_ , append_ , render ) where import Html.Internal Html/Internal.hs module Html.Internal where -- * Types newtype Html = Html String newtype Structure = Structure String type Title = String -- * EDSL html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; (escape title)) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot; . escape h1_ :: String -&gt; Structure h1_ = Structure . el &quot;h1&quot; . escape append_ :: Structure -&gt; Structure -&gt; Structure append_ c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) -- * Render render :: Html -&gt; String render html = case html of Html str -&gt; str -- * Utilities el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; getStructureString :: Structure -&gt; String getStructureString content = case content of Structure str -&gt; str escape :: String -&gt; String escape = let escapeChar c = case c of '&lt;' -&gt; &quot;&amp;lt;&quot; '&gt;' -&gt; &quot;&amp;gt;&quot; '&amp;' -&gt; &quot;&amp;amp;&quot; '&quot;' -&gt; &quot;&amp;quot;&quot; '\\'' -&gt; &quot;&amp;#39;&quot; _ -&gt; [c] in concat . map escapeChar  "},{"title":"요약​","type":1,"pageTitle":"내부 기능 노출하기 (내부 모듈)","url":"/learn-haskell-blog-generator/html/internal-modules#요약","content":"우리 프로젝트에서는, 내부 모듈이 필요하지 않습니다. 우리 프로젝트와 HTML EDSL의 소스 코드는 동일한 프로젝트에 있으며, Html 모듈에 직접 접근 할 수 있기 때문입니다. 우리는 원할 때 언제든지 모듈을 수정 할 수 있습니다. 하지만 만약 다른 개발자가 사용하기 위해 HTML EDSL을 라이브러리로 출시하려고 한다면, 사용자가 내부 구현에 접근할 수 있도록 Internal 모듈을 노출하는 것이 좋습니다. 이렇게 하면 사용자가 라이브러리를 사용하는 데 어려움을 겪지 않을 수 있습니다! 소스 코드로부터 패키지를 만드는 방법에 대해서는 이후에 다룰 예정입니다. "},{"title":"모듈을 사용하여 잘못된 사용 방지하기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/modules","content":"","keywords":""},{"title":"모듈​","type":1,"pageTitle":"모듈을 사용하여 잘못된 사용 방지하기","url":"/learn-haskell-blog-generator/html/modules#모듈","content":"각 하스켈 소스 파일은 모듈입니다. 모듈 이름은 소스 파일 이름과 같아야 하며 대문자로 시작해야 합니다. 하위 디렉토리도 모듈 이름에 포함되어야 하며 하위 디렉토리를 나타내기 위해 .을 사용합니다. 다음 장에서 이를 자세히 살펴보겠습니다. 위 규칙의 유일한 예외는 프로그램의 진입점 모듈입니다.main의 정의가 존재하는 이름이 'Main'인 모듈을 말합니다. 이 모듈의 소스 파일 이름은 원하는 대로 지을 수 있습니다. 모듈 정의는 다음과 같습니다: module &lt;모듈 이름&gt; ( &lt;내보내기(export) 목록&gt; ) where  모듈 내의 모든 항목을 내보내고 싶다면 내보내기 목록을 생략할 수 있지만 그렇게 하지 않겠습니다. 우리의 작은 라이브러리를 사용하는 방법을 제어하기 위해 원하는 함수와 타입만 내보내겠습니다. Html.hs라는 이름의 새 소스 파일을 만들고 다음과 같이 모듈 선언 코드를 파일 상단에 추가합니다: module Html ( Html , Title , Structure , html_ , p_ , h1_ , append_ , render ) where  다음 항목은 내보내지 않습니다: 새로 정의한 타입의 생성자는 제외하고 타입만 내보냅니다. 생성자도 내보내고 싶다면 Html(Html) 또는 Html(..)와 같이 작성하면 됩니다. 이렇게 하면 사용자가 Structure &quot;Hello&quot;와 같이 직접 Structure를 만들 수 없습니다. 라이브러리가 사용하는 내부 함수, 예를 들어 el과 getStructureString입니다. hello.hs 파일에서 HTML과 관련된 함수들도 Html.hs로 옮깁니다: newtype Html = Html String newtype Structure = Structure String type Title = String html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; title) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot; h1_ :: String -&gt; Structure h1_ = Structure . el &quot;h1&quot; el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; append_ :: Structure -&gt; Structure -&gt; Structure append_ c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) getStructureString :: Structure -&gt; String getStructureString content = case content of Structure str -&gt; str render :: Html -&gt; String render html = case html of Html str -&gt; str  이제 import구문을 사용해서 이 모듈을 가져오는 경우 우리가 내보낸 것만 가져올 수 있습니다. hello.hs 파일 상단에 다음 코드를 추가합니다: import Html  이제 hello.hs 파일은 다음과 같이 변경됩니다: hello.hs import Html main :: IO () main = putStrLn (render myhtml) myhtml :: Html myhtml = html_ &quot;My title&quot; ( append_ (h1_ &quot;Heading&quot;) ( append_ (p_ &quot;Paragraph #1&quot;) (p_ &quot;Paragraph #2&quot;) ) )  그리고 Html.hs 파일은 다음과 같이 변경됩니다: Html.hs module Html ( Html , Title , Structure , html_ , p_ , h1_ , append_ , render ) where newtype Html = Html String newtype Structure = Structure String type Title = String html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; title) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot; h1_ :: String -&gt; Structure h1_ = Structure . el &quot;h1&quot; el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; append_ :: Structure -&gt; Structure -&gt; Structure append_ c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) getStructureString :: Structure -&gt; String getStructureString content = case content of Structure str -&gt; str render :: Html -&gt; String render html = case html of Html str -&gt; str  정보 HTML 값을 만드는 함수의 접미사로 밑줄(_)을 사용한것을 눈치채신 분도 있을겁니다. 이는 미학적인 결정으로, 개인적으로 EDSL을 더 쉽게 인식할 수 있다고 생각했기 때문입니다. 또한 head와 같은 하스켈 표준 라이브러리에 정의된 함수와의 이름 충돌을 피할 수 있기에 유용합니다. 이 아이디어는 lucid라는 하스켈 HTML 라이브러리에서 가져왔습니다! "},{"title":"Summary","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/summary","content":"Summary In this chapter we built a very minimal HTML EDSL. We will later use this library to convert our custom markup formatted text to HTML. We've also learned about: Defining and using functionsTypes and type signaturesEmbedded domain specific languagesChaining functions using the . operatorPreventing incorrect use with newtypesDefining modules and the Internal module patternEncapsulation using newtypes and modules Here's our complete program up to this point: -- hello.hs import Html main :: IO () main = putStrLn (render myhtml) myhtml :: Html myhtml = html_ &quot;My title&quot; ( append_ (h1_ &quot;Heading&quot;) ( append_ (p_ &quot;Paragraph #1&quot;) (p_ &quot;Paragraph #2&quot;) ) ) -- Html.hs module Html ( Html , Title , Structure , html_ , h1_ , p_ , ul_ , ol_ , code_ , append_ , render ) where import Html.Internal -- Html/Internal.hs module Html.Internal where -- * Types newtype Html = Html String newtype Structure = Structure String type Title = String -- * EDSL html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; (escape title)) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot; . escape h1_ :: String -&gt; Structure h1_ = Structure . el &quot;h1&quot; . escape ul_ :: [Structure] -&gt; Structure ul_ = Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString) ol_ :: [Structure] -&gt; Structure ol_ = Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString) code_ :: String -&gt; Structure code_ = Structure . el &quot;pre&quot; . escape append_ :: Structure -&gt; Structure -&gt; Structure append_ c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) -- * Render render :: Html -&gt; String render html = case html of Html str -&gt; str -- * Utilities el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; getStructureString :: Structure -&gt; String getStructureString content = case content of Structure str -&gt; str escape :: String -&gt; String escape = let escapeChar c = case c of '&lt;' -&gt; &quot;&amp;lt;&quot; '&gt;' -&gt; &quot;&amp;gt;&quot; '&amp;' -&gt; &quot;&amp;amp;&quot; '&quot;' -&gt; &quot;&amp;quot;&quot; '\\'' -&gt; &quot;&amp;#39;&quot; _ -&gt; [c] in concat . map escapeChar You can also browse the code as a tree.","keywords":""},{"title":"타입으로 안전한 HTML 구성하기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/safer-construction","content":"","keywords":""},{"title":"newtype​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#newtype","content":"newttype 선언은 기존 값 집합에 대해 새로운 타입을 정의하는 방법입니다. 이는 기존 값을 재사용하지만 다른 의미를 부여하고 두 가지를 혼동되지 않도록 하기에 유용합니다. 예를 들어, 초, 분, 그램, 엔을 정수 값으로 표현할 수 있지만, 초와 그램을 잘못 섞어 쓰는걸 원하진 않을것입니다. 우리가 만드는 프로그램의 경우 구조화된 HTML을 텍스트 값으로 표현하고 싶지만, 유효한 HTML이 아닌 평범한 문자열과 구분하고 싶습니다. newtype 선언은 다음과 같이 생겼습니다: newtype &lt;타입 이름&gt; = &lt;생성자&gt; &lt;기존 타입&gt;  예를들면 Html 타입을 다음과 같이 정의할 수 있습니다: newtype Html = Html String  등호 왼쪽의 Html은 타입 이름 공간(namespace)에 존재합니다. 즉, :: 뒤에만 나올 수 있는 이름입니다. 등호 오른쪽의 Html은 표현식 (혹은 terms/values) 이름 공간에 존재합니다. 즉, 표현식에서만 나올 수 있는 이름입니다. (곧 그 위치를 살펴보겠습니다). 두 이름, &lt;타입 이름&gt;과 &lt;생성자&gt;는 같을 필요는 없지만, 일반적으로 같습니다. 그리고 두 이름 모두 대문자로 시작해야 합니다. newtype 선언의 오른쪽은 해당 타입의 모양을 의미합니다. 위의 경우, Html 타입의 값은 Html 생성자와 그 뒤에 오는 문자열 타입의 표현식을 가지고 있습니다. 예를 들면 Html &quot;hello&quot; 또는 Html (&quot;hello &quot; &lt;&gt; &quot;world&quot;)가 될 수 있습니다. 생성자는 인자를 받아서 새로운 타입의 반환하는 함수로 생각할 수 있습니다: Html :: String -&gt; Html  주의 Html 타입의 표현식을 String 타입의 표현식과 같은 방식으로 사용할 수 없습니다. 즉, &quot;hello &quot; &lt;&gt; Html &quot;world&quot;는 타입 에러가 발생합니다. 이것은 캡슐화(encapsulation)가 필요할 때 유용합니다. 기본 타입에 대한 표현과 함수를 정의하고 사용할 수 있지만, 관련 없는(우리 도메인과 관련이 없는) 타입들과 혼동되지 않도록 합니다. 미터와 피트가 모두 숫자가 될 수 있지만, 우리는 변환 없이 실수로 미터와 피트를 더하는 것을 원치 않습니다.  이제 유용한 몇 가지 타입을 더 만들어 보겠습니다. 우리는 다음 두 가지 타입을 사용할 것입니다: 완전한 HTML 문서&lt;body&gt; 태그 안에 들어갈 수 있는 제목과 문단과 같은 HTML 구조에 대한 타입 우리는 두 가지 타입이 혼용되지 않기를 원합니다. 정답 newtype Html = Html String newtype Structure = Structure String   "},{"title":"newtype 사용하기​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#newtype-사용하기","content":"newtype이 감싸고 있는 내부 타입을 사용하려면, 우선 그 타입을 추출해야 합니다. 이를 위해 패턴 매칭을 사용합니다. 패턴 매칭은 두 가지 방법으로 사용할 수 있습니다. 하나는 case 표현식이고, 다른 하나는 함수 정의입니다. case 표현식은 switch 표현식과 비슷하며 다음과 같이 생겼습니다: case &lt;표현식&gt; of &lt;패턴&gt; -&gt; &lt;표현식&gt; ... &lt;패턴&gt; -&gt; &lt;표현식&gt; &lt;표현식&gt;은 추출하고자 하는 것이고, &lt;패턴&gt;은 그것의 구체적인 모양입니다. 예를 들어, Structure 타입을 정의했다고 가정해 봅시다. 이 타입의 String 값을 추출하고 싶다면 다음과 같이 합니다: getStructureString :: Structure -&gt; String getStructureString struct = case struct of Structure str -&gt; str 이렇게 하면 Structure에서 String을 추출하고 반환할 수 있습니다. 이후 장에서 data 선언을 소개할 것입니다. (이는 struct + enum의 혼성체와 비슷합니다.) 여기서는 여러 생성자를 가진 타입을 정의할 수 있습니다. 그러면 case 표현식의 여러 패턴이 더 의미가 있게 될 것입니다. 다른 방법으로, 함수를 정의할 때, 인자에 대해 패턴 매칭을 사용할 수 있습니다: func &lt;패턴&gt; = &lt;표현식&gt; 예를 들면: getStructureString :: Structure -&gt; String getStructureString (Structure str) = str 이제 이전에 정의한 html_, body_, p_ 등의 함수를 String 대신에 새로운 타입을 사용하도록 변경할 수 있습니다. 그 전에, 우리의 코드를 더 간결하게 만들 수 있는 또 다른 연산자를 만나보겠습니다. newtype의 또 다른 유용한 점은, 표현식을 감싸고 추출하는 것이 실제로는 성능에 영향을 주지 않는다는 것입니다! 컴파일러는 newtype 생성자의 감싸고 추출하는 것을 제거하고 기본 타입을 사용합니다. 우리가 정의한 타입과 생성자는 오직 우리가 코드를 작성할 때 기존 타입과 새로운 타입을 구분하는 데 도움을 주는 것이고,코드가 실행 중에는 필요하지 않습니다. newtype은 타입 안전성을 제공하면서도 성능에 영향을 주지 않습니다! "},{"title":"함수 합성​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#함수-합성","content":"또 다른 흥미롭고 굉장히 자주 쓰이는 연산자로 (하스켈 일반 라이브러리 함수인) . (compose)가 있습니다. 이 연산자는 수학에서 알고 있는 합성 연산자(∘)와 비슷하게 생겼습니다. 연산자의 타입과 구현을 살펴보겠습니다: (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c (.) f g x = f (g x)  이 연산자는 3 개의 인자를 받습니다: 두 개의 함수(여기서는 f와 g라고 부릅니다)와 세 번째 인자 x입니다. 그런 다음 x를 두 번째 함수 g에 전달하고, g x의 결과를 첫 번째 함수 f에 전달합니다. g 함수가 a 타입의 값을 받고 b 타입의 값을 반환하고, f 함수가 b 타입의 값을 받고 c 타입의 값을 반환한다는 점을 주목하세요. 또 다른 주목해야 할 점으로 소문자로 시작하는 타입이 있는데 이는 타입 변수(type variables)라 합니다. 이는 일반적인 변수와 비슷합니다. content는 hello나 world처럼 어떤 문자열이 될 수 있듯이, 타입 변수는 Bool, String, String -&gt; String 등 어떤 타입이 될 수 있습니다. 이러한 기능을 매개변수 다형성(parametric polymorphism)이라고 합니다. (다른 언어에서는 이를 제네릭(generics)이라고 부릅니다.) 주의해야 할 점은 타입 변수는 반드시 서명(signature)과 일치해야 한다는 것입니다. 예를 들어, a -&gt; a라는 서명을 가진 함수를 정의하려고 한다면, 입력 타입과 반환 타입은 반드시 일치해야 하지만, 어떤 타입이든 될 수 있습니다. 그래서 이 서명을 가진 함수를 구현하는 유일한 방법은 다음과 같습니다: id :: a -&gt; a id x = x  항등 함수를 의미하는 id는 받은 값을 그대로 반환합니다. 만약 다른 방법을 사용하려고 하면, 예를 들어 &quot;hello&quot;와 같은 임의의 값을 반환하거나,x를 알고 있는 타입의 값처럼 사용해 x + x와 같은 표현식을 작성하면, 타입 오류가 발생합니다. -&gt; 연산자는 오른쪽으로 결합되는 것을 기억하시나요? 이 서명은 다음과 같이 해석할 수 있습니다: (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)  이는 마치 함수가 두 함수를 받아서 합성한 함수를 반환하는 것처럼 보이지 않나요? 이제 이 연산자를 사용해 HTML 함수를 다시 작성해보겠습니다.p_ 함수부터 시작해보겠습니다. 기존 정의는 다음과 같았습니다: p_ :: String -&gt; String p_ = el &quot;p&quot;  이제, 다음과 같이 작성할 수 있습니다: p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot;  p_ 함수는 문단을 의미하는 임의의 String을 받아서 &lt;p&gt;와 &lt;/p&gt; 태그로 감싼 후, 타입을 더 자세히 살펴보겠습니다: Structure :: String -&gt; Structureel &quot;p&quot; :: String -&gt; String(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)Structure . el &quot;p&quot; :: String -&gt; Structure 표현식 Structure . el &quot;p&quot;가 타입 검사를 통과하는 이유와, 타입이 String -&gt; Structure인 이유를 살펴보겠습니다. "},{"title":"펜과 종이로 타입 검사하기​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#펜과-종이로-타입-검사하기","content":"표현식이 어떻게 타입 검사를 통과하는지 이해하고 싶다면, 체계적으로 타입 검사를 해보는 것이 좋습니다. 다음 예제를 살펴보겠습니다. 이 예제에서 우리는 다음 표현식을 타입 검사하려고 합니다. p_ = Structure . el &quot;p&quot;  우선, 가장 바깥쪽 함수의 타입을 적습니다. 이 경우에는 연산자 .의 타입입니다: (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)  그런 다음, 우리는 이 함수에 적용할 인자의 타입과 함수서명의 타입과 비교합니다. 먼저, .의 두 개의 인자의 타입을 확인합니다: Structure :: String -&gt; Structureel &quot;p&quot; :: String -&gt; String 다행히 . 연산자는 두 개의 인자를 받고, 다음과 같은 타입을 가집니다: b -&gt; ca -&gt; b 주의 함수가 받을 수 있는 인자의 수보다 더 많은 인자를 적용하면 타입 오류가 발생합니다. . 연산자는 우리가 제공한 인자의 수만큼 인자를 받기 때문에, 다음 단계로 넘어갑니다: 타입 검사의 다음 단계는 입력 타입과 (연산자의 서명을 통해) 예상되는 타입을 비교하는 것입니다. 두 타입을 비교할 때, 둘 간의 동등성(equivalence)를 확인합니다. 여기에는 몇 가지 가능한 시나리오가 있습니다: 두 타입이 Int, Bool과 같은 구체적(concrete)(타입 변수가 아닌)이고 단순한 타입인 경우, 두 타입이 같은지 확인합니다. 만약 같다면, 타입 검사를 통과하고 계속 진행합니다. 만약 다르다면, 타입 검사를 통과하지 못하고 오류를 발생시킵니다.두 타입이 더 복잡한 경우(예를 들어 둘 다 함수인 경우), 입력과 출력을 비교합니다. 만약 입력과 출력이 일치한다면, 두 타입이 일치한다고 판단합니다.두 타입중 하나가 타입 변수인 특별한 경우가 있습니다. 이 경우, 타입 검사를 방정식처럼 처리합니다. 그리고 어딘가에 적어둡니다. 다음에 이 타입 변수를 볼 때, 방정식에 있는 값으로 대체합니다. 이것을 타입 변수에 값을 할당(assign) 한다고 생각하면 됩니다. 위 예제에서, 우리는 다음 두 가지 타입을 비교해야 합니다: String -&gt; Structure 과 b -&gt; cString -&gt; String 과 a -&gt; b 하나씩 살펴보겠습니다. 먼저, String -&gt; Structure과 b -&gt; c를 비교해보겠습니다: 두 타입이 복잡하므로, 두 타입이 모두 함수라는 것을 확인하고, 입력과 출력을 비교합니다.String과 b, 그리고 Structure와 c를 비교합니다.b는 타입 변수이므로, 어딘가에 적어둡니다. b는 String과 동등하다고 적어둡니다.b ~ String (우리는 ~를 동등함을 나타내는 기호로 사용합니다).같은 방식으로 c도 Structure와 동등하다고 적어둡니다. c ~ Structure. 지금까지 문제는 없습니다. 이제 String -&gt; String과 a -&gt; b를 비교해보겠습니다: 두 타입이 복잡하므로, 두 타입이 모두 함수라는 것을 확인하고, 입력과 출력을 비교합니다.String과 a를 비교합니다. a ~ String으로 적어둡니다.String과 b를 비교합니다. b는 이미 적어둔 방정식을 가지고 있습니다.b ~ String이라고 적어둔 것을 기억합니다. b를 String으로 대체하고, 이 타입과 비교합니다. String과 String을 비교하므로, 타입 검사를 통과합니다. 우리는 무사히 표현식을 타입 검사했고, 다음과 같은 타입 변수의 동등성을 찾았습니다: a ~ Stringb ~ Stringc ~ Structure 이제, 다음 표현식의 타입을 찾아보겠습니다: p_ = Structure . el &quot;p&quot;  이 표현식의 타입을 찾기 위해, 우리가 찾은 방정식을 사용하여 타입 변수를 대체하고, 우리가 적용한 인자를 제거합니다. 그래서 다음과 같은 타입을 얻습니다: (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)  그리고 다음과 같이 타입 변수를 대체합니다: (.) :: (String -&gt; Structure) -&gt; (String -&gt; String) -&gt; (String -&gt; Structure)  그리고 함수를 적용하면서 두 개의 인자를 제거합니다: Structure . el &quot;p&quot; :: String -&gt; Structure  이제, 우리는 이 표현식의 타입을 찾았습니다! 다행히, 하스켈은 이 과정을 대신 해줄 수 있습니다. 하지만 하스켈이 타입 에러를 발생시키는 경우, 그 이유를 이해하지 못하는 상황이 발생할 수 있습니다. 이럴때 위와 같은 과정을 거치면, 타입이 일치하지 않는 부분을 찾을 수 있고, 그 부분을 해결할 수 있습니다. 주의 만약 우리가 매개변수화된 다형성을 가진 함수를 두 번 이상 사용하거나, 비슷한 타입 변수 이름을 가진 다른 함수를 사용한다면, 이름이 같다고 해서 모든 인스턴스에서 타입 변수가 일치할 필요는 없습니다. 각 인스턴스는 고유한 타입 변수 집합을 가집니다. 예를 들어: id :: a -&gt; a ord :: Char -&gt; Int chr :: Int -&gt; Char incrementChar :: Char -&gt; Char incrementChar c = chr (ord (id c) + id 1) 위의 코드에서 id를 두 번 사용합니다. (예시로 사용하기 위함일 뿐 좋은 구조는 아닙니다) 첫 번째 id는 Char를 인자로 받고, a는 Char와 동등합니다. 두 번째 id는 Int를 인자로 받고, 구별된 a는 Int와 동등합니다. 이 상황은 오직 최상위(top-level)에 정의한 함수에만 적용됩니다. 만약 우리가 incrementChar에 인자로 전달할 지역 함수를 정의하고,id와 같은 타입 시그니처를 가진다면, 모든 사용처에서 타입이 일치해야 합니다. 다음 코드의 경우: incrementChar :: (a -&gt; a) -&gt; Char -&gt; Char incrementChar func c = chr (ord (func c) + func 1) 타입 에러가 발생합니다. 직접 확인해보세요! "},{"title":"구조 확장하기​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#구조-확장하기","content":"이전에 우리는 풍부한 HTML 컨텐츠를 만들고 위해 노드를 이어붙이기 위해 &lt;&gt; 연산자를 사용했습니다. 하지만 이제 String을 사용하지 않으므로, 다른 방법을 사용해야 합니다. 물론 하스켈에서 타입클래스로 불리는 기능을 통해 &lt;&gt; 연산자를 오버로딩하여 사용할 수 있지만, 이번에는 append_라는 이름의 새로운 함수를 만들고, 타입클래스에 대해서는 나중에 다루겠습니다. append_는 두 개의 Structure를 인자로 받고, 첫 번째 Structure의 내부 String을 두 번째 Structure에 붙여서 새로운 Structure를 반환합니다.  append_ 함수를 구현해보세요. 정답 append_ :: Structure -&gt; Structure -&gt; Structure append_ (Structure a) (Structure b) = Structure (a &lt;&gt; b)   "},{"title":"Html을 String으로 되돌리기​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#html을-string으로-되돌리기","content":"유효한 Html 값을 만들었으니, 브라우저에서 출력할 수 있도록 Html을 String으로 변환할 수 있는 함수가 필요합니다. 이를 위해 Html을 String으로 변환한 후 putStrLn에 전달하는 함수가 필요합니다.  render 함수를 구현해보세요. 정답 render :: Html -&gt; String render html = case html of Html str -&gt; str   "},{"title":"type​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#type","content":"타입에 새로운 이름을 붙이는 방법은 또 다른 방법이 있습니다. type 정의는 newtype 정의와 매우 유사합니다. 유일한 차이점은 생성자 없이 타입 이름을 참조한다는 것입니다: type &lt;type-name&gt; = &lt;existing-type&gt;  이전 예제에서 type을 사용하면 다음과 같이 작성할 수 있습니다: type Title = String  type은 newtype과 다르게 타입 이름에 대한 별칭입니다.Title을 String의 타입 별칭으로 선언했다는 것은, 두 타입은 서로 대체 가능하고, 언제든지 하나를 다른 하나로 사용할 수 있다는 것을 의미합니다: &quot;hello&quot; :: Title &quot;hello&quot; :: String  위 코드는 모두 유효합니다. type은 때때로 코드 가독성을 높이기 위해 사용합니다. 같은 타입을 다르게 구별할 수 있는 newtype에 비해 type은 덜 유용합니다. "},{"title":"또 다른 문제​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#또-다른-문제","content":" 이전 장에서 작성한 코드를 새로운 타입을 사용하도록 변경해보세요. 팁 이제 makeHtml과 html_를 합치고 body_, head_, title_을 제거할 수 있습니다.html_에서 el을 직접 호출할 수 있으며, 타입은 Title -&gt; Structure -&gt; Html가 됩니다. 이러면 HTML EDSL이 덜 유연하지만 더 간결해집니다. 대안으로, HtmlHead와 HtmlBody라는 newtype을 만들고 html_에 전달할 수 있습니다. 하지만 이번에는 API를 간단하게 유지하기 위해 사용하지 않았고 이후 장에서 다룰 예정입니다. 정답 hello.hs main :: IO () main = putStrLn (render myhtml) myhtml :: Html myhtml = html_ &quot;My title&quot; ( append_ (h1_ &quot;Heading&quot;) ( append_ (p_ &quot;Paragraph #1&quot;) (p_ &quot;Paragraph #2&quot;) ) ) newtype Html = Html String newtype Structure = Structure String type Title = String html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; title) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot; h1_ :: String -&gt; Structure h1_ = Structure . el &quot;h1&quot; el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; append_ :: Structure -&gt; Structure -&gt; Structure append_ c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) getStructureString :: Structure -&gt; String getStructureString content = case content of Structure str -&gt; str render :: Html -&gt; String render html = case html of Html str -&gt; str   "},{"title":"아직 안전하지 않나요?​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#아직-안전하지-않나요","content":"이제 우리는 문단과 제목이 필요한 곳에 &quot;Hello&quot;같은 문자열을 사용할 수 없게 만들었습니다. 하지만 Structure &quot;hello&quot;처럼 제목도 문단도 아닌 값을 사용할 수 있는 문제가 남아있습니다. 사용자의 실수를 방지할 수 있게 노력했지만 아직 원하는만큼 불변성을 강제하지 못했습니다. 다음 장에서는 모듈(modules)과 스마트 생성자(smart constructors)를 사용해 *Structure &quot;hello&quot;와 같은 표현식을 사용할 수 없게 만들어보겠습니다. "},{"title":"Custom markup language","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/markup","content":"Custom markup language In this chapter we will define our own simple markup language and parse documents written in this language into Haskell data structures. Our markup language will contain the following features: Headings: prefix by a number of * charactersParagraphs: a group of lines without empty lines in betweenUnordered lists: a group of lines each prefixed with - Ordered lists: a group of lines each prefixed with # Code blocks: a group of lines each prefixed with &gt; Here's a sample document: * Compiling programs with ghc Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries. Create a new Haskell source file named hello.hs, and write the following code in it: &gt; main = putStrLn &quot;Hello, Haskell!&quot; Now, we can compile the program by invoking ghc with the file name: &gt; ➜ ghc hello.hs &gt; [1 of 1] Compiling Main ( hello.hs, hello.o ) &gt; Linking hello ... GHC created the following files: - hello.hi - Haskell interface file - hello.o - Object file, the output of the compiler before linking - hello (or hello.exe on Microsoft Windows) - A native runnable executable. GHC will produce an executable when the source file satisfies both conditions: # Defines the main function in the source file # Defines the module name to be Main, or does not have a module declaration Otherwise, it will only produce the .o and .hi files. which we will, eventually, convert into this (modulo formatting) HTML: &lt;h1&gt;Compiling programs with ghc&lt;/h1&gt; &lt;p&gt; Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries. &lt;/p&gt; &lt;p&gt; Create a new Haskell source file named hello.hs, and write the following code in it: &lt;/p&gt; &lt;pre&gt; main = putStrLn &quot;Hello, Haskell!&quot; &lt;/pre&gt; &lt;p&gt;Now, we can compile the program by invoking ghc with the file name:&lt;/p&gt; &lt;pre&gt; ➜ ghc hello.hs [1 of 1] Compiling Main ( hello.hs, hello.o ) Linking hello ... &lt;/pre&gt; &lt;p&gt;GHC created the following files:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;hello.hi - Haskell interface file&lt;/li&gt; &lt;li&gt;hello.o - Object file, the output of the compiler before linking&lt;/li&gt; &lt;li&gt; hello (or hello.exe on Microsoft Windows) - A native runnable executable. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt; GHC will produce an executable when the source file satisfies both conditions: &lt;/p&gt; &lt;ol&gt; &lt;li&gt;Defines the main function in the source file&lt;/li&gt; &lt;li&gt; Defines the module name to be Main, or does not have a module declaration &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;Otherwise, it will only produce the .o and .hi files.&lt;/p&gt; ","keywords":""},{"title":"타입 시그니처를 추가하기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/type-signatures","content":"","keywords":""},{"title":"익명/람다 함수​","type":1,"pageTitle":"타입 시그니처를 추가하기","url":"/learn-haskell-blog-generator/html/type-signatures#익명람다-함수","content":"하스켈 함수는 일급이며 모든 함수는 정확히 하나의 인자를 받는다는 점에 나아가, 지금까지 사용한 함수 정의 문법은 단지 문법적 설탕(syntactic sugar)이라는 점을 언급하려 합니다. 우리는 어디에서나 익명 함수 (이름이 없는 함수)를 정의할 수 있습니다. 익명함수는 람다 함수(lambda function) 라고도 불립니다. 이는 가장 원시적인 함수형 프로그래밍 언어인 람다 대수(lambda calculus)의 영향을 받은 것입니다. &quot;hello&quot;와 같은 표현식이 위치할 수 있는 모든곳에 다음과 같은 문법으로 익명 함수를 정의할 수 있습니다. \\&lt;argument&gt; -&gt; &lt;expression&gt;  \\ 기호(그리스 문자 람다 'λ'와 유사한 모양)는 람다 함수의 시작을 나타내며,-&gt; 기호는 함수의 본문의 시작지점을 나타냅니다. 람다 함수를 체인으로 연결하여 &quot;다중 인자 함수&quot;를 만들 수도 있습니다: three = (\\num1 -&gt; \\num2 -&gt; num1 + num2) 1 2  이전과 같이, 함수의 인자를 주어진 값으로 대체하여 함수를 평가합니다. 위의 예제에서 num1을 1로 대체하면 (\\num2 -&gt; 1 + num2) 2가 됩니다. 그리고 num2를 2로 대체하면 1 + 2가 됩니다. 추후에 이에 대해 더 자세히 다루겠습니다. 이제 다음과 같은 함수가 있다면 el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;  하스켈은 실제로 다음과 같이 해석합니다: el :: String -&gt; (String -&gt; String) el = \\tag -&gt; \\content -&gt; &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;  이러한 형태는 하스켈 함수가 왜 항상 하나의 인자만 받는지에 대한 이유를 잘 보여줍니다. 익명 함수에 대한 문법적 설탕을 하나 더 소개하겠습니다: 다중 인자 익명 함수를 정의할 때, 다음과 같이 작성할 수 있습니다: \\&lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; -&gt; &lt;expression&gt;  예를 들면: three = (\\num1 num2 -&gt; num1 + num2) 1 2  하지만 내부적으로 어떻게 작동하는지는 아는것 또한 중요합니다. 지금까지는 익명/람다 함수가 필요하지는 않았지만, 추후에 이를 유용하게 사용할 수 있는 상황을 보게 될 것입니다.  연습문제: 지금까지 만든 모든 함수에 타입을 추가하세요. 지금까지 만든 HTML 함수를 el을 사용하도록 구현하세요. 문단과 제목을 정의하는 몇 가지 함수를 추가하세요: p_는 &lt;p&gt; 태그를 사용하는 문단을 정의합니다.h1_는 &lt;h1&gt; 태그를 사용하는 제목을 정의합니다. Hello, world! 문자열을 더욱 풍부한 내용으로 바꾸고, h1_와 p_를 사용하세요.h1_와 p_로 만든 HTML 문자열을 이어붙이기 위해 &lt;&gt; 연산자를 사용할 수 있습니다.  정답: 연습문제 #1 정답 myhtml :: String myhtml = makeHtml &quot;Hello title&quot; &quot;Hello, world!&quot; makeHtml :: String -&gt; String -&gt; String makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content) html_ :: String -&gt; String html_ content = &quot;&lt;html&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/html&gt;&quot; body_ :: String -&gt; String body_ content = &quot;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&quot; head_ :: String -&gt; String head_ content = &quot;&lt;head&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/head&gt;&quot; title_ :: String -&gt; String title_ content = &quot;&lt;title&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/title&gt;&quot;  연습문제 #2 정답 html_ :: String -&gt; String html_ = el &quot;html&quot; body_ :: String -&gt; String body_ = el &quot;body&quot; head_ :: String -&gt; String head_ = el &quot;head&quot; title_ :: String -&gt; String title_ = el &quot;title&quot;  연습문제 #3 정답 p_ :: String -&gt; String p_ = el &quot;p&quot; h1_ :: String -&gt; String h1_ = el &quot;h1&quot;  연습문제 #4 정답 myhtml :: String myhtml = makeHtml &quot;Hello title&quot; (h1_ &quot;Hello, world!&quot; &lt;&gt; p_ &quot;Let's learn about Haskell!&quot;)   최종 프로그램 hello.hs main :: IO () main = putStrLn myhtml myhtml :: String myhtml = makeHtml &quot;Hello title&quot; (h1_ &quot;Hello, world!&quot; &lt;&gt; p_ &quot;Let's learn about Haskell!&quot;) makeHtml :: String -&gt; String -&gt; String makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content) html_ :: String -&gt; String html_ = el &quot;html&quot; body_ :: String -&gt; String body_ = el &quot;body&quot; head_ :: String -&gt; String head_ = el &quot;head&quot; title_ :: String -&gt; String title_ = el &quot;title&quot; p_ :: String -&gt; String p_ = el &quot;p&quot; h1_ :: String -&gt; String h1_ = el &quot;h1&quot; el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;  "},{"title":"Displaying the parsing results (type classes)","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/markup/displaying-results","content":"","keywords":""},{"title":"Deriving instances​","type":1,"pageTitle":"Displaying the parsing results (type classes)","url":"/learn-haskell-blog-generator/markup/displaying-results#deriving-instances","content":"It is also possible to automatically generate implementations of a few selected type classes. Fortunately, Show is one of them. If all the types in the definition of our data type already implement an instance of Show, we can automatically derive it by adding deriving Show at the end of the data definition. data Structure = Heading Natural String | Paragraph String | UnorderedList [String] | OrderedList [String] | CodeBlock [String] deriving Show  Now we can use the function show :: Show a =&gt; a -&gt; String for any type that implements an instance of the Show type class. For example, with print: print :: Show a =&gt; a -&gt; IO () print = putStrLn . show  We can first convert our type to String and then write it to the standard output. And because lists also implement Show for any element type that has a Show instance, we can now print Documents, because they are just aliases for [Structure]. Try it! There are many type classes Haskellers use everyday. A couple more areEq for equality and Ord for ordering. These are also special type classes that can be derived automatically. "},{"title":"Laws​","type":1,"pageTitle":"Displaying the parsing results (type classes)","url":"/learn-haskell-blog-generator/markup/displaying-results#laws","content":"Type classes often come with &quot;rules&quot; or &quot;laws&quot; that instances should satisfy, the purpose of these laws is to provide predictable behaviour across instances, so that when we run into a new instance we can be confident that it will behave in an expected way, and we can write code that works generically for all instances of a type class while expecting them to adhere to these rules. As an example, let's look at the Semigroup type class: class Semigroup a where (&lt;&gt;) :: a -&gt; a -&gt; a  This type class provides a common interface for types with an operation &lt;&gt;that can combine two values into one in some way. This type class also mentions that this &lt;&gt; operation should be associative, meaning that these two sides should evaluate to the same result: x &lt;&gt; (y &lt;&gt; z) = (x &lt;&gt; y) &lt;&gt; z  An example of a lawful instance of Semigroup is lists with the append operation (++): instance Semigroup [a] where (&lt;&gt;) = (++)  Unfortunately the Haskell type system cannot &quot;prove&quot; that instances satisfy these laws, but as a community we often shun unlawful instances. Many data types (together with their respective operations) can form a Semigroup, and instances don't even have to look similar or have a common analogy/metaphor (and this is true for many other type classes as well). Type classes are often just interfaces with laws (or expected behaviours if you will). Approaching them with this mindset can be very liberating! To put it differently, type classes can be used to create abstractions - interfaces with laws/expected behaviours where we don't actually care about the concrete details of the underlying type, just that it implements a certain API and behaves in a certain way. Regarding Semigroup, we have previouslycreated a function that looks like &lt;&gt; for our Html EDSL! We can add a Semigroup instance for our Structure data type and have a nicer API!  Exercise: Please do this and remove the append_ function from the API. Solution Replace this: append_ :: Structure -&gt; Structure -&gt; Structure append_ c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) With this: instance Semigroup Structure where (&lt;&gt;) c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) And remove the export of append_ in Html.hs. You won't need to further export anything as type class instances are exported automatically. You will also need to replace the usage of append_ with &lt;&gt; in hello.hs.  "},{"title":"Representing the markup language as a Haskell data type","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/markup/data-type","content":"","keywords":""},{"title":"Exercises​","type":1,"pageTitle":"Representing the markup language as a Haskell data type","url":"/learn-haskell-blog-generator/markup/data-type#exercises","content":"Represent the following markup documents as values of Document: Hello, world! * Welcome To this tutorial about Haskell. Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate. # Item 1 of a list # Item 2 of the same list * Compiling programs with ghc Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries. Create a new Haskell source file named hello.hs, and write the following code in it: &gt; main = putStrLn &quot;Hello, Haskell!&quot; Now, we can compile the program by invoking ghc with the file name: &gt; ➜ ghc hello.hs &gt; [1 of 1] Compiling Main ( hello.hs, hello.o ) &gt; Linking hello ... GHC created the following files: - hello.hi - Haskell interface file - hello.o - Object file, the output of the compiler before linking - hello (or hello.exe on Microsoft Windows) - A native runnable executable. GHC will produce an executable when the source file satisfies both conditions: # Defines the main function in the source file # Defines the module name to be Main, or does not have a module declaration Otherwise, it will only produce the .o and .hi files.  Solutions: Solution 1 example1 :: Document example1 = [ Paragraph &quot;Hello, world!&quot; ]  Solution 2 example2 :: Document example2 = [ Heading 1 &quot;Welcome&quot; , Paragraph &quot;To this tutorial about Haskell.&quot; ]  Solution 3 example3 :: Document example3 = [ Paragraph &quot;Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate.&quot; , OrderedList [ &quot;Item 1 of a list&quot; , &quot;Item 2 of the same list&quot; ] ]  Solution 4 example4 :: Document example4 = [ Heading 1 &quot;Compiling programs with ghc&quot; , Paragraph &quot;Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries.&quot; , Paragraph &quot;Create a new Haskell source file named hello.hs, and write the following code in it:&quot; , CodeBlock [ &quot;main = putStrLn \\&quot;Hello, Haskell!\\&quot;&quot; ] , Paragraph &quot;Now, we can compile the program by invoking ghc with the file name:&quot; , CodeBlock [ &quot;➜ ghc hello.hs&quot; , &quot;[1 of 1] Compiling Main ( hello.hs, hello.o )&quot; , &quot;Linking hello ...&quot; ] , Paragraph &quot;GHC created the following files:&quot; , UnorderedList [ &quot;hello.hi - Haskell interface file&quot; , &quot;hello.o - Object file, the output of the compiler before linking&quot; , &quot;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&quot; ] , Paragraph &quot;GHC will produce an executable when the source file satisfies both conditions:&quot; , OrderedList [ &quot;Defines the main function in the source file&quot; , &quot;Defines the module name to be Main, or does not have a module declaration&quot; ] , Paragraph &quot;Otherwise, it will only produce the .o and .hi files.&quot; ]  Add a new module named Markup and add the data type definition to it. Note that in this case we do want to export the constructors of Structure. Solution -- Markup.hs module Markup ( Document , Structure(..) ) where import Numeric.Natural type Document = [Structure] data Structure = Heading Natural String | Paragraph String | UnorderedList [String] | OrderedList [String] | CodeBlock [String]   "},{"title":"Translating directly?​","type":1,"pageTitle":"Representing the markup language as a Haskell data type","url":"/learn-haskell-blog-generator/markup/data-type#translating-directly","content":"You might ask &quot;Why do we even need to represent the markup as a type? Why don't we convert it into HTML as soon as we parse it instead?&quot;. That's a good question and a valid strategy. The reason we first represent it as a Haskell type is for flexibility and modularity. If the parsing code is coupled with HTML generation, we lose the ability to pre-process the markup document. For example we might want to take only a small part of the document (for summary) and present it, or create a table of content from headings. Or maybe we'd like to add other targets and not just HTML - maybe markdown format or a GUI reader? Parsing to an &quot;abstract data type&quot; (ADT) representation (one that does not contain the details of the language, for example '#' for ordered lists) gives us the freedom to do so much more than just conversion to HTML that it's usually worth it in my opinion unless you really need to optimize the process. "},{"title":"Parsing markup part 01 (Recursion)","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/markup/parsing-01","content":"","keywords":""},{"title":"Recursion and accumulating information​","type":1,"pageTitle":"Parsing markup part 01 (Recursion)","url":"/learn-haskell-blog-generator/markup/parsing-01#recursion-and-accumulating-information","content":"Instead of loops, in Haskell we use recursion to model iteration. Consider the following contrived example: let's say that we want to write an algorithm for adding two natural numbers together, and we don't have a standard operation to do that (+), but we do have two operations we could use on each number: incrementand decrement. A solution we could come up with is to slowly &quot;pass&quot; one number to the other number iteratively, by incrementing one, and decrementing the other. And we do that until the number we decrement reaches 0. For example for 3 and 2: We start with 3 and 2, and we increment 3 and decrement 2On the next step we now have 4 and 1, we increment 4 and decrement 1On the next step we now have 5 and 0, since the second number is 0 we declare 5 as the result. This can be written imperatively using a loop: function add(n, m) { while ((m /= 0)) { n = increment(n); m = decrement(m); } return n; }  We can write the same algorithm in Haskell without mutation using recursion: add n m = if m /= 0 then add (increment n) (decrement m) else n  In Haskell, in order to emulate iteration with mutable state, we call the function again with the values we want the variables to have in the next iteration. "},{"title":"Evaluation of recursion​","type":1,"pageTitle":"Parsing markup part 01 (Recursion)","url":"/learn-haskell-blog-generator/markup/parsing-01#evaluation-of-recursion","content":"Recursion commonly has a bad reputation for being slow and possibly unsafe compared to loops. This is because in imperative languages, calling a function often requires creating a new call stack. However, functional languages (and Haskell in particular) play by different rules and implement a feature called tail call elimination - when the result of a function call is the result of the function (this is called tail position), we can just drop the current stack frame and then allocate one for the function we call, so we don't require N stack frames for N iterations. This is of course only one way to do tail call elimination and other strategies exist, such as translating code like our recursive add above to the iteration version. Laziness​ Haskell plays by slightly different rules because it uses a lazy evaluation strategyinstead of the much more common strict evaluation strategy. An evaluation strategyrefers to &quot;when do we evaluate a computation&quot;. In a strict language the answer is simple:we evaluate the arguments of a function before entering a function. So for example the evaluation of add (increment 3) (decrement 2) using strict evaluation will look like this: Evaluate increment 3 to 4Evaluate decrement 2 to 1Evaluate add 4 1 Or, alternatively (depending on the language) we reverse (1) and (2) and evaluate the arguments from right-to-left instead of left-to-right. On the other hand, with lazy evaluation, we only evaluate computation when we need it, which is when it is part of a computation that will have some effect on the outside world, for example when writing a computation to standard output or sending it over the network. So unless this computation is required, it won't be evaluated. For example: main = if add (increment 2) (decrement 3) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot;  In the case above, we need the result of add (increment 2) (decrement 3)in order to know which message to write, so it will be evaluated. But: main = let five = add (increment 2) (decrement 3) in putStrLn &quot;Not required&quot;  In the case above we don't actually need five, so we don't evaluate it! But then if we know we need add (increment 2) (decrement 3), do we use strict evaluation now? The answer is no - because we might not need to evaluate the arguments to complete the computation. For example in this case: const a b = a main = if const (increment 2) (decrement 3) == 3 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot;  const ignores the second argument and returns the first, so we don't actually need to calculate decrement 3 in order to provide an answer to the computation and in turn output an answer to the screen. With the lazy evaluation strategy we will evaluate expressions when we need to (when they are required in order to do something for the user), and we evaluate from the outside in - first we enter functions, and then we evaluate the arguments when we need to (usually when the thing we want to evaluate appears in some control flow such as the condition of an if expression or a pattern in pattern matching).  I've written a more in-depth blog post about how this works in Haskell:Substitution and Equational Reasoning. Please read it and try to evaluate the following program by hand: import Prelude hiding (const) -- feel free to ignore this line increment n = n + 1 decrement n = n - 1 const a b = a add n m = if m /= 0 then add (increment n) (decrement m) else n main = if const (add 3 2) (decrement 3) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot;  Remember that evaluation always begins from main. Solution evaluating main if const (add 3 2) (decrement 3) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; expanding const if add 3 2 == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; expanding add if (if 2 /= 0 then add (increment 3) (decrement 2) else 3) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; evaluating the control flow 2 /= 0 if (if True then add (increment 3) (decrement 2) else 3) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; Choosing the then branch if (add (increment 3) (decrement 2)) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; expanding add if ( if decrement 2 /= 0 then add (increment (increment 3)) (decrement (decrement 2)) else (increment 3) ) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; Evaluating decrement 2 in the control flow (notice how both places change!) if ( if 1 /= 0 then add (increment (increment 3)) (decrement 1) else (increment 3) ) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; Evaluating the control flow 1 /= 0 if ( if True then add (increment (increment 3)) (decrement 1) else (increment 3) ) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; Choosing the then branch if ( add (increment (increment 3)) (decrement 1) ) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; Expanding add if ( if decrement 1 /= 0 then add (increment (increment (increment 3))) (decrement (decrement 1)) else increment (increment 3) ) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; Evaluating control flow decrement 1 if ( if 0 /= 0 then add (increment (increment (increment 3))) (decrement 0) else increment (increment 3) ) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; Evaluating control flow 0 /= 0 if ( if False then add (increment (increment (increment 3))) (decrement 0) else increment (increment 3) ) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; Choosing the else branch if (increment (increment 3)) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; Evaluate control flow increment (increment 3) if (increment 3 + 1) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; Evaluate in control flow increment 3 if (3 + 1 + 1) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; Evaluate in control flow 3 + 1 if (4 + 1) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; Evaluate in control flow 4 + 1 if 5 == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; Evaluate in control flow 5 == 5 if True then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; Choosing the then branch putStrLn &quot;Yes.&quot; Which when run will print Yes. to the screen.  "},{"title":"General recursion​","type":1,"pageTitle":"Parsing markup part 01 (Recursion)","url":"/learn-haskell-blog-generator/markup/parsing-01#general-recursion","content":"In general, when trying to solve problems recursively, it is useful to think about the problem in three parts: Finding the base case (the most simple cases - the ones we already know how to answer)Figuring out how to reduce the problem to something simpler (so it gets closer to the base case)Mitigating the difference between the reduced version and the solution we need to provide The reduce and mitigate steps together are usually called the recursive step. Let's take a look at another example problem: generating a list of a particular size with a specific value in place of every element. In Haskell, this function would have the following signature: replicate :: Int -&gt; a -&gt; [a]  Here are a few usage examples of replicate: ghci&gt; replicate 4 True [True,True,True,True] ghci&gt; replicate 0 True [] ghci&gt; replicate (-13) True []  How would we implement this function recursively? How would describe it in three steps above? Base case: the cases we already know how to generate are the cases where the length of the list is zero (or less) - we just return an empty list.Reduce: while we might not know how to generate a list of size N (where N is positive), if we knew the solution for N-1 we could:Mitigate: Add another element to the solution for N-1 using the : (cons) operator.  Try to write this in Haskell! Solution replicate :: Int -&gt; a -&gt; [a] replicate n x = if n &lt;= 0 -- recognizing the base case then [] -- the solution for the base case else x : replicate (n - 1) x -- --- ------------------- -- ^ ^ -- | | -- | +-------- reduction -- | -- +--- mitigation   "},{"title":"Mutual recursion​","type":1,"pageTitle":"Parsing markup part 01 (Recursion)","url":"/learn-haskell-blog-generator/markup/parsing-01#mutual-recursion","content":"When solving functions recursively we usually call the same function again, but that doesn't have to be the case. It is possible to reduce our problem to something simpler that requires an answer from a different function. If, in turn, that function will (or another function in that call chain) call our function again, we have a mutual recursive solution. For example, let's write two functions, one that checks whether a natural number is even or not, and one that checks whether a number is odd or not only by decrementing it. even :: Int -&gt; Bool odd :: Int -&gt; Bool  Let's start with even, how should we solve this recursively? Base case: We know the answer for 0 - it is True.Reduction: We might not know the answer for a general N, but we could check whether N - 1 is odd,Mitigation: if N - 1 is odd, then N is even! if it isn't odd, then N isn't even. What about odd? Base case: We know the answer for 0 - it is False.Reduction: We might not know the answer for a general N, but we could check whether N - 1 is even,Mitigation: if N - 1 is even, then N is odd! if it isn't even, then N isn't odd.  Try writing this in Haskell! Solution even :: Int -&gt; Bool even n = if n == 0 then True else odd (n - 1) odd :: Int -&gt; Bool odd n = if n == 0 then False else even (n - 1)   "},{"title":"Partial functions​","type":1,"pageTitle":"Parsing markup part 01 (Recursion)","url":"/learn-haskell-blog-generator/markup/parsing-01#partial-functions","content":"Because we didn't handle the negative numbers cases in the example above, our functions will loop forever when a negative value is passed as input. A function that does not return a result for some value (either by not terminating or by throwing an error) is called a partial function(because it only returns a result for a part of the possible inputs). Partial functions are generally considered bad practice because they can have undesired behaviour at runtime (a runtime exception or an infinite loop), so we want to avoid using partial functions as well as avoid writing partial functions. The best way to avoid writing partial functions is by covering all inputs! In the situation above, it is definitely possible to handle negative numbers as well, so we should do that! Or, instead, we could require that our functions accept a Natural instead of an Int, and then the type system would've stopped us from using these functions with values that we did not handle. There are cases where we can't possibly cover all inputs, in these cases it is important to re-examine the code and see if we could further restrict the inputs using types to mitigate these issues. For example, the head :: [a] -&gt; a function from Prelude promises to return the first element (the head) of a list, but we know that lists could possibly be empty, so how can this function deliver on its promise? Unfortunately, it can't. But there exists a different function that can:head :: NonEmpty a -&gt; a from theData.List.NonEmptymodule! The trick here is that this other head does not take a general list as input, it takes a different type entirely, one that promises to have at least one element, and therefore can deliver on its promise! We could also potentially use smart constructors with newtype and enforce some sort of restrictions in the type system, as we saw in earlier chapters, But this solution can sometimes be less ergonomic to use. An alternative approach is to use data types to encode the absence of a proper result, for example, using Maybe, as we'll see in a future chapter. Make sure the functions you write return a result for every input, either by constraining the input using types, or by encoding the absence of a result using types. "},{"title":"Parsing markup?​","type":1,"pageTitle":"Parsing markup part 01 (Recursion)","url":"/learn-haskell-blog-generator/markup/parsing-01#parsing-markup","content":"Let's get back to the task at hand. As stated previously, our strategy for parsing the markup text is: Split the string to a list where each element is a separate line (which we can do with lines), andGo over the list line by line and process it, remembering information from previous lines if necessary Remember that we want to start by ignoring all of the markup syntax and just group lines together into paragraphs (paragraphs are separated by an empty line), and iteratively add new features later in the chapter: parse :: String -&gt; Document parse = parseLines [] . lines -- (1) parseLines :: [String] -&gt; [String] -&gt; Document parseLines currentParagraph txts = let paragraph = Paragraph (unlines (reverse currentParagraph)) -- (2), (3) in case txts of -- (4) [] -&gt; [paragraph] currentLine : rest -&gt; if trim currentLine == &quot;&quot; then paragraph : parseLines [] rest -- (5) else parseLines (currentLine : currentParagraph) rest -- (6) trim :: String -&gt; String trim = unwords . words  Things to note: We pass a list that contains the currently grouped paragraph (paragraphs are separated by an empty line) Because of laziness, paragraph is not computed until it's needed, so we don't have to worry about the performance implications in the case that we are still grouping lines Why do we reverse currentParagraph? (See point (6)) We saw case expressions used to deconstruct newtypes and Chars, but we can also pattern match on lists and other ADTs as well! In this case we match against two patterns, an empty list ([]), and a &quot;cons cell&quot; - a list with at least one element (currentLine : rest). In the body of the &quot;cons&quot; pattern, we bind the first element to the name currentLine, and the rest of the elements to the name rest. We will talk about how all of this works really soon! When we run into an empty line we add the accumulated paragraph to the resulting list (A Document is a list of structures) and start the function again with the rest of the input. We pass the new lines to be grouped in a paragraph in reverse order because of performance characteristics - because of the nature of singly-linked lists, prepending an element is fast, and appending is slow. Prepending only requires us to create a new cons (:) cell to hold a pointer to the value and a pointer to the list, but appending requires us to traverse the list to its end and rebuild the cons cells - the last one will contain the last value of the list and a pointer to the list to append, the next will contain the value before the last value of the list and a pointer to the list which contains the last element and the appended list, and so on. This code above will group together paragraphs in a structure, but how do we view our result? In the next chapter we will take a short detour and talk about type classes, and how they can help us in this scenario. "},{"title":"Parsing markup part 02 (Pattern matching)","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/markup/parsing-02","content":"","keywords":""},{"title":"Maybe​","type":1,"pageTitle":"Parsing markup part 02 (Pattern matching)","url":"/learn-haskell-blog-generator/markup/parsing-02#maybe","content":"Previously on partial functions, we mentioned that one way to avoid writing partial functions is to encode the absence of a result using Maybe: data Maybe a = Nothing | Just a  Maybe is a data type from the standard library (named base) for adding an additional value to a type: the absence of a value. For example, Maybe Bool has three values, two with the Just constructor to represent regular boolean values (Just True and Just False) and another value, Nothing to represent the absence of a boolean value. We can use this to encode the result of head, a function that promises to return the first element of a list, without creating a partial function: safeHead :: [a] -&gt; Maybe a  This way, when the list is empty, we can return Nothing, and when it has at least one element, we can return Just &lt;first element&gt;. This function can be found in the Data.Maybemodule under the namelistToMaybe. In order to consume values of type Maybe &lt;something&gt;, and other types created withdata, we can use pattern matching. "},{"title":"Pattern Matching​","type":1,"pageTitle":"Parsing markup part 02 (Pattern matching)","url":"/learn-haskell-blog-generator/markup/parsing-02#pattern-matching","content":"We've already seen pattern matching a few times. It is an incredibly versatile feature of Haskell, we can use it to do two main things: Deconstruct complex valuesControl flow As we've seen when discussingnewtypes, we can use case expressions and function definitions to deconstruct a newtype. Same for data types as well: -- | A data type representing colors data Color = RGB Word8 Word8 Word8 getBluePart :: Color -&gt; Word8 getBluePart color = case color of RGB _ _ blue -&gt; blue  In getBluePart we deconstruct a composite value into its part and extract the third component representing the blue value in a color represented by red, green and blue components (RGB). Note that blue is the name we give to the third component so it will be bound to the right of the arrow that comes after the pattern. This is similar to a function argument. Also note that _ matches any value without binding it to a name. We can also try to match a value with more than one pattern: data Brightness = Dark | Bright data EightColor = Black | Red | Green | Yellow | Blue | Magenta | Cyan | White data AnsiColor = AnsiColor Brightness EightColor ansiColorToVGA :: AnsiColor -&gt; Color ansiColorToVGA ansicolor = case ansicolor of AnsiColor Dark Black -&gt; RGB 0 0 0 AnsiColor Bright Black -&gt; RGB 85 85 85 AnsiColor Dark Red -&gt; RGB 170 0 0 AnsiColor Bright Red -&gt; RGB 255 85 85 -- and so on  It's important to notice a few things here: Patterns can be nested, notice how we deconstructed ansicolor on multiple levelsWe try to match patterns from the top down, it is possible for patterns to overlap with one another and the top one will winIf the value we try to match does not match any of the patterns listed, an error will be thrown at runtime We can ask GHC to notify us when we accidentally write overlapping patterns, or when we haven't listed enough patterns to match all possible values, by passing the flag -Wall to ghc or runghc. My recommendation is to always use -Wall! As an aside, while it is possible to use pattern matching in function definitions by defining a function multiple times, I personally don't like that feature very muchand I would encourage you to avoid it, but if you want to use it instead of case expressions, it is possible. "},{"title":"Pattern matching on linked lists​","type":1,"pageTitle":"Parsing markup part 02 (Pattern matching)","url":"/learn-haskell-blog-generator/markup/parsing-02#pattern-matching-on-linked-lists","content":"Because linked lists have their own special syntax, we also have special syntax for their pattern match. We can use the same special syntax for creating lists when we pattern match on lists, replacing the elements of the list with patterns. For example: safeHead :: [a] -&gt; Maybe a safeHead list = case list of -- Empty list [] -&gt; Nothing -- Cons cell pattern, will match any list with at least one element x : _ -&gt; Just x  exactlyTwo :: [a] -&gt; Maybe (a, a) exactlyTwo list = case list of -- Will match a list with exactly two elements [x, y] -&gt; Just (x, y) -- Will match any other pattern _ -&gt; Nothing  -- This will also work exactlyTwoVersion2 :: [a] -&gt; Maybe (a, a) exactlyTwoVersion2 list = case list of -- Will match a list with exactly two elements x : y : [] -&gt; Just (x, y) -- Will match any other pattern _ -&gt; Nothing   Exercises: Create a function isBright :: AnsiColor -&gt; Bool that checks whether a color is brightUse this table to write ansiToUbuntuCreate a function isEmpty :: [a] -&gt; Bool that uses listToMaybe to check whether a list is emptyCreate a function isEmpty :: [a] -&gt; Bool that doesn't use listToMaybe to check whether a list is empty Solutions: Solution for (1) isBright :: AnsiColor -&gt; Bool isBright ansiColor = case ansiColor of AnsiColor Bright _ -&gt; True AnsiColor Dark _ -&gt; False  Solution for (2) ansiToUbuntu :: AnsiColor -&gt; Color ansiToUbuntu ansiColor = case ansiColor of AnsiColor brightness color -&gt; case brightness of Dark -&gt; case color of Black -&gt; RGB 0 0 0 Red -&gt; RGB 194 54 33 Green -&gt; RGB 37 188 36 Yellow -&gt; RGB 173 173 39 Blue -&gt; RGB 73 46 225 Magenta -&gt; RGB 211 56 211 Cyan -&gt; RGB 51 187 200 White -&gt; RGB 203 204 205 Bright -&gt; case color of Black -&gt; RGB 129 131 131 Red -&gt; RGB 252 57 31 Green -&gt; RGB 49 231 34 Yellow -&gt; RGB 234 236 35 Blue -&gt; RGB 88 51 255 Magenta -&gt; RGB 249 53 248 Cyan -&gt; RGB 20 240 240 White -&gt; RGB 233 235 235 Since pattern matching goes arbitrarily deep as we saw before, we could instead pattern match all the way through in one case expression: ansiToUbuntu :: AnsiColor -&gt; Color ansiToUbuntu ansiColor = case ansiColor of AnsiColor Dark Black -&gt; RGB 0 0 0 AnsiColor Dark Red -&gt; RGB 194 54 33 AnsiColor Dark Green -&gt; RGB 37 188 36 AnsiColor Dark Yellow -&gt; RGB 173 173 39 AnsiColor Dark Blue -&gt; RGB 73 46 225 AnsiColor Dark Magenta -&gt; RGB 211 56 211 AnsiColor Dark Cyan -&gt; RGB 51 187 200 AnsiColor Dark White -&gt; RGB 203 204 205 AnsiColor Bright Black -&gt; RGB 129 131 131 AnsiColor Bright Red -&gt; RGB 252 57 31 AnsiColor Bright Green -&gt; RGB 49 231 34 AnsiColor Bright Yellow -&gt; RGB 234 236 35 AnsiColor Bright Blue -&gt; RGB 88 51 255 AnsiColor Bright Magenta -&gt; RGB 249 53 248 AnsiColor Bright Cyan -&gt; RGB 20 240 240 AnsiColor Bright White -&gt; RGB 233 235 235 But this is a bit too much repetition of AnsiColor, Dark and Brightto my taste in this case. Solution for (3) isEmpty :: [a] -&gt; Bool isEmpty list = case listToMaybe list of Nothing -&gt; True Just _ -&gt; False  Solution for (4) isEmpty :: [a] -&gt; Bool isEmpty list = case list of [] -&gt; True _ : _ -&gt; False   "},{"title":"Parsing with rich context​","type":1,"pageTitle":"Parsing markup part 02 (Pattern matching)","url":"/learn-haskell-blog-generator/markup/parsing-02#parsing-with-rich-context","content":"Previously we wrote a parser that separates documents into different paragraphs. With new features under our belt we can now remember the exact context we are in (whether it is a text paragraph, a list, or a code block) and act accordingly! Let's look again at the parsing code we wrote previously: parse :: String -&gt; Document parse = parseLines [] . lines parseLines :: [String] -&gt; [String] -&gt; Document parseLines currentParagraph txts = let paragraph = Paragraph (unlines (reverse currentParagraph)) in case txts of [] -&gt; [paragraph] currentLine : rest -&gt; if trim currentLine == &quot;&quot; then paragraph : parseLines [] rest else parseLines (currentLine : currentParagraph) rest trim :: String -&gt; String trim = unwords . words  Previously our context, currentParagraph, was used to group adjacent lines in an accumulative list. Next, instead of using a [String] type to denote adjacent lines, we can instead use a Structure to denote the context. One issue we might have though with representing context with the Structure type, is that when we start parsing we don't have any context. But we have learned of a way to represent the absence of a value with Maybe! So our new context type can be Maybe Structure instead. Let's rewrite our code above with our new context type: parse :: String -&gt; Document parse = parseLines Nothing . lines -- (1) parseLines :: Maybe Structure -&gt; [String] -&gt; Document parseLines context txts = case txts of [] -&gt; maybeToList context -- (2) -- Paragraph case currentLine : rest -&gt; let line = trim currentLine in if line == &quot;&quot; then maybe id (:) context (parseLines Nothing rest) -- (3) else case context of Just (Paragraph paragraph) -&gt; parseLines (Just (Paragraph (unwords [paragraph, line]))) rest -- (4) _ -&gt; maybe id (:) context (parseLines (Just (Paragraph line)) rest) trim :: String -&gt; String trim = unwords . words  We can now pass Nothing when we don't have a context Unsure what maybeToList does? Hoogle it! We can split this line into two important parts: maybe id (:) context - prepending the context to the rest of the documentparseLines Nothing rest - parsing the rest of the document Let's focus on the first part. We want to prepend context to the rest of the document, but we can't writecontext : parseLines Nothing rest because context has the type Maybe Structureand not Structure, meaning that we might have a Structure but maybe not. If we do have a Structure to prepend, we wish to prepend it. If not, we want to return the result of parseLines Nothing rest as is. Try writing this using pattern matching! Solution case context of Nothing -&gt; parseLines Nothing rest Just structure -&gt; structure : parseLines Nothing rest The maybefunction let's us do the same thing in a more compact way. It is a function that works similarly to pattern matching on a Maybe: the third argument to maybe is the value on which we pattern match, the second argument is a function to apply to the value found in a Just case, and the first argument is the value to return in case the value we pattern match on is Nothing. A more faithful translation ofmaybe id (:) context (parseLines Nothing rest)to pattern matching would look like this: Solution ( case context of Nothing -&gt; id Just structure -&gt; (:) structure ) (parseLines Nothing rest) Note how the result of this case expression is a function of type Document -&gt; Document, how we partially apply (:) with structure to create a function that prepends structure, and how we apply parseLines Nothing rest to the case expression. This way of encoding pattern matching using functions is fairly common. Check out the types of id, (:) and maybe id (:) in GHCi! Hey! Didn't we say that appending Strings/lists is slow (which is what unwords does)? Yes, it is. Because in our Structure data type, a paragraph is defined as Paragraph String and not Paragraph [String], we can't use our trick of building a list of lines and then reverse it in the end. So what do we do? There are many ways to handle that, one simple way is to create a different type with the right shape: data Context = CtxHeading Natural String | CtxParagraph [String] | CtxUnorderedList [String] | CtxOrderedList [String] | CtxCodeBlock [String] Since creating new types in Haskell is cheap, this is a very viable solution. In this case I'm going with the approach of not worrying about it too much, because it's a very local piece of code that can easily be fixed later if needed. Let's cover more parsing cases, we want to handle headings and lists as well. We can do that by examining the first characters of a line: parse :: String -&gt; Document parse = parseLines Nothing . lines parseLines :: Maybe Structure -&gt; [String] -&gt; Document parseLines context txts = case txts of -- done case [] -&gt; maybeToList context -- Heading 1 case ('*' : ' ' : line) : rest -&gt; maybe id (:) context (Heading 1 (trim line) : parseLines Nothing rest) -- Unordered list case ('-' : ' ' : line) : rest -&gt; case context of Just (UnorderedList list) -&gt; parseLines (Just (UnorderedList (list &lt;&gt; [trim line]))) rest _ -&gt; maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest) -- Paragraph case currentLine : rest -&gt; let line = trim currentLine in if line == &quot;&quot; then maybe id (:) context (parseLines Nothing rest) else case context of Just (Paragraph paragraph) -&gt; parseLines (Just (Paragraph (unwords [paragraph, line]))) rest _ -&gt; maybe id (:) context (parseLines (Just (Paragraph line)) rest) trim :: String -&gt; String trim = unwords . words   Exercise: Add the CodeBlock and OrderedList cases. Final module -- Markup.hs module Markup ( Document , Structure(..) , parse ) where import Numeric.Natural import Data.Maybe (maybeToList) type Document = [Structure] data Structure = Heading Natural String | Paragraph String | UnorderedList [String] | OrderedList [String] | CodeBlock [String] deriving (Eq, Show) -- (1) parse :: String -&gt; Document parse = parseLines Nothing . lines parseLines :: Maybe Structure -&gt; [String] -&gt; Document parseLines context txts = case txts of -- done case [] -&gt; maybeToList context -- Heading 1 case ('*' : ' ' : line) : rest -&gt; maybe id (:) context (Heading 1 (trim line) : parseLines Nothing rest) -- Unordered list case ('-' : ' ' : line) : rest -&gt; case context of Just (UnorderedList list) -&gt; parseLines (Just (UnorderedList (list &lt;&gt; [trim line]))) rest _ -&gt; maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest) -- Ordered list case ('#' : ' ' : line) : rest -&gt; case context of Just (OrderedList list) -&gt; parseLines (Just (OrderedList (list &lt;&gt; [trim line]))) rest _ -&gt; maybe id (:) context (parseLines (Just (OrderedList [trim line])) rest) -- Code block case ('&gt;' : ' ' : line) : rest -&gt; case context of Just (CodeBlock code) -&gt; parseLines (Just (CodeBlock (code &lt;&gt; [line]))) rest _ -&gt; maybe id (:) context (parseLines (Just (CodeBlock [line])) rest) -- Paragraph case currentLine : rest -&gt; let line = trim currentLine in if line == &quot;&quot; then maybe id (:) context (parseLines Nothing rest) else case context of Just (Paragraph paragraph) -&gt; parseLines (Just (Paragraph (unwords [paragraph, line]))) rest _ -&gt; maybe id (:) context (parseLines (Just (Paragraph line)) rest) trim :: String -&gt; String trim = unwords . words   "},{"title":"How do we know our parser works correctly?​","type":1,"pageTitle":"Parsing markup part 02 (Pattern matching)","url":"/learn-haskell-blog-generator/markup/parsing-02#how-do-we-know-our-parser-works-correctly","content":"In an earlier chapter, we parsed a few examples of our markup language by hand. Now, we can try to test our parser by comparing our solutions to our parser. By deriving Eq for our Structure data type (marked with (1) in &quot;final module&quot; above), we can compare solutions with the == (equals) operator. Try it in GHCi! You can read a text file in GHCi using the following syntax: ghci&gt; txt &lt;- readFile &quot;/tmp/sample.txt&quot;  And then compare with the hand written example values from the solutions (after adding them to the module and loading them in GHCi): ghci&gt; parse txt == example4  In a later chapter, we'll write automated tests for our parser using a testing framework. But before that, I'd like to glue things together so we'll be able to: Read markup text from a fileParse the textConvert the result to our HTML EDSLGenerate HTML code And also discuss how to work with IO in Haskell while we're at it. You can view the git commit ofthe changes we've madeand the code up until now. "},{"title":"Where to go next","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/next","content":"","keywords":""},{"title":"Extending this project​","type":1,"pageTitle":"Where to go next","url":"/learn-haskell-blog-generator/next#extending-this-project","content":"If you'd like to extend this project, here are a few ideas for you: Serve over HTTP - You can use a web library such aswai ortwainto serve this blog over HTTP instead of generating it staticallyRewrite it with libraries - you could rewrite it and use a real-worldHTML packageand markdown parserAdd features You could add a metadata block at the top of each article which would include the title, publish date and tags of a blog post, and use them when generating HTML, index page and even tags pagesYou could add HTML pages templating usingmustache or similar, and use that to generate a nice and customizable structure to the pageYou could add support for links and images in our markup language parserYou could add support for configuration files which would include things like the blog title, description, or other meta information for things liketwitter cards Or anything else you can think of, consider this project your playground and do whatever you like with it! "},{"title":"Other resources​","type":1,"pageTitle":"Where to go next","url":"/learn-haskell-blog-generator/next#other-resources","content":"At some point you are likely to run into new concepts, techniques, or even just a feeling of &quot;I feel like this could be done better&quot;. I'd like to point you in the right direction so you can find additional information and learn new Haskell things when you need to or want to. I've compiled a list of resources for learning Haskell calledHaskell study plan, which includes links to very useful articles, community hubs and news aggregators, project suggestions, and even cool open-source Haskell projects. You will also find alternative explanations to thing we've covered and even links to other Haskell tutorials, guides and books in case you need a different view on things. Also, the GHC User Guideis a fantastic resource with loads of articles and information about the language and GHC tooling around it. It is often the best place to learn about the Haskell language. However, don't feel pressured to learn everything Haskell has to offer right away. Mastering Haskell is a journey that can take a lot of time. Most of us are definitely not there yet, but we can still be very productive with Haskell, build real-world projects, and even discover new techniques and concepts ourselves. Remember that in a lazy language we evaluate things only when we need them. Maybe we can do that too with Haskell concepts! "},{"title":"Recap","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/recap","content":"","keywords":""},{"title":"Thank you!​","type":1,"pageTitle":"Recap","url":"/learn-haskell-blog-generator/recap#thank-you","content":"Thank you for reading this book. I hope you enjoyed it and found Haskell interesting. I would very much like to hear your feedback. If you'd like, you could leave your feedback at this book'sGitHub issue board, or you could reach me directly on mastodon or via email. You can find my contact information on my website. If you liked this book, do let me know - your kind words mean a lot. Finally, if you really liked this book and would like to support future passion projects like it, you can support me directly via Ko-fi. Thank you and good luck with your next Haskell project! "},{"title":"Testing","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/testing","content":"","keywords":""},{"title":"Initial setup​","type":1,"pageTitle":"Testing","url":"/learn-haskell-blog-generator/testing#initial-setup","content":""},{"title":"Cabal file additions​","type":1,"pageTitle":"Testing","url":"/learn-haskell-blog-generator/testing#cabal-file-additions","content":"We're going to define a new section in our hs-blog-gen.cabal file for our new test suite. This section is called test-suite and it is fairly similar to the library andexecutable sections. The interfaces for how to define a test suite are described in theCabal documentation. We are going to use the exitcode-stdio-1.0 interface. Let's go over the different settings and options: test-suite hs-blog-gen-test import: common-settings type: exitcode-stdio-1.0 hs-source-dirs: test main-is: Spec.hs -- other-modules: build-depends: base , hspec , hspec-discover , raw-strings-qq , hs-blog ghc-options: -O -threaded -rtsopts -with-rtsopts=-N build-tool-depends: hspec-discover:hspec-discover  hs-source-dirs: test - The directory of the source files for the test suitemain-is: Spec.hs - The entry point to the test suiteother-modules - The modules in our test suite. Currently commented out because we haven't added any yetbuild-depends - The packages we are going to use: base - The standard library for Haskell, as we've used beforehspec - The test framework we are going to usehspec-discover - Automatic discovery of Hspec testsraw-strings-qq - Additional syntax for writing raw string literalshs-blog - Our library ghc-options - Extra options and flags for GHC: -O - Compile with optimizations-threaded - Use the multi-core runtime instead of single-core runtime. The multi-core runtime is generally a bit slower in my experience, but when writing code that actually uses multiple cores (such as a test framework that runs tests in parallel) it can give a good performance boost-rtsopts - Let us configure the Haskell runtime system by passing command-line arguments to our application-with-rtsopts=-N - Set specific default options for the program at link-time. Specifically, -NSets the number of cores to use in our program build-tool-depends - Use a specific executable from a package dependency in aid of building the package. In this case, we are using the hspec-discover executable from thehspec-discover package, which goes over the source directory for the tests, finds all of the Spec files, and creates an entry point for the program that will run all the tests it discovered "},{"title":"Hspec discovery​","type":1,"pageTitle":"Testing","url":"/learn-haskell-blog-generator/testing#hspec-discovery","content":"In order for hspec-discover to work, we need to add the following to the &quot;main&quot; file of the test suite, for us this is test/Spec.hs: {-# OPTIONS_GHC -F -pgmF hspec-discover #-}  That's it! hspec-discover will automatically define a main for us. Now we can run the tests using stack test or cabal test (your choice). Because we haven't defined any tests, our output is: Finished in 0.0000 seconds 0 examples, 0 failures  When we add new Hspec tests, hspec-discover will find and run them automatically (though we will still need add them to the other-modules section in the cabal file). For hspec-discover to identify modules as test modules, the modules must follow a convention: Their module names must end with SpecThey must define a value spec :: Spec (which describes the test) and export it outside of the module (by adding it to the export list of the module, for example) "},{"title":"Writing tests​","type":1,"pageTitle":"Testing","url":"/learn-haskell-blog-generator/testing#writing-tests","content":"Let's write our first test. We'll create a new module to test markup parsing. We'll call it MarkupParsingSpec.hs. We'll need the following imports as well: module MarkupParsingSpec where import Test.Hspec import HsBlog.Markup  Hspec provides us with a monadic interface for describing, composing and nesting test specifications (Specs). Using the describe function we can describe a group of tests, using the it function we can add a new test, and using a function like shouldBe we can compare two values and make sure they are equal by using their Eq instance. If they are, the test will pass, and if not, it will fail with a descriptive error. Let's try it and write a test that obviously fails! spec :: Spec spec = do describe &quot;Markup parsing tests&quot; $ do it &quot;empty&quot; $ shouldBe (parse &quot;&quot;) [Heading 1 &quot;bug&quot;]  After adding the module to the other-modules list in the cabal file:  other-modules: MarkupParsingSpec  And running the tests, we get this output: MarkupParsing Markup parsing tests empty FAILED [1] Failures: test/MarkupParsingSpec.hs:10:7: 1) MarkupParsing, Markup parsing tests, empty expected: [Heading 1 &quot;bug&quot;] but got: [] To rerun use: --match &quot;/MarkupParsing/Markup parsing tests/empty/&quot; Randomized with seed 763489823 Finished in 0.0004 seconds 1 example, 1 failure  The output describes which tests are running in a hierarchy tree (module, group and test), whether the tests pass or fail, and if they fail, the output and the expected output. We can fix our test by matching the expected output:  shouldBe (parse &quot;&quot;) []  Now, running the tests will produce: MarkupParsing Markup parsing tests empty Finished in 0.0001 seconds 1 example, 0 failures  We can add a few more tests:  it &quot;paragraph&quot; $ shouldBe (parse &quot;hello world&quot;) [Paragraph &quot;hello world&quot;] it &quot;heading 1&quot; $ shouldBe (parse &quot;* Heading 1&quot;) [Heading 1 &quot;Heading 1&quot;] it &quot;code&quot; $ shouldBe (parse &quot;&gt; main = putStrLn \\&quot;hello world!\\&quot;&quot;) [CodeBlock [&quot;main = putStrLn \\&quot;hello world!\\&quot;&quot;]]  And run the tests again: MarkupParsing Markup parsing tests Test empty paragraph heading 1 code Finished in 0.0003 seconds 4 examples, 0 failures  This is the gist of writing unit tests with Hspec. It's important to note that we can nest Specs that are declared with describe to create trees, and of course refactor and move things to different functions and modules to make our test suite better organized. For example, we can write our tests like this: spec :: Spec spec = do describe &quot;Markup parsing tests&quot; $ do simple simple :: Spec simple = do describe &quot;simple&quot; $ do it &quot;empty&quot; $ shouldBe (parse &quot;&quot;) [] it &quot;paragraph&quot; $ shouldBe (parse &quot;hello world&quot;) [Paragraph &quot;hello world&quot;] it &quot;heading 1&quot; $ shouldBe (parse &quot;* Heading 1&quot;) [Heading 1 &quot;Heading 1&quot;] it &quot;code&quot; $ shouldBe (parse &quot;&gt; main = putStrLn \\&quot;hello world!\\&quot;&quot;) [CodeBlock [&quot;main = putStrLn \\&quot;hello world!\\&quot;&quot;]]  Also, there are other &quot;expectations&quot; like shouldBe that we can use when writing tests. They are described in the Hspec tutorialand can be found in thehaddock documentation as well. "},{"title":"Raw strings​","type":1,"pageTitle":"Testing","url":"/learn-haskell-blog-generator/testing#raw-strings","content":"If we want to write multi-line strings, or avoid escaping strings like we did in the &quot;code&quot; test, we can use a library calledraw-strings-qqwhich uses a language extension calledQuasiQuotes.QuasiQuotes is a meta-programming extension that provides a mechanism for extending the syntax of Haskell. A quasi-quote has the form [quoter| string |], where the quoter is the name of the function providing the syntax we wish to use, and the string is our input. In our case, we use the quoter r, which is defined inraw-strings-qq, and write any string we want, with multi-lines and unescaped characters! We could use this to write the testswe previously wrote: {-# language QuasiQuotes #-} ... import Text.RawString.QQ ... example3 :: String example3 = [r| Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate. # Item 1 of a list # Item 2 of the same list |]  And add multi-line tests: spec :: Spec spec = do describe &quot;Markup parsing tests&quot; $ do simple multiline multiline :: Spec multiline = do describe &quot;Multi-line tests&quot; $ do it &quot;example3&quot; $ shouldBe (parse example3) example3Result example3 :: String example3 = [r| Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate. # Item 1 of a list # Item 2 of the same list |] example3Result :: Document example3Result = [ Paragraph &quot;Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate.&quot; , OrderedList [ &quot;Item 1 of a list&quot; , &quot;Item 2 of the same list&quot; ] ]  Running the tests: MarkupParsing Markup parsing tests simple Test empty paragraph heading 1 code Multi-line tests example3 Finished in 0.0004 seconds 5 examples, 0 failures   Exercise: Add a test for the fourth example described in theprevious exercises. Solution multiline :: Spec multiline = do describe &quot;Multi-line tests&quot; $ do it &quot;example3&quot; $ shouldBe (parse example3) example3Result it &quot;example4&quot; $ shouldBe (parse example4) example4Result example4 :: String example4 = [r| * Compiling programs with ghc Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries. Create a new Haskell source file named hello.hs, and write the following code in it: &gt; main = putStrLn &quot;Hello, Haskell!&quot; Now, we can compile the program by invoking ghc with the file name: &gt; ➜ ghc hello.hs &gt; [1 of 1] Compiling Main ( hello.hs, hello.o ) &gt; Linking hello ... GHC created the following files: - hello.hi - Haskell interface file - hello.o - Object file, the output of the compiler before linking - hello (or hello.exe on Microsoft Windows) - A native runnable executable. GHC will produce an executable when the source file satisfies both conditions: # Defines the main function in the source file # Defines the module name to be Main, or does not have a module declaration Otherwise, it will only produce the .o and .hi files. |] example4Result :: Document example4Result = [ Heading 1 &quot;Compiling programs with ghc&quot; , Paragraph &quot;Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries.&quot; , Paragraph &quot;Create a new Haskell source file named hello.hs, and write the following code in it:&quot; , CodeBlock [ &quot;main = putStrLn \\&quot;Hello, Haskell!\\&quot;&quot; ] , Paragraph &quot;Now, we can compile the program by invoking ghc with the file name:&quot; , CodeBlock [ &quot;➜ ghc hello.hs&quot; , &quot;[1 of 1] Compiling Main ( hello.hs, hello.o )&quot; , &quot;Linking hello ...&quot; ] , Paragraph &quot;GHC created the following files:&quot; , UnorderedList [ &quot;hello.hi - Haskell interface file&quot; , &quot;hello.o - Object file, the output of the compiler before linking&quot; , &quot;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&quot; ] , Paragraph &quot;GHC will produce an executable when the source file satisfies both conditions:&quot; , OrderedList [ &quot;Defines the main function in the source file&quot; , &quot;Defines the module name to be Main, or does not have a module declaration&quot; ] , Paragraph &quot;Otherwise, it will only produce the .o and .hi files.&quot; ]   "},{"title":"Parallel test execution​","type":1,"pageTitle":"Testing","url":"/learn-haskell-blog-generator/testing#parallel-test-execution","content":"Without further configuration, Hspec will run all of our tests on the main thread, sequentially. There are a couple of ways to configure tests to run in parallel. One is to manually mark a Specas parallel by passing it to the parallel function, and another is by creating a /hook/ that will applyparallel to each Spec automatically withhspec-discover. Consult the Hspec manualon this topic and try both methods. Remember that we already enabled the threaded runtime and set it to use multiple cores in the cabal file. "},{"title":"Summary​","type":1,"pageTitle":"Testing","url":"/learn-haskell-blog-generator/testing#summary","content":"This chapter has been just the tip of the iceberg of the Haskell testing landscape. We haven't talked aboutproperty testing orgolden testing, testing expected failures, testing IO code, inspection testing, benchmarking, and more. There's just too much to cover! My hope is that this chapter provided you with the basics of how to start writing tests for your own projects. Please consult the tutorial for your chosen testing framework, and read more about this very important subject on your own. You can view the git commit ofthe changes we've madeand the code up until now. "}]