[{"title":"문서 생성하기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/documentation","content":"","keywords":"","version":"Next"},{"title":"Haddock 실행하기​","type":1,"pageTitle":"문서 생성하기","url":"/learn-haskell-blog-generator/documentation#haddock-실행하기","content":"선호하는 패키지 관리자를 사용하여 (Haskell 세계에서는 haddock로 알려진) 프로젝트의 API 문서 를 생성할 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"Cabal​","type":1,"pageTitle":"문서 생성하기","url":"/learn-haskell-blog-generator/documentation#cabal","content":"cabal haddock을 실행하여 haddock을 생성할 수 있습니다. ➜ cabal haddock Resolving dependencies... Build profile: -w ghc-9.0.1 -O1 In order, the following will be built (use -v for more details): - hs-blog-0.1.0.0 (lib) (first run) Configuring library for hs-blog-0.1.0.0.. Preprocessing library for hs-blog-0.1.0.0.. Running Haddock on library for hs-blog-0.1.0.0.. Haddock coverage: 0% ( 0 / 3) in 'HsBlog.Env' Missing documentation for: Module header Env (src/HsBlog/Env.hs:3) defaultEnv (src/HsBlog/Env.hs:10) 21% ( 7 / 33) in 'HsBlog.Html.Internal' Missing documentation for: Module header Html (src/HsBlog/Html/Internal.hs:8) ... Documentation created: /tmp/learn-haskell-blog-generator/dist-newstyle/build/x86_64-linux/ghc-9.0.1/hs-blog-0.1.0.0/doc/html/hs-blog/index.html  Cabal과 Haddock은 프로젝트를 빌드하고 HTML 페이지를 생성합니다. ./dist-newstyle/build/&lt;platform &gt;/&lt;compiler &gt;/&lt;package &gt;-&lt;version&gt;/doc/html/&lt;package&gt;/&lt;/package&gt;&lt;/version&gt;&lt;/package &gt;&lt;/compiler &gt;&lt;/platform &gt;  이후 웹 브라우저에서 해당 디렉토리의 index.html 파일을 열어 패키지 문서를 볼 수 있습니다. ","version":"Next","tagName":"h3"},{"title":"Stack​","type":1,"pageTitle":"문서 생성하기","url":"/learn-haskell-blog-generator/documentation#stack","content":"stack haddock을 실행하여 haddock을 생성할 수 있습니다. ➜ stack haddock ... hs-blog&gt; build (lib + exe) Preprocessing library for hs-blog-0.1.0.0.. Building library for hs-blog-0.1.0.0.. [1 of 7] Compiling HsBlog.Env [2 of 7] Compiling HsBlog.Html.Internal ... hs-blog&gt; haddock Preprocessing library for hs-blog-0.1.0.0.. Running Haddock on library for hs-blog-0.1.0.0.. Haddock coverage: 0% ( 0 / 3) in 'HsBlog.Env' Missing documentation for: Module header Env (src/HsBlog/Env.hs:3) defaultEnv (src/HsBlog/Env.hs:10) 21% ( 7 / 33) in 'HsBlog.Html.Internal' Missing documentation for: Module header Html (src/HsBlog/Html/Internal.hs:8) ... Documentation created: .stack-work/dist/x86_64-linux-tinfo6/Cabal-3.2.1.0/doc/html/hs-blog/index.html, .stack-work/dist/x86_64-linux-tinfo6/Cabal-3.2.1.0/doc/html/hs-blog/hs-blog.txt Preprocessing executable 'hs-blog-gen' for hs-blog-0.1.0.0.. ...  Stack과 Haddock은 프로젝트를 빌드하고 HTML 페이지를 생성합니다. ./.stack-work/dist/&lt;platform &gt;/Cabal-&lt;version&gt;/doc/html/&lt;package&gt;/&lt;/package&gt;&lt;/version&gt;&lt;/platform &gt;  이후 웹 브라우저에서 해당 디렉토리의 index.html 파일을 열어 패키지 문서를 볼 수 있습니다. ","version":"Next","tagName":"h3"},{"title":"Haddock 커버리지​","type":1,"pageTitle":"문서 생성하기","url":"/learn-haskell-blog-generator/documentation#haddock-커버리지","content":"Haddock은 실행하면 커버리지 보고서를 출력하고 사용자에게 공개되었지만 문서가 없는 항목들을 보여줍니다. 이러한 항목들은 모듈 헤더, 타입, 데이터 생성자, 타입 클래스, 함수, 값 등이 될 수 있습니다. 예를 들어: Haddock coverage: ... 0% ( 0 / 3) in 'HsBlog.Convert' Missing documentation for: Module header convert (src/HsBlog/Convert.hs:8) convertStructure (src/HsBlog/Convert.hs:23) 67% ( 2 / 3) in 'HsBlog.Directory' Missing documentation for: buildIndex (src/HsBlog/Directory.hs:80) ...  우리는 HsBlog.Convert를 전혀 문서화하지 않았고, 모듈 헤더, convert 함수, convertStructure 함수에 대한 문서가 없다는 사실을 알 수 있습니다. 반면에 HsBlog.Directory 모듈에는 일부 문서가 있다는 것을 알 수 있습니다! 왜 그런지는 이후에 다루겠습니다. 그전에 우선 haddock을 생성해보고 모듈 계층 구조를 살펴보고, 다른 모듈을 둘러보고, 타입의 링크를 따라가고, API 문서의 형태를 상상해보고, 어떻게 개선할 수 있는지 살펴보겠습니다. ","version":"Next","tagName":"h3"},{"title":"Haddock 마크업​","type":1,"pageTitle":"문서 생성하기","url":"/learn-haskell-blog-generator/documentation#haddock-마크업","content":"Haddock은 프로젝트를 빌드하고, 내보낸 모듈과 내보낸 정의를 추적하고, 특별한 마크업 형식으로 작성된 소스 코드 주석을 통해 API 문서를 생성합니다. 마크업 형식에 대해 살펴보겠습니다. 몇 가지 중요한 부분을 다루겠지만, Haddock 마크업에 대한 전체 가이드는 Haddock 문서에서 확인할 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"정의 문서화하기​","type":1,"pageTitle":"문서 생성하기","url":"/learn-haskell-blog-generator/documentation#정의-문서화하기","content":"모든 haddock 주석은 일반적인 Haskell 주석의 일부로 표현됩니다. 단일 라인 형식 (--)과 다중 라인 형식 ({- 및 -}) 모두 사용할 수 있습니다. 주석 블록과 haddock 마커의 배치는 haddock 문자열이 어떤 하스켈 정의에 연결되는지를 결정합니다. 하스켈 정의에 대한 주석을 작성하려면 정의 이전에 |로 시작하는 주석 블록을 작성하거나, 정의 이후에 ^로 시작하는 주석 블록을 작성하면 됩니다. 예를 들어: -- | `Head`와 `Structure`를 통해 -- HTML 페이지를 생성합니다. html_ :: Head -- ^ HTML 파일의 @\\&lt;head\\&gt;@ 섹션을 나타냅니다. -&gt; Structure -- ^ HTML 파일의 @\\&lt;body\\&gt;@ 섹션을 나타냅니다. -&gt; Html html_ = ... ...  또 다른 예제를 살펴보겠습니다: {- | 다음과 같은 단일 마크업 구조를 표현합니다. - 문단 - 순서 없는 목록 - 코드 블록 -} data Structure = Heading Natural String -- ^ A 크기를 가지는 섹션 제목 | Paragraph String -- ^ 문단 | UnorderedList [String] -- ^ 순서 없는 문자열 목록 | OrderedList [String] -- ^ 순서 있는 문자열 목록 | CodeBlock [String] -- ^ 코드 블록  {- | 마크업을 HTML로 변환하는 모듈입니다. 이 모듈은 우리의 커스텀 마크업 언어로 작성된 문서를 HTML 페이지로 변환합니다. -} module HsBlog.Convert where  보시다시피, |와 ^를 사용하여 함수, 함수 인자, 타입, 데이터 생성자, 모듈 등을 문서화할 수 있습니다. 이들은 Haddock 주석을 작성하기 위해 기억해야 할 중요한 항목이라고 생각합니다. (사실 |만 기억해도 충분합니다) 팁 프로젝트에서 내보낸 모듈, 타입 및 최상단 정의에 상세한 설명이나 (최소한) 어떤 용도로 사용되는지 주석으로 작성하세요. 모듈 사용자 및 참여자들이 감사할 것입니다! ","version":"Next","tagName":"h3"},{"title":"섹션 제목​","type":1,"pageTitle":"문서 생성하기","url":"/learn-haskell-blog-generator/documentation#섹션-제목","content":"제목을 추가하여 모듈을 섹션으로 나눌 수 있습니다. 제목은 (다른 마크업 언어와 유사하게) *로 시작하는 주석으로 표현됩니다. 예를 들어: -- * HTML EDSL html_ :: Head -&gt; Structure -&gt; Html html_ = ... -- ** Structure p_ :: Content -&gt; Structure p_ = .. h_ :: Content -&gt; Structure h_ = .. ... -- ** Content txt_ :: String -&gt; Content txt_ = ... link_ :: FilePath -&gt; Content -&gt; Content link_ = ...  제목을 내보내기 목록에 추가할 수도 있습니다: module HsBlog.Html ( -- * HTML EDSL Html , html_ -- ** @\\&lt;head\\&gt;@ 섹션을 구성하기 위한 조합자 , Head , title_ , stylesheet_ , meta_ -- ** @\\&lt;body\\&gt;@ 섹션을 구성하기 위한 조합자 , Structure , p_ , h_ , ul_ , ol_ , code_ -- ** 구조 안 본문을 구성하기 위한 조합자 , Content , txt_ , img_ , link_ , b_ , i_ -- ** HTML을 문자열로 출력 , render ) where  모듈의 구성 요소들을 섹션으로 분리하면 중요한 부분을 모아두고, haddock이 모듈 페이지 상단에 목차를 생성하도록 할 수 있습니다. 제목을 통해 섹션을 분리한 이후, 때때로 하나의 모듈을 여러 모듈로 분리하는 것이 좋을지 여부를 쉽게 파악할 수 있습니다.  연습문제: 프로젝트의 모듈을 원하는 대로 재배열하고 섹션에 제목을 추가해 보세요.  ","version":"Next","tagName":"h3"},{"title":"서식 지정​","type":1,"pageTitle":"문서 생성하기","url":"/learn-haskell-blog-generator/documentation#서식-지정","content":"앞서 살펴본 것처럼 댓글 본문에 서식을 추가할 수도 있습니다. 예를 들어 다음과 같이 할 수 있습니다: `로 둘러싸서 하이퍼링크 식별자를 추가합니다. 예를 들어: `Heading` @로 둘러싸서 고정폭 텍스트를 추가합니다. 예를 들어: @Paragraph &quot;Hello&quot;@ /로 둘러싸서 강조 텍스트를 추가합니다. 예를 들어: /this is emphasised/ __로 둘러싸서 굵은 텍스트를 추가합니다. 예를 들어: __this is bold__ ","version":"Next","tagName":"h3"},{"title":"더 나아가​","type":1,"pageTitle":"문서 생성하기","url":"/learn-haskell-blog-generator/documentation#더-나아가","content":"이번 장에서는 haddock 마크업 언어의 기본 사항을 다루었습니다. 더 알고 싶다면 Haddock 마크업 가이드를 참고하세요. 코드 블록, 그리드 테이블, 이미지 및 예제와 같은 더 흥미로운 문서 구조를 생성하는 방법에 대한 정보가 있습니다. ","version":"Next","tagName":"h3"},{"title":"요약​","type":1,"pageTitle":"문서 생성하기","url":"/learn-haskell-blog-generator/documentation#요약","content":"지금까지 하스켈 프로그램을 문서화하는 한 가지 방법을 간단히 살펴보았습니다: haddock 마크업으로 사용해 소스 코드 주석을 작성하고 이를 통해 API 문서를 생성합니다. API 문서도 매우 유용하지만, 예제와 튜토리얼과 같은 다른 형태의 문서를 통해서도 사용자가 빠르게 시작할 수 있도록 도울 수 있습니다.  연습문제: 우리의 프로젝의 최상단 정의에 hadddock 주석을 추가해 보세요. 그리고 프로그램과 다양한 부분을 잘 이해하고 있는지 테스트해 보세요. 때로는 무언가를 설명하려고 하면 더 잘 이해하게 됩니다!  ","version":"Next","tagName":"h2"},{"title":"환경 변수 전달하기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/environment","content":"","keywords":"","version":"Next"},{"title":"환경​","type":1,"pageTitle":"환경 변수 전달하기","url":"/learn-haskell-blog-generator/environment#환경","content":"환경은 레코드 데이터 타입으로 표현할 수 있으며 사용자 입력을 통해 구성할 수 있습니다. 여기서 사용자 입력은 명령행 인자, 구성 파일 또는 그 외 다른 것들이 될 수 있습니다. module HsBlog.Env where data Env = Env { eBlogName :: String , eStylesheetPath :: FilePath } deriving Show defaultEnv :: Env defaultEnv = Env &quot;My Blog&quot; &quot;style.css&quot;  이러한 레코드를 요청받은 정보로 채운이후, 필요로 하는 함수의 입력으로 전달할 수 있습니다. 이는 작은 프로젝트에서는 잘 동작하지만, 프로젝트가 커지고 많은 중첩된 함수들이 같은 정보를 필요로 할 때는 환경을 전달하는 것이 번거로울 수 있습니다. 함수의 입력으로 환경을 전달하는 대신, mtl (또는 transformers) 패키지에서 제공하는ReaderT타입을 사용할 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"ReaderT​","type":1,"pageTitle":"환경 변수 전달하기","url":"/learn-haskell-blog-generator/environment#readert","content":"newtype ReaderT r m a = ReaderT (r -&gt; m a)  ReaderT는 ExceptT와 비슷한 monad transformer이며Functor, Applicative, Monad 그리고 MonadTrans의 인스턴스 또한 제공합니다. 정의에서 볼 수 있듯이, ReaderT는 r 타입의 값을 받아 m a 타입의 값을 반환하는 함수를 감싼 newtype 입니다.r은 보통 우리가 합성하고자 하는 함수들 사이에서 공유하고자 하는 환경을 나타냅니다. 그리고 m a는 우리가 반환하고자 하는 결과를 나타냅니다.m은 우리가 익숙한 Monad를 구현하는 어떤 타입이든 될 수 있습니다. 보통 IO 또는 Identity와 잘 어울리는데, 환경을 효과가 있는 또는 효과가 없는 계산 사이에서 공유하고자 할 때에 따라 다릅니다. ReaderT는 r 타입의 값을 가지고 있고 Applicative과 Monad 인터페이스를 사용할 때 다른 함수들에게 r 타입의 값을 전달합니다. 따라서 직접 r 타입의 값을 전달하지 않아도 됩니다. 필요한 경우 단순히 ask를 사용하면 됩니다. 블로그의 경우 Env를 전달하는 대신 우리의 함수들을 ReaderT를 사용하게 변경할 수 있습니다. 효과가 없고 IO를 사용하지 않으면 a 대신 Reader Env a를 반환하고 (또는 더 간단한 버전인 Reader Env a), 효과가 있는 경우 IO a 대신 ReaderT Env IO a를 반환합니다. 이전에 언급했듯이, Functor, Applicative 그리고 Monad는 이들의 인터페이스를 구현한 타입이 * -&gt; * kind를 가져야합니다. 이는 ReaderT r m이 이들의 인터페이스를 구현하고, 함수들을 &lt;*&gt; 또는 &gt;&gt;=로 합성할 때 f 또는 m을 타입 시그니처에서 ReaderT r m으로 대체한다는 것을 의미합니다. 이는 Either e의 경우 같은 에러타입을 가진 함수끼리만 합성할 수 있었던 것과 비슷하게,ReaderT r m의 경우 같은 r 타입과 같은 m 타입을 가진 함수끼리만 합성할 수 있다는 것을 의미합니다. 우리는 m을 Identity로 하는 특수화된 ReaderT인Reader를 사용할 예정인디ㅏ.Control.Monad.Reader는 다음 alias를 제공합니다: Reader r a = ReaderT r Identity a. 만약 ReaderT에 대한 개념이 아직 혼란스럽고 ReaderT가 어떻게 동작하는지 더 잘 이해하고 싶다면, 다음 연습문제를 풀어보세요: Applicative 또는 Monad 인터페이스 함수를 선택하세요. 개인적으로 liftA2를 추천합니다. 그리고 f (또는 m)를 ReaderT 타입인 ReaderT Int IO와 같은 구체적인 타입으로 대체하여 타입 시그니처를 특수화하세요.ReaderT newtype을 풀어 ReaderT Int IO t를 Int -&gt; IO t로 대체하세요.선택한 함수를 특수화된 타입에 대해 구현하세요. liftA2에 대한 정답 liftA2 :: Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c (1)번 정답 -- 특수화: `f`를 `ReaderT Env IO`로 대체 liftA2 :: (a -&gt; b -&gt; c) -&gt; ReaderT Env IO a -&gt; ReaderT Env IO b -&gt; ReaderT Env IO c (2)번 정답 -- newtype 해제, `ReaderT Env IO a`를 `Env -&gt; IO a`로 대체 liftA2 :: (a -&gt; b -&gt; c) -&gt; (Env -&gt; IO a) -&gt; (Env -&gt; IO b) -&gt; (Env -&gt; IO c) (3)번 정답 specialLiftA2 :: (a -&gt; b -&gt; c) -&gt; (Env -&gt; IO a) -&gt; (Env -&gt; IO b) -&gt; (Env -&gt; IO c) specialLiftA2 combine funcA funcB env = liftA2 combine (funcA env) (funcB env) 이러한 ReaderT에 대한 liftA2의 역할은 두 함수에 env를 제공하고, 나머지 일은 기반 타입 m (우리의 경우 IO)의 liftA2 구현에 위임하는 것을 알 수 있습니다. 이러한 형태는 다양한 m에 대해 기능을 추가하는 것처럼 보이지 않나요? 이것이 바로 monad transformer의 아이디어입니다. ","version":"Next","tagName":"h3"},{"title":"Reader 사용법​","type":1,"pageTitle":"환경 변수 전달하기","url":"/learn-haskell-blog-generator/environment#reader-사용법","content":"함수 정의하기​ 다음과 같은 함수를 정의하는 대신: txtsToRenderedHtml :: Env -&gt; [(FilePath, String)] -&gt; [(FilePath, String)]  다음과 같이 정의합니다: txtsToRenderedHtml :: [(FilePath, String)] -&gt; Reader Env [(FilePath, String)]  이제 이 함수는 Reader를 사용하므로, 함수 구현부도 수정이 필요합니다. 변경 전: txtsToRenderedHtml :: Env -&gt; [(FilePath, String)] -&gt; [(FilePath, String)] txtsToRenderedHtml env txtFiles = let txtOutputFiles = map toOutputMarkupFile txtFiles index = (&quot;index.html&quot;, buildIndex env txtOutputFiles) htmlPages = map (convertFile env) txtOutputFiles in map (fmap Html.render) (index : htmlPages)  env를 다른 함수에게 어떻게 전달하는지 주의깊게 살펴보세요. 변경 후: txtsToRenderedHtml :: [(FilePath, String)] -&gt; Reader Env [(FilePath, String)] txtsToRenderedHtml txtFiles = do let txtOutputFiles = map toOutputMarkupFile txtFiles index &lt;- (,) &quot;index.html&quot; &lt;$&gt; buildIndex txtOutputFiles htmlPages &lt;- traverse convertFile txtOutputFiles pure $ map (fmap Html.render) (index : htmlPages)  이제 do 표기법을 사용하고 있으며, env를 전달하지 않고도 buildIndex와 convertFile을 합성할 수 있습니다. 함수를 합성하기 위해 타입 클래스 인터페이스를 사용하고 있습니다.buildIndex에 fmap을 사용해 출력 파일을 추가하고, map 대신 traverse를 사용해 convertFile이 생성할 수 있는 여러 Reader 값을 합성합니다. Env 추출하기​ Env를 사용하려면 Reader에서 추출해야 합니다. 다음 함수를 사용합니다: ask :: ReaderT r m r  ask는 Reader에서 r을 꺼내오며 &gt;&gt;= 또는 do 표기법 안에서 &lt;-을 사용해 추출할 수 있습니다. 다음 코드를 비교해보세요: 변경 전: convertFile :: Env -&gt; (FilePath, Markup.Document) -&gt; (FilePath, Html.Html) convertFile env (file, doc) = (file, convert env (takeBaseName file) doc)  변경 후: convertFile :: (FilePath, Markup.Document) -&gt; Reader Env (FilePath, Html.Html) convertFile (file, doc) = do env &lt;- ask pure (file, convert env (takeBaseName file) doc)  노트 Reader를 사용하기 위해 convert를 수정하지 않았습니다. 이는 convert가 라이브러리의 사용자에게 노출되는 API이기 때문입니다. 더 간단한 인터페이스를 제공함으로써, monad transformer에 대해 아직 익숙하지 않은 사용자도 라이브러리를 사용할 수 있습니다. 함수 인자 전달 인터페이스는 간단하게 유지하는 것이 좋습니다. ","version":"Next","tagName":"h3"},{"title":"Reader 실행하기​","type":1,"pageTitle":"환경 변수 전달하기","url":"/learn-haskell-blog-generator/environment#reader-실행하기","content":"이전에 Either를 사용해 에러를 처리하는 것과 비슷하게, Reader를 사용하는 계산에 환경을 전달하고, 계산에서 결과를 추출해야 합니다. 이를 위해 runReader와 runReaderT 함수를 사용합니다: runReader :: Reader r a -&gt; (r -&gt; a) runReaderT :: ReaderT r m a -&gt; (r -&gt; m a)  이러한 함수는 Reader 또는 ReaderT를 r을 받는 함수로 변환합니다. 그러면 이 함수에 초기 환경을 전달할 수 있습니다: convertDirectory :: Env -&gt; FilePath -&gt; FilePath -&gt; IO () convertDirectory env inputDir outputDir = do DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir createOutputDirectoryOrExit outputDir let outputHtmls = runReader (txtsToRenderedHtml filesToProcess) env copyFiles outputDir filesToCopy writeFiles outputDir outputHtmls putStrLn &quot;Done.&quot;  let outputHtmls 부분을 살펴보세요. ","version":"Next","tagName":"h3"},{"title":"추가: 특정 호출을 위해 Env 변환하기​","type":1,"pageTitle":"환경 변수 전달하기","url":"/learn-haskell-blog-generator/environment#추가-특정-호출을-위해-env-변환하기","content":"때로는 특정 함수 호출에 전달하는 Env를 수정해야 할 수도 있습니다. 예를 들어, 많은 정보를 포함하는 일반적인 Env 타입이 있고, 그 중 일부 정보만 필요로 하는 함수 호출이 있을 수 있습니다. 만약 호출하는 함수가 conver와 비슷하고 Reader대신 환경을 인자로 받는다면,ask를 활용해 환경을 추출하고, 변환한 후 그 결과를 함수에 전달할 수 있습니다: outer :: Reader BigEnv MyResult outer = do env &lt;- ask pure (inner (extractSmallEnv env)) inner :: SmallEnv -&gt; MyResult inner = ... extractSmallEnv :: BigEnv -&gt; SmallEnv extractSmallEnv = ...  하지만 만약 inner가 인자 전달 대신 Reader SmallEnv를 사용한다면,runReader를 사용해 inner를 일반 함수로 변환할 수 있으며 위와 같은 방식을 적용할 수 있습니다! outer :: Reader BigEnv MyResult outer = do env &lt;- ask -- Here the type of `runReader inner` is `SmallEnv -&gt; MyResult` pure (runReader inner (extractSmallEnv env)) inner :: Reader SmallEnv MyResult inner = ... extractSmallEnv :: BigEnv -&gt; SmallEnv extractSmallEnv = ...  이러한 패턴은 일반적이라서withReaderT라는 함수가 존재하며 이를 사용해 더 간단하게 표현할 수 있습니다: withReaderT :: (env2 -&gt; env1) -&gt; ReaderT env1 m a -&gt; ReaderT env2 m a  이 함수는 환경을 변환하는 함수를 받아 ReaderT env1 m a 계산을 ReaderT env2 m a 계산으로 변환합니다. 이번 예제에 적용해보겠습니다: outer :: Reader BigEnv MyResult outer = withReaderT extractSmallEnv inner   문제: 이번 예제로 구체화하면 withReaderT의 타입은 어떻게 될까요? 정답 withReaderT :: (BigEnv -&gt; SmallEnv) -- `extractSmallEnv` 타입과 동일합니다. -&gt; Reader SmallEnv MyResult -- `inner` 타입과 동일합니다. -&gt; Reader BigEnv MyResult -- `outer` 타입과 동일합니다.   각 환경의 순서에 주의하세요!SmallEnv의 Reader를 BigEnv의 Reader로 변환하기 위해서는, BigEnv를 SmallEnv로 변환하는 함수가 필요합니다! 이러한 순서를 가지는 이유는 함수의 출력대신 입력에 대해 매핑을 수행하기 때문입니다. 이는 공변(variance)과 반공변(covariance)에 대한 주제와 관련이 있지만, 지금 당장은 중요하지 않습니다. ","version":"Next","tagName":"h3"},{"title":"로직에서 Env 사용하기​","type":1,"pageTitle":"환경 변수 전달하기","url":"/learn-haskell-blog-generator/environment#로직에서-env-사용하기","content":"아직 다루지 못한 주제가 하나 있습니다. 바로 convert 함수를 통해 원하는 페이지를 생성하는 방법입니다. 사실 우리는 아직 스타일시트를 HTML EDSL에 추가하는 기능조차 존재하지 않습니다. 이제 이 기능을 추가해보겠습니다:  스타일시트는 head 요소에 들어가기 때문에, head 정보를 위한 Structure와 같은 추가적인 newtype을 만드는 것이 좋을 것 같습니다. 제목, 스타일시트, 그리고 메타 요소와 같은 것들은 Structure를 만들면서 했던것과 같은 방식으로 조합할 수 있습니다! 지금 당장 해보기: head를 위한 3 개의 함수를 구현해 HTML 라이브러리를 확장해보세요. 제목을 위한 title_, 스타일시트를 위한 stylesheet_, 그리고twitter cards와 같은 메타 요소를 위한 meta_입니다. 정답 src/HsBlog/Html.hs -- Html.hs module HsBlog.Html ( Html , Head , title_ , stylesheet_ , meta_ , Structure , html_ , p_ , h_ , ul_ , ol_ , code_ , Content , txt_ , img_ , link_ , b_ , i_ , render ) where import Prelude hiding (head) import HsBlog.Html.Internal src/HsBlog/Html/Internal.hs newtype Head = Head String -- * EDSL html_ :: Head -&gt; Structure -&gt; Html html_ (Head head) content = Html ( el &quot;html&quot; ( el &quot;head&quot; head &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) -- * Head title_ :: String -&gt; Head title_ = Head . el &quot;title&quot; . escape stylesheet_ :: FilePath -&gt; Head stylesheet_ path = Head $ &quot;&lt;link rel=\\&quot;stylesheet\\&quot; type=\\&quot;text/css\\&quot; href=\\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\\&quot;&gt;&quot; meta_ :: String -&gt; String -&gt; Head meta_ name content = Head $ &quot;&lt;meta name=\\&quot;&quot; &lt;&gt; escape name &lt;&gt; &quot;\\&quot; content=\\&quot;&quot; &lt;&gt; escape content &lt;&gt; &quot;\\&quot;&gt;&quot; instance Semigroup Head where (&lt;&gt;) (Head h1) (Head h2) = Head (h1 &lt;&gt; h2) instance Monoid Head where mempty = Head &quot;&quot; conver와 buildIndex가 새로운 API를 사용하게 수정하세요.buildIndex는 Reader를 반환해야 합니다! 정답 src/HsBlog/Convert.hs import Prelude hiding (head) import HsBlog.Env (Env(..)) convert :: Env -&gt; String -&gt; Markup.Document -&gt; Html.Html convert env title doc = let head = Html.title_ (eBlogName env &lt;&gt; &quot; - &quot; &lt;&gt; title) &lt;&gt; Html.stylesheet_ (eStylesheetPath env) article = foldMap convertStructure doc websiteTitle = Html.h_ 1 (Html.link_ &quot;index.html&quot; $ Html.txt_ $ eBlogName env) body = websiteTitle &lt;&gt; article in Html.html_ head body src/HsBlog/Directory.hs buildIndex :: [(FilePath, Markup.Document)] -&gt; Reader Env Html.Html buildIndex files = do env &lt;- ask let previews = map ( \\(file, doc) -&gt; case doc of Markup.Head 1 head : article -&gt; Html.h_ 3 (Html.link_ file (Html.txt_ head)) &lt;&gt; foldMap convertStructure (take 2 article) &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;)) _ -&gt; Html.h_ 3 (Html.link_ file (Html.txt_ file)) ) files pure $ Html.html_ ( Html.title_ (eBlogName env) &lt;&gt; Html.stylesheet_ (eStylesheetPath env) ) ( Html.h_ 1 (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;)) &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;) &lt;&gt; mconcat previews ) Env를 위한 명령줄 파서를 만들어, convert-dir명령어에 연결하세요. 그리고 결과를 convertDirectory 함수에 전달하세요. 정답 src/HsBlog.hs import HsBlog.Env (defaultEnv) convertSingle :: String -&gt; Handle -&gt; Handle -&gt; IO () process :: String -&gt; String -&gt; String process title = Html.render . convert defaultEnv title . Markup.parse app/OptParse.hs import HsBlog.Env ------------------------------------------------ -- * Our command-line options model -- | Model data Options = ConvertSingle SingleInput SingleOutput | ConvertDir FilePath FilePath Env deriving Show ------------------------------------------------ -- * Directory conversion parser pConvertDir :: Parser Options pConvertDir = ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir &lt;*&gt; pEnv -- | Parser for blog environment pEnv :: Parser Env pEnv = Env &lt;$&gt; pBlogName &lt;*&gt; pStylesheet -- | Blog name parser pBlogName :: Parser String pBlogName = strOption ( long &quot;name&quot; &lt;&gt; short 'N' &lt;&gt; metavar &quot;STRING&quot; &lt;&gt; help &quot;Blog name&quot; &lt;&gt; value (eBlogName defaultEnv) &lt;&gt; showDefault ) -- | Stylesheet parser pStylesheet :: Parser String pStylesheet = strOption ( long &quot;style&quot; &lt;&gt; short 'S' &lt;&gt; metavar &quot;FILE&quot; &lt;&gt; help &quot;Stylesheet filename&quot; &lt;&gt; value (eStylesheetPath defaultEnv) &lt;&gt; showDefault ) app/Main.hs main :: IO () main = do options &lt;- parse case options of ConvertDir input output env -&gt; HsBlog.convertDirectory env input output ...   ","version":"Next","tagName":"h3"},{"title":"요약​","type":1,"pageTitle":"환경 변수 전달하기","url":"/learn-haskell-blog-generator/environment#요약","content":"직접 인자를 전달하는 방법과 Reader를 사용하는 방법 중 어떤것을 선호하시나요? 저는 상황에 따라 Reader를 사용하는 두 번째 방식이 직접 인자 전달하는 첫 번째 방식보다 더 좋다고 말할 수는 없다고 생각합니다. Reader와 ReaderT를 사용하면 이러한 개념과 기술에 익숙하지 않은 사람에게는 불친절한 코드가 될 수 있습니다. 이러한 상황에서는 큰 이점을 얻지 못할 것입니다. 프로그램이 커질수록 Reader를 사용하는 방법이 더 유용해집니다. 우리의 비교적 작은 예제에서는 Reader를 사용하는 것이 적합하지 않을 수도 있습니다. 하지만 Reader는 익혀야 할 중요한 기술이라고 생각하기에 이 책에 포함했습니다. 고급 기술을 사용했을 때의 이점과 비용을 고려하는 것은 중요합니다. 그리고 때로는 할 수 있다면, 더 간단한 방법을 사용하는 것이 좋습니다. Git 커밋을 통해이번에 수정한 내역과 현재까지 코드 를 확인할 수 있습니다. ","version":"Next","tagName":"h3"},{"title":"에러 처리와 여러 파일 다루기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/errors_and_files","content":"","keywords":"","version":"Next"},{"title":"HTML 링크​","type":1,"pageTitle":"에러 처리와 여러 파일 다루기","url":"/learn-haskell-blog-generator/errors_and_files#html-링크","content":"우리의 HTML EDSL은 아직 링크나 굵은 글씨, 이탤릭체 등의 기능을 지원하지 않습니다. 이 기능들을 추가해서 인덱스를 만들 때 사용할 수 있도록 해야 합니다. 지금까지는 String을 Structure에 전달해서 p_나 h_와 같은 함수를 만들었습니다. 대신에 텍스트, 링크, 이미지 등을 의미하는 새로운 타입인 Content를 만들어서 이 타입을 전달하면 됩니다.  연습문제: 방금 언급한 기능들을 추가해 보세요. 컴파일러 에러를 해결하고 필요하다면 리팩터링을 진행하세요. 정답 src/Html/Internal.hs module HsBlog.Html.Internal where import Numeric.Natural -- * Types newtype Html = Html String newtype Structure = Structure String newtype Content = Content String type Title = String -- * EDSL html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; (escape title)) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) -- * Structure p_ :: Content -&gt; Structure p_ = Structure . el &quot;p&quot; . getContentString h_ :: Natural -&gt; Content -&gt; Structure h_ n = Structure . el (&quot;h&quot; &lt;&gt; show n) . getContentString ul_ :: [Structure] -&gt; Structure ul_ = Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString) ol_ :: [Structure] -&gt; Structure ol_ = Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString) code_ :: String -&gt; Structure code_ = Structure . el &quot;pre&quot; . escape instance Semigroup Structure where (&lt;&gt;) c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) instance Monoid Structure where mempty = Structure &quot;&quot; -- * Content txt_ :: String -&gt; Content txt_ = Content . escape link_ :: FilePath -&gt; Content -&gt; Content link_ path content = Content $ elAttr &quot;a&quot; (&quot;href=\\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\\&quot;&quot;) (getContentString content) img_ :: FilePath -&gt; Content img_ path = Content $ &quot;&lt;img src=\\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\\&quot;&gt;&quot; b_ :: Content -&gt; Content b_ content = Content $ el &quot;b&quot; (getContentString content) i_ :: Content -&gt; Content i_ content = Content $ el &quot;i&quot; (getContentString content) instance Semigroup Content where (&lt;&gt;) c1 c2 = Content (getContentString c1 &lt;&gt; getContentString c2) instance Monoid Content where mempty = Content &quot;&quot; -- * Render render :: Html -&gt; String render html = case html of Html str -&gt; str -- * Utilities el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; elAttr :: String -&gt; String -&gt; String -&gt; String elAttr tag attrs content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot; &quot; &lt;&gt; attrs &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; getStructureString :: Structure -&gt; String getStructureString structure = case structure of Structure str -&gt; str getContentString :: Content -&gt; String getContentString content = case content of Content str -&gt; str escape :: String -&gt; String escape = let escapeChar c = case c of '&lt;' -&gt; &quot;&amp;lt;&quot; '&gt;' -&gt; &quot;&amp;gt;&quot; '&amp;' -&gt; &quot;&amp;amp;&quot; '&quot;' -&gt; &quot;&amp;quot;&quot; '\\'' -&gt; &quot;&amp;#39;&quot; _ -&gt; [c] in concat . map escapeChar src/Html.hs module HsBlog.Html ( Html , Title , Structure , html_ , p_ , h_ , ul_ , ol_ , code_ , Content , txt_ , img_ , link_ , b_ , i_ , render ) where import HsBlog.Html.Internal src/Convert.hs module HsBlog.Convert where import qualified HsBlog.Markup as Markup import qualified HsBlog.Html as Html convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html convert title = Html.html_ title . foldMap convertStructure convertStructure :: Markup.Structure -&gt; Html.Structure convertStructure structure = case structure of Markup.Heading n txt -&gt; Html.h_ n $ Html.txt_ txt Markup.Paragraph p -&gt; Html.p_ $ Html.txt_ p Markup.UnorderedList list -&gt; Html.ul_ $ map (Html.p_ . Html.txt_) list Markup.OrderedList list -&gt; Html.ol_ $ map (Html.p_ . Html.txt_) list Markup.CodeBlock list -&gt; Html.code_ (unlines list)   Git 커밋을 통해이번에 수정한 내역과 현재까지 코드 를 확인할 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"인덱스 페이지 만들기​","type":1,"pageTitle":"에러 처리와 여러 파일 다루기","url":"/learn-haskell-blog-generator/errors_and_files#인덱스-페이지-만들기","content":"이제 확장된 HTML EDSL을 사용해, 다른 페이지로의 링크가 있는 인덱스 페이지를 만들어 봅시다. 인덱스 페이지를 만들기 위해 타겟 경로와 마크업(첫 제목과 문단을 가져와 인덱스 페이지에 사용하기 위한)을 가진 파일 목록이 필요합니다. 출력은 Html 페이지여야 합니다.  다음과 같은 함수를 구현해보세요: buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html  정답 buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html buildIndex files = let previews = map ( \\(file, doc) -&gt; case doc of Markup.Heading 1 heading : article -&gt; Html.h_ 3 (Html.link_ file (Html.txt_ heading)) &lt;&gt; foldMap convertStructure (take 3 article) &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;)) _ -&gt; Html.h_ 3 (Html.link_ file (Html.txt_ file)) ) files in Html.html_ &quot;Blog&quot; ( Html.h_ 1 (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;)) &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;) &lt;&gt; mconcat previews )   ","version":"Next","tagName":"h2"},{"title":"디렉터리 처리하기​","type":1,"pageTitle":"에러 처리와 여러 파일 다루기","url":"/learn-haskell-blog-generator/errors_and_files#디렉터리-처리하기","content":"디렉터리를 처리하는 일반적인 전략은 다음과 같습니다: 출력 디렉터리를 만듭니다디렉터리의 모든 파일 이름을 가져옵니다확장자에 따라 필터링합니다, txt 파일을 처리하고 다른 파일은 수정 없이 복사합니다각 텍스트 파일을 파싱하고, 인덱스를 만들고, 파일을 HTML로 변환하고, 모든 것을 출력 디렉터리에 씁니다 파싱 함수는 실패할 가능성이 거의 없으나 파일 시스템에서 파일을 읽거나 쓰는 것은 다양한 원인으로 인해 실패할 수 있습니다. 정적 블로그 생성기는 하나의 파일이 문제가 있어도 전체 과정이 실패하지는 않도록 동작하려고 합니다. 이는 하스켈에서 에러 처리에 대해 배우기 좋은 기회입니다. 부수 효과가 없는 코드와 I/O 코드에 대한 에러 처리 모두에 대해 배워보겠습니다. 다음 몇 장에 걸쳐 하스켈레어 에러 처리에 대한 전반적인 내용을 살펴보고, 우리의 경우에 적합한 접근 방식을 찾아보겠습니다. ","version":"Next","tagName":"h2"},{"title":"Either와 IO","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/errors_and_files/except","content":"","keywords":"","version":"Next"},{"title":"ExceptT를 사용한 IO + Either 합성​","type":1,"pageTitle":"Either와 IO","url":"/learn-haskell-blog-generator/errors_and_files/except#exceptt를-사용한-io--either-합성","content":"이를 해결하는 한 가지 방법은 monad transformer를 사용하는 것입니다. Monad transformer는 monad 기능을 하나씩 쌓아 올릴 수 있는 방법을 제공합니다. 이름이 transformer인 이유는 monad 인스턴스를 입력으로 받아 새로운 기능을 쌓아 올린 새로운 monad 타입을 반환하기 때문입니다. 예를 들어, IO (Either Error a)와 같은 타입의 값을 monadic 인터페이스를 사용하여 합성하고 싶다고 가정해봅시다. 이를 위해 ExceptT라는 monad transformer를 사용하여 IO 위에 쌓을 수 있습니다.ExceptT의 정의를 살펴보겠습니다: newtype ExceptT e m a = ExceptT (m (Either e a))  newtype은 기존 타입의 새로운 이름을 만드는 데 사용됩니다.e를 Error로, m을 IO로 바꾸면 우리가 원하는 것과 정확히 일치하는 IO (Either Error a)가 됩니다. 그리고 ExceptT Error IO a를 IO (Either Error a)로 변환하는 함수 runExceptT를 사용할 수 있습니다: runExceptT :: ExceptT e m a -&gt; m (Either e a)  ExceptT는 Either의 기능과 임의의 m의 기능을 결합하는 방식으로 모나드 인터페이스를 구현합니다.ExceptT e m은 Monad 인스턴스이므로, 특수화된 &gt;&gt;=의 구현은 다음과 같습니다: -- 일반적인 버전 (&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b -- 특수화된 버전, 위의 `m`을 `ExceptT e m`으로 바꾸면 됩니다. (&gt;&gt;=) :: Monad m =&gt; ExceptT e m a -&gt; (a -&gt; ExceptT e m b) -&gt; ExceptT e m b  특수화된 버전에서의 m은 여전히 Monad 인스턴스여야 합니다.  어떻게 동작하는지 확실하지 않다면, IO (Either Error a)의 &gt;&gt;=를 구현해보세요: bindExceptT :: IO (Either Error a) -&gt; (a -&gt; IO (Either Error b)) -&gt; IO (Either Error b)  정답 bindExceptT :: IO (Either Error a) -&gt; (a -&gt; IO (Either Error b)) -&gt; IO (Either Error b) bindExceptT mx f = do x &lt;- mx -- `x`의 타입은 `Either Error a`입니다. case x of Left err -&gt; pure (Left err) Right y -&gt; f y 여기서 Error 또는 IO의 구현 세부 사항을 실제로 사용하지 않았습니다.Error는 전혀 언급되지 않았고, IO에 대해서는 do 표기법과 함께 모나드 인터페이스만 사용했습니다. 따라서 더 일반화된 타입 시그니처로 동일한 함수를 작성할 수 있습니다: bindExceptT :: Monad m =&gt; m (Either e a) -&gt; (a -&gt; m (Either e b)) -&gt; m (Either e b) bindExceptT mx f = do x &lt;- mx -- `x` has the type `Either e a` case x of Left err -&gt; pure (Left err) Right y -&gt; f y 그리고 newtype ExceptT e m a = ExceptT (m (Either e a))이기 때문에ExceptT 생성자를 사용해 감쌀 수 있습니다. bindExceptT :: Monad m =&gt; ExceptT e m a -&gt; (a -&gt; ExceptT e m b) -&gt; ExceptT e m b bindExceptT mx f = ExceptT $ do -- `runExceptT mx`의 타입은 `m (Either e a)`입니다. -- `x`의 타입은 `Either e a`입니다. x &lt;- runExceptT mx case x of Left err -&gt; pure (Left err) Right y -&gt; runExceptT (f y)   monad transformer를 쌓을 때, 쌓는 순서가 중요하다는 점을 기억하세요.ExceptT Error IO a을 사용하면, Either를 반환하는 IO 연산이 생성됩니다. ExceptT는 두 가지 경우를 모두 처리할 수 있습니다. - throwError 함수를 사용하여 오류 값을 반환할 수 있습니다: throwError :: e -&gt; ExceptT e m a  그리고 monadic 타입 m의 값을 반환하는 함수를 끌어올려(lift), ExceptT e m a를 반환하게 할 수 있습니다: lift :: m a -&gt; ExceptT e m a  예를 들면: getLine :: IO String lift getLine :: ExceptT e IO String  lift는 사실 MonadTrans의 타입 클래스 함수이기도 합니다.MonadTrans는 monad transformer의 타입 클래스입니다. 따라서 정확한 타입은 lift getLine :: MonadTrans t =&gt; t IO String이지만, &gt; 여기서는 이해를 돕기 위해 구체화했습니다. 이제 다음의 경우: readFile :: FilePath -&gt; ExceptT IOError IO String writeFile :: FilePath -&gt; String -&gt; ExceptT IOError IO ()  문제 없이 합성할 수 있습니다: readFile &quot;input.txt&quot; &gt;&gt;= writeFile &quot;ouptut.html&quot;  여기서 주의해야 할 점은 에러 타입 e가 (Either와 Except 모두) 각 함수 내에서 동일해야 한다는 것입니다! 이는 readFile과 writeFile 모두 에러를 나타내는 타입이 동일해야 한다는 것을 의미합니다. 따라서 이러한 함수의 사용자가 동일한 에러를 처리해야 함을 의미합니다.writeFile을 호출한 사용자는 &quot;파일을 찾을 수 없음&quot; 에러를 처리해야 할까요?readFile을 호출한 사용자는 &quot;디스크 공간 부족&quot; 에러를 처리해야 할까요? &quot;네트워크 연결 불가&quot;, &quot;메모리 부족&quot;, &quot;취소된 스레드&quot; 등 이 외에 수많은 IO 에러가 있습니다! 사용자가 이러한 모든 에러를 처리하도록 요구할 수는 없으며, 데이터 타입에서 이러한 모든 에러를 다룰 수도 없습니다. 그렇다면 어떻게 해야 할까요? IO 코드에 대해서는 이러한 접근 방식을 포기하고, Exceptions 라는 다른 방식을 사용합니다. 다음 장에서 살펴보겠습니다. 만약 ExceptT를Identity라 불리는 다른 타입 위에 쌓는다면,Except라는 이름(끝에 T가 없습니다)의 Either와 동일한 타입을 얻을 수 있습니다.Except는 Either보다 더 적절한 이름과 에러 처리를 위한 더 나은 API를 가지고 있기 때문에Either 대신 Except를 사용하는 것이 더 좋을 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"Either를 활용한 에러 처리","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/errors_and_files/either","content":"","keywords":"","version":"Next"},{"title":"Applicative + Traversable​","type":1,"pageTitle":"Either를 활용한 에러 처리","url":"/learn-haskell-blog-generator/errors_and_files/either#applicative--traversable","content":"Either의 Applicative 인터페이스는 매우 강력하며, 다른 추상화인 Traversable와 결합할 수 있습니다. - 연결 리스트나 이진 트리와 같이 왼쪽에서 오른쪽으로 순회할 수 있는 데이터 구조를 말합니다. 이를 통해 Traversable를 구현하는 데이터 구조이기만 하면 임의의 개수의 Either ParseDigitError Int와 같은 값들을 결합할 수 있습니다. 예제를 살펴보겠습니다: ghci&gt; :t &quot;1234567&quot; &quot;1234567&quot; :: String -- String은 Char의 리스트에 대한 별칭인 것을 기억하세요. ghci&gt; :info String type String :: * type String = [Char] -- Defined in ‘GHC.Base’ ghci&gt; :t map parseDigit &quot;1234567&quot; map parseDigit &quot;1234567&quot; :: [Either ParseDigitError Int] ghci&gt; map parseDigit &quot;1234567&quot; [Right 1,Right 2,Right 3,Right 4,Right 5,Right 6,Right 7] ghci&gt; :t sequenceA sequenceA :: (Traversable t, Applicative f) =&gt; t (f a) -&gt; f (t a) -- `t`를 `[]`로, `f`를 `Either Error`로 대체해서 생각해볼 수 있습니다. ghci&gt; sequenceA (map parseDigit &quot;1234567&quot;) Right [1,2,3,4,5,6,7] ghci&gt; map parseDigit &quot;1a2&quot; [Right 1,Left (NotADigit 'a'),Right 2] ghci&gt; sequenceA (map parseDigit &quot;1a2&quot;) Left (NotADigit 'a')  map과 sequenceA를 결합하는 대신 traverse를 사용할 수도 있습니다. ghci&gt; :t traverse traverse :: (Traversable t, Applicative f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b) ghci&gt; traverse parseDigit &quot;1234567&quot; Right [1,2,3,4,5,6,7] ghci&gt; traverse parseDigit &quot;1a2&quot; Left (NotADigit 'a')  Either a 또는 IO처럼 Applicative 인터페이스를 구현한 타입과 [] 또는Map k(다른 언어에서는 딕셔너리라고도 함 - 키와 값의 매핑) 와 같이 Traversable 인터페이스를 구현한 어떠한 두 타입에 대해서도 traverse를 사용할 수 있습니다. 예를 들어 IO와 []를 결합할 수 있습니다.Map 데이터 구조는 fromList 함수를 사용하여 튜플의 리스트에서 생성할 수 있습니다. - 튜플의 첫 번째 값은 키이고 두 번째 값은 값입니다. ghci&gt; import qualified Data.Map as M -- 컨테이너 패키지에서 가져옵니다. ghci&gt; file1 = (&quot;output/file1.html&quot;, &quot;input/file1.txt&quot;) ghci&gt; file2 = (&quot;output/file2.html&quot;, &quot;input/file2.txt&quot;) ghci&gt; file3 = (&quot;output/file3.html&quot;, &quot;input/file3.txt&quot;) ghci&gt; files = M.fromList [file1, file2, file3] ghci&gt; :t files :: M.Map FilePath FilePath -- FilePath는 String의 별칭입니다. files :: M.Map FilePath FilePath :: M.Map FilePath FilePath ghci&gt; readFiles = traverse readFile ghci&gt; :t readFiles readFiles :: Traversable t =&gt; t FilePath -&gt; IO (t String) ghci&gt; readFiles files fromList [(&quot;output/file1.html&quot;,&quot;I'm the content of file1.txt\\n&quot;),(&quot;output/file2.html&quot;,&quot;I'm the content of file2.txt\\n&quot;),(&quot;output/file3.html&quot;,&quot;I'm the content of file3.txt\\n&quot;)] ghci&gt; :t readFiles files readFiles files :: IO (Map String String)  위 코드에서 readFiles라는 함수를 만들었습니다. 이 함수는 출력 파일 경로를 입력 파일 경로로 매핑을 수행합니다. 그리고 입력 파일을 읽어서 그 내용을 맵에 바로 쓰는 IO 연산을 반환합니다! 나중에 유용하게 사용할 수 있을 것입니다. ","version":"Next","tagName":"h2"},{"title":"에러가 여러 개인 경우​","type":1,"pageTitle":"Either를 활용한 에러 처리","url":"/learn-haskell-blog-generator/errors_and_files/either#에러가-여러-개인-경우","content":"Either의 kind는 * -&gt; * -&gt; *(두 개의 타입 파라미터를 받습니다)이기 때문에 Either는 Functor나 Applicative의 인스턴스가 될 수 없습니다. 이러한 타입 클래스의 인스턴스는 kind가 * -&gt; *이어야 합니다. 다음 타입 클래스 함수 시그니처를 살펴보면: fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b  그리고 특정한 타입에 대해 이를 구현하고 싶다면(f의 자리에), f를 대상 타입으로 치환할 수 있어야 합니다.Either를 사용하려고 하면 다음과 같은 시그니처를 얻을 수 있습니다: fmap :: (a -&gt; b) -&gt; Either a -&gt; Either b  Either a와 Either b는 둘 다 구체화된 타입이 아니기 때문에 이는 타입 오류가 발생합니다. 같은 이유로 f를 Int로 치환하려고 하면 다음과 같은 시그니처를 얻을 수 있습니다: fmap :: (a -&gt; b) -&gt; Int a -&gt; Int b  이 또한 타입 오류가 발생합니다. Either를 사용할 수 없지만, Either e의 kind는 * -&gt; *이기 때문에 사용할 수 있습니다. 다음 시그니처에서 f를 Either e로 치환해봅시다: liftA2 :: Applicative =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c  다음과 같은 결과를 얻을 수 있습니다: liftA2 :: (a -&gt; b -&gt; c) -&gt; Either e a -&gt; Either e b -&gt; Either e c  이를 통해 알 수 있는 것은 Left 생성자의 타입이 같은 두 개의 Either를 결합할 때만 applicative 인터페이스를 사용할 수 있다는 것입니다. 그렇다면 두 개의 Either를 결합할 때 Left 생성자의 타입이 다르다면 어떻게 해야 할까요? 몇 가지 방법이 있지만 가장 적법한 방법은 다음과 같습니다: 같은 에러 타입을 반환하도록 만듭니다. 모든 에러를 하나의 타입으로 통합하는 ADT를 작성합니다. 이는 일부 경우에는 작동하지만 항상 이상적인 것은 아닙니다. 예를 들어 parseDigit의 입력이 빈 문자열일 수 있는 경우를 사용자가 직접 처리하게 만들어서는 안 됩니다.각 타입에 대해 특수한 에러 타입을 사용합니다. 그리고 이들을 결합할 때는 일반적인 에러 타입으로 매핑합니다. 이는 first 함수를 사용하여 수행할 수 있습니다.first 함수는 Bifunctor 타입 클래스에 정의되어 있습니다. ","version":"Next","tagName":"h2"},{"title":"모나딕 인터페이스​","type":1,"pageTitle":"Either를 활용한 에러 처리","url":"/learn-haskell-blog-generator/errors_and_files/either#모나딕-인터페이스","content":"Applicative 인터페이스를 사용하면 여러 개의 Either 값(또는 IO나 Parser와 같은 다른 applicative functor 인스턴스)을 처리할 수 있게 함수를 끌어올릴 수 있습니다. 하지만 더 자주 사용하는 방법은 에러가 발생할 수 있는 한 계산결과를 에러가 발생할 수 있는 다른 계산에 사용하는 것입니다. 예를 들어, 컴파일러는 어휘 분석, 파싱, 타입 체크, 코드 생성 등의 단계로 구성됩니다. 각 단계는 이전 단계의 출력에 의존하며, 각 단계는 실패할 수 있습니다. 각 단계에 대한 함수의 타입은 다음과 같습니다: tokenize :: String -&gt; Either Error [Token] parse :: [Token] -&gt; Either Error AST typecheck :: AST -&gt; Either Error TypedAST  이러한 함수를 합성해 체인으로 작동하도록 만들려고 합니다. 즉 tokenize의 출력은 parse로, parse의 출력은 typecheck로 이동합니다. 우리는 특정 함수를 Either에 대해 동작하게 끌어올리는 방법을 이미 알고 있습니다.Either를 반환하는 함수 또한 끌어올릴 수 있습니다: -- fmap 타입은 다음과 같습니다 fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b -- `Either Error`로 치환하면 fmap :: (a -&gt; b) -&gt; Either Error a -&gt; Either Error b -- 여기서 `a`는 [Token]이고 `b`는 `Either Error AST`입니다: &gt; fmap parse (tokenize string) :: Either Error (Either Error AST)  위 코드는 컴파일에 성공하지만, 훌륭하지는 않습니다. 왜냐하면 우리는 Either Error의 계층을 만들고 있고 typecheck에서 이 트릭을 다시 사용할 수 없기 때문입니다!typecheck는 AST를 기대하지만 fmap parse (tokenize string)에 대해 fmap을 시도하면 a는 Either Error AST가 됩니다. 우리가 원하는 것은 이러한 계층을 중첩하는 것이 아니라 펼치는 것입니다.Either Error (Either Error AST)의 값이 가질 수 있는 종류를 살펴보면 다음과 같습니다: Left &lt;error&gt;Right (Left error)Right (Right &lt;ast&gt;)  연습문제: 위 타입에 대해 패턴매칭을 수행하면 어떠한 코드가 나올까요? 정답 case tokenize string of Left err -&gt; Left err Right tokens -&gt; case parse tokens of Left err -&gt; Left err Right ast -&gt; typecheck ast 각 단계에서 에러가 발생하면 에러를 반환하고 중단합니다. 성공하면 다음 단계에 대한 입력으로 사용합니다.  이러한 Either의 중첩을 펼치는 과정은 마지막 단계인 Right tokens일 때도 동일하게 수행됩니다. flatten :: Either e (Either e a) -&gt; Either e a flatten e = case e of Left l -&gt; Left l Right x -&gt; x  위와 같은 함수를 만들었다면, fmap parse (tokenize string) :: Either Error (Either Error AST)의 결과에 적용할 수 있습니다: &gt; flatten (fmap parse (tokenize string)) :: Either Error AST  이제 typecheck와 합성하기 위해 다시 사용할 수 있습니다: &gt; flatten (fmap typecheck (flatten (fmap parse (tokenize string)))) :: Either Error TypedAST  이러한 flatten + `fmap' 조합은 반복되는 패턴이기에, 이를 함수로 결합할 수 있습니다: flatMap :: (a -&gt; Either e b) -&gt; Either a -&gt; Either b flatMap func val = flatten (fmap func val)  이제 코드를 다음과 같이 작성할 수 있습니다: &gt; flatMap typecheck (flatMap parse (tokenize string)) :: Either Error TypedAST -- 또는 함수를 중위 표기법으로 변환하기 위해 backtick을 사용합니다: &gt; typecheck `flatMap` parse `flatMap` tokenize string -- 또는 custom infix operator를 만듭니다: (=&lt;&lt;) = flatMap &gt; typeCheck =&lt;&lt; parse =&lt;&lt; tokenize string  flatten (그리고 flatMap) 함수는 하스켈에서는 다른 이름으로 사용되며,join과 =&lt;&lt;(&quot;reverse bind&quot;로 발음) 로 불립니다. 이들은 하스켈에서 또 다른 매우 유용한 추상화의 핵심입니다. 다음과 같은 항목을 구현한 타입이 있다면: Functor 인터페이스, 특히 fmap 함수Applicative 인터페이스, 특히 pure 함수join 함수 Monad 타입 클래스의 인스턴스를 구현할 수 있습니다. Functor를 통해 우리는 함수를 &quot;끌어올려&quot; functor 타입 클래스를 구현하는 타입 위에서 작동하도록 할 수 있었습니다: fmap :: (a -&gt; b) -&gt; f a -&gt; f b  Applicative functors를 통해 우리는 applicative functor 타입 클래스를 구현한 타입을 가진 여러 인자들을 가진 함수를 끌어올릴 수 있었습니다. 또한 해당 타입으로 어떠한 값을 끌어올릴 수도 있었습니다: pure :: a -&gt; f a liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c  이제 Monad를 통해 우리는 Monad 인터페이스를 구현한 타입들을 펼칠 수 (또는 하스켈 용어로 &quot;join&quot;할 수) 있습니다. join :: m (m a) -&gt; m a -- =&lt;&lt; 의 인자를 반대로 뒤집은 것입니다. &quot;bind&quot;로 발음합니다. (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b  &gt;&gt;=를 사용하면 예제로 소개한 컴파일 파이프라인을 왼쪽에서 오른쪽으로 작성할 수 있습니다. monad에 대해서는 이 방식을 더 자주 사용합니다: &gt; tokenize string &gt;&gt;= parse &gt;&gt;= typecheck  사실 이 함수는 예전에 IO에 대해 소개할 때 이미 사용해 보았습니다. 맞습니다. IO 또한 Monad 인터페이스를 구현합니다.IO의 모나드 인터페이스는 효과의 순서를 구성하는 데 도움이 됩니다. Monad 인터페이스의 핵심은 join/&gt;&gt;= 함수이며, 우리가 &gt;&gt;=를 join으로 구현할 수 있었듯이,join을 &gt;&gt;=로 구현할 수도 있습니다 (한 번 시도해 보세요!). Monad 인터페이스는 타입에 따라 각각 다른 의미를 가질 수 있습니다.IO의 경우 효과의 순서를 의미하고, Either의 경우 조기 종료를 의미하며,Logic에 대해서는 backtracking 계산을 의미합니다. 다시 말하지만, 이론과 비유에 신경쓰지 말고, API와 법칙에 집중하세요. 혹시 Monad 법칙을 확인해 보셨나요? 왼쪽 항등, 오른쪽 항등, 결합성에 대한 내용입니다. 우리는 이미 이러한 법칙을 가진 타입 클래스에 대해 논의했습니다. 바로 Monoid 타입 클래스입니다. 아마도 이것이 유명한 명언과 관련이 있을지도 모릅니다. - monad is just a monoid in the category of endofunctors. ","version":"Next","tagName":"h2"},{"title":"Do 표기법​","type":1,"pageTitle":"Either를 활용한 에러 처리","url":"/learn-haskell-blog-generator/errors_and_files/either#do-표기법","content":"do 표기법을 기억하시나요? 이는 Monad의 인스턴스인 모든 타입에 대해 동작합니다. 다음과 같은 코드를 pipeline :: String -&gt; Either Error TypedAST pipeline string = tokenize string &gt;&gt;= \\tokens -&gt; parse tokens &gt;&gt;= \\ast -&gt; typecheck ast  아래와 같이 작성할 수 있습니다: pipeline :: String -&gt; Either Error TypedAST pipeline string = do tokens &lt;- tokenize string ast &lt;- parse tokens typecheck ast  또한 tokenize string &gt;&gt;= parse &gt;&gt;= typecheck와 같이 특별한 경우에는&gt;=&gt;또는&lt;=&lt;를 사용하여 더 간결하게 작성할 수 있습니다: (&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c -- 함수 합성과 비교해 보세요: (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c  pipeline = tokenize &gt;=&gt; parse &gt;=&gt; typecheck  또는 pipeline = typecheck &lt;=&lt; parse &lt;=&lt; tokenize  추상화를 통해 간결한 코드를 작성할 수 있는 하스켈의 능력은 추상화에 익숙해지면 더욱 더 좋아집니다. Monad 추상화에 대해 알게 되면, 이미 많은 라이브러리들이 사용하는 핵심 조합 API를 빠르게 익힐 수 있습니다. 예를 들면: 동시성과 비동기 프로그래밍웹 프로그래밍테스팅상태 계산 모형계산간의 환경을 공유그 외 ","version":"Next","tagName":"h3"},{"title":"요약​","type":1,"pageTitle":"Either를 활용한 에러 처리","url":"/learn-haskell-blog-generator/errors_and_files/either#요약","content":"에러 처리를 위해 Either를 사용하면 다음과 같은 이점이 있습니다: 타입을 통해 에러를 표현할 수 있습니다. 그리고 사용자가 이러한 에러를 처리하도록 강제할 수 있습니다. 이를 통해 코드는 더욱 견고해지고, 잘못된 동작을 방지할 수 있습니다.Functor, Applicative, Monad 인터페이스를 통해 실패할 수 있는 함수를 조합할 수 있습니다. 이를 통해 보일러 플레이트를 줄이고, 코드에 대한 강력한 보장을 유지하며, 에러를 처리하는 시점을 미룰 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"예외","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/errors_and_files/exceptions","content":"","keywords":"","version":"Next"},{"title":"요약​","type":1,"pageTitle":"예외","url":"/learn-haskell-blog-generator/errors_and_files/exceptions#요약","content":"예외는 IO를 사용할 때 유용하고 때로는 필수적입니다. 이는 프로그램이 오류를 우아하게 처리할 수 있도록 합니다.Either와 달리, 서로 다른 타입의 오류를 던질 수 있는 함수를 쉽게 조합할 수 있지만, 반환값을 통해 타입을 전달하지 않기 때문에 핸들링을 강제하지 않는 단점이 있습니다. 하스켈에서는 언어 설계자들이 IO를 Either 대신 예외를 사용할 수 있는 선택지를 제공해주었습니다. 대부분의 경우 효과를 가진 계산을 다룰 때 추천하는 방법입니다. 하지만 효과가 없는 코드의 경우에는 Either가 더 적절하다고 생각합니다. 왜냐하면 우리가 오류를 인지하고 처리해야 한다는 것을 강제해, 프로그램을 더 견고하게 만들기 때문입니다. 또한 IO 코드에서만 예외를 잡을 수 있기 때문이기도 합니다. ","version":"Next","tagName":"h2"},{"title":"요약","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/errors_and_files/summary","content":"요약 이번 장은 꽤 길었습니다. 배운 것들을 요약해보겠습니다. 우리는 하스켈에서 에러를 다루는 몇 가지 방법을 다루었습니다. 데이터 타입으로 에러를 표현하고 Either 타입을 사용해 &quot;값 또는 에러&quot;를 표현. 부수 효과가 없는 코드에 유용한 접근법입니다.ExceptT를 사용해 monadic 기능을 가진 타입 위에 (1)의 접근법을 조합.IO 코드에 대해 예외를 사용. 우리는 몇 가지 새로운 추상화와 기법도 배웠습니다. Traversable 타입 클래스는 왼쪽에서 오른쪽으로 순회할 수 있는 자료 구조를 위한 것입니다. 링크드 리스트, 이진 트리, Map과 같은 것들이 있습니다.Either나 IO와 같은 다른 applicative functor 타입과 조합하면 유용합니다.Monad 타입 클래스는 Applicative 타입 클래스를 join :: m (m a) -&gt; m a 함수로 확장합니다.Either가 이 타입 클래스 인터페이스를 구현한다는 것을 배웠고 IO도 마찬가지입니다.MonadTrans 타입 클래스는 monad transformer로 다른 모나드를 입력으로 받고 monadic 인터페이스(&gt;&gt;=, do 표기법 등)를 제공하면서 두 기능을 결합합니다.IO 위에 Either와 비슷한 monad transformer인 ExceptT를 쌓는 방법을 배웠습니다. 거의 다 왔습니다. 이 프로젝트를 마무리 하기위해 몇 가지 남은 것들만 처리하면 됩니다. Git 커밋을 통해이번에 수정한 내역과 현재까지 코드 를 확인할 수 있습니다.","keywords":"","version":"Next"},{"title":"자주 묻는 질문","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/faq","content":"","keywords":"","version":"Next"},{"title":"일반적인 질문​","type":1,"pageTitle":"자주 묻는 질문","url":"/learn-haskell-blog-generator/faq#일반적인-질문","content":"","version":"Next","tagName":"h2"},{"title":"하스켈을 배워야 하는 이유​","type":1,"pageTitle":"자주 묻는 질문","url":"/learn-haskell-blog-generator/faq#하스켈을-배워야-하는-이유","content":"저는 이 주제에 대한 몇가지 글을 썼습니다: 하스켈 고려하기 (대체 제목, '하스켈로 무엇을 할 수 있나요?')하스켈을 통해 배운 7가지 ","version":"Next","tagName":"h3"},{"title":"에디터 도구를 설치하는 방법​","type":1,"pageTitle":"자주 묻는 질문","url":"/learn-haskell-blog-generator/faq#에디터-도구를-설치하는-방법","content":"제가 알기로는, 현재 하스켈 개발을 위해 가장 권장되는 설정은 VSCode 또는 VSCodium을 사용하고하스켈 확장을 설치하는 것입니다. 이 확장은 haskell-language-server를 사용하며, GHCup 또는 하스켈 확장 자체를 통해 설치할 수 있습니다. 만약 선호하는 에디터가 이미 있다면,HLS를 지원하는지 확인하거나, 대안으로 에디터에서 독립적으로 빠른 피드백을 제공하는 GHCid를 사용할 수 있습니다. ","version":"Next","tagName":"h3"},{"title":"새로운 것을 배우는 방법​","type":1,"pageTitle":"자주 묻는 질문","url":"/learn-haskell-blog-generator/faq#새로운-것을-배우는-방법","content":"하스켈 커뮤니티는 매우 활발하며, 새로운 라이브러리, 도구 및 기술을 개발하고 있습니다.하스켈 planetarium은 여러 커뮤니티의 피드를 한 페이지에 모아두었으며,하스켈 주간 뉴스레터도 있습니다. 또한 Fediverse에서도 많은 하스켈 관련 내용을 찾을 수 있습니다! ","version":"Next","tagName":"h3"},{"title":"디버깅​","type":1,"pageTitle":"자주 묻는 질문","url":"/learn-haskell-blog-generator/faq#디버깅","content":"","version":"Next","tagName":"h2"},{"title":"하스켈 코드를 디버깅하는 방법​","type":1,"pageTitle":"자주 묻는 질문","url":"/learn-haskell-blog-generator/faq#하스켈-코드를-디버깅하는-방법","content":"명령형 언어의 대부분은 단계별 디버거를 제공합니다. 반면에 하스켈은GHCi 디버거가 있긴 하지만, 하스켈의 지연 평가 때문에 예상한 순서대로 평가되지 않을 수 있어서 사용하기가 그리 쉽지 않습니다. 그래서 하스켈러들은추적 디버깅과 등식 추론을 활용합니다. 추적 디버깅을 사용하면 코드에 대한 우리의 가정을 검증해볼 수 있습니다. 코드의 어디서든 변수, 함수 입력, 함수 출력을 출력하거나 단순히 &quot;이곳에 도달했다&quot;는 정보를 확인할 수 있습니다. 예상하지 못한 함수의 입력과 출력과 같은 우리의 가정을 위반하는 것을 찾으면, 우리는 코드의 어느 부분에 문제가 있는지 파악하거나 추적 디버깅을 다시 사용하여 정확한 위치를 찾을 수 있습니다. 그리고 우리의 추론과 벗어난 코드를 평가하기 위해 &quot;등식 추론&quot;을 사용할 수 있습니다. 만약 쉽게 할 수 있다면, ghci에서 함수에 다른 입력을 전달해 우리의 가정을 확인할 수도 있습니다. 하스켈은 불변성, 합성 가능성, 타입을 사용하여 많은 오류를 제거합니다. 이는 &quot;지역 추론&quot;을 가능하게 하고, 추적 디버깅이 하스켈 프로그램을 디버깅하는 데 유용하도록 만듭니다. ","version":"Next","tagName":"h3"},{"title":"타입 에러를 이해하는 방법​","type":1,"pageTitle":"자주 묻는 질문","url":"/learn-haskell-blog-generator/faq#타입-에러를-이해하는-방법","content":"GHC 타입 에러는 종종 친절하지 못한 메시지를 출력하지만 최대한 도움을 주려고 노력합니다! 그들은 우리가 코드에서 일관성을 유지하도록 도와줍니다 - 보통 타입 사용과 관련된 것들로 인해, 우리가 실수를 하지 않도록 도와줍니다. 만약 에러 메시지를 만난다면, 익숙해질 때 까지 자세히 읽어보고, 에러 메시지가 암시하는 문제 코드도 읽어보세요. 경험이 쌓이면, 에러의 가장 중요한 부분은 문제가 발생한 코드의 위치일 것이고, 코드를 읽어보면 에러 메시지 없이도 문제를 찾을 수 있을 것입니다. 타입에 대한 이해를 시험하기 위해 타입 시그니처과 주석을 추가하는 것도 큰 도움이 됩니다. 또는 typed holes를 사용하여 특정 위치에서 예상되는 타입을 GHC를 통해 확인할 수도 있습니다. ","version":"Next","tagName":"h3"},{"title":"프로젝트가 느린 이유​","type":1,"pageTitle":"자주 묻는 질문","url":"/learn-haskell-blog-generator/faq#프로젝트가-느린-이유","content":"프로젝트가 느린 이유는 다양할 수 있습니다. 일반 연산의 시간 복잡도에 관해 비효율적인 알고리즘을 사용하거나,부적절한 자료구조를 사용했을 수 있습니다. 또는 덜 효율적인 메모리 표현(Text 대신 String 사용하기)을 사용했거나, 게으름 문제(이번에도 평가 전략!)도 있을 수 있습니다. 제 Haskell study plan에 있는performance 섹션에는 하스켈 평가, 프로파일링 및 사례 연구에 대한 다양한 자료가 있습니다. ","version":"Next","tagName":"h3"},{"title":"디자인​","type":1,"pageTitle":"자주 묻는 질문","url":"/learn-haskell-blog-generator/faq#디자인","content":"","version":"Next","tagName":"h2"},{"title":"프로그램 구조를 설계하는 방법​","type":1,"pageTitle":"자주 묻는 질문","url":"/learn-haskell-blog-generator/faq#프로그램-구조를-설계하는-방법","content":"먼저 기능적 코어 명령형 쉘 접근법을 사용하여 시작하세요. 이후 로직을 위한 조합자 패턴으로 EDSL을 정의하고, 필요한 경우 State와 같은 기능을 지역적으로 사용하고,ReaderT를 통해 환경 설정을 추가하면서 어떻게 변화하는지 살펴보세요. 만약 이러한 접근법이 실패한다면, 왜 실패했는지 살펴보고, 필요한 경우 다른 접근법을 살펴보세요. ","version":"Next","tagName":"h3"},{"title":"데이터를 모델링하는 방법​","type":1,"pageTitle":"자주 묻는 질문","url":"/learn-haskell-blog-generator/faq#데이터를-모델링하는-방법","content":"ADT를 사용하여 데이터를 모델링하는 것이 일반적으로 가장 좋은 방법입니다. 객체 지향 프로그래머들은 종종 타입 클래스를 사용하여 상속과 유사한 메서드를 정의하려고 합니다. 하지만 이는 종종 올바른 접근법이 아니며, 다양한 상황을 위해 다른 생성자를 가진 ADT가 더 좋을 수 있습니다. OOP 사람들도 종종 상속보다는 합성을 추구하는 걸 명심하세요. 데이터와 행위를 묶기보다는, 데이터에 대한 행위를 정의하기 위해 함수를 사용하세요. ","version":"Next","tagName":"h3"},{"title":"통합하기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/glue","content":"통합하기 이번 장에서는 우리가 만든 조각들을 서로 붙여서 실제 블로그 생성기를 만들어 보겠습니다. 다음과 같은 작업을 할 것입니다: 파일에서 마크업 텍스트 읽어오기텍스트를 Document로 파싱하기결과를 Html EDSL로 변환하기HTML 코드 생성하기파일에 쓰기 이를 수행하면서 다음과 같은 내용을 배우게 될 것입니다: IO 작업을 수행하는 방법외부 라이브러리를 가져와서 디렉토리 전체를 처리하고 간단한 명령줄 인터페이스를 만드는 방법","keywords":"","version":"Next"},{"title":"코드를 작성해봅시다!","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/errors_and_files/implementation","content":"","keywords":"","version":"Next"},{"title":"새로운 모듈​","type":1,"pageTitle":"코드를 작성해봅시다!","url":"/learn-haskell-blog-generator/errors_and_files/implementation#새로운-모듈","content":"먼저 HsBlog.Directory라는 새로운 모듈을 만들겠습니다. 이 모듈은 디렉터리와 여러 파일을 처리할 것입니다. 이 모듈에서는 이전에 정의한 convertDirectory와 buildIndex 함수를 내보낼 것입니다. -- | 여러 파일을 처리하고 디렉토리를 변환합니다 module HsBlog.Directory ( convertDirectory , buildIndex ) where  이 모듈에서는 디렉터리, 파일 및 파일 경로를 조작하는 데 사용할directory와 filepath라이브러리를 사용합니다. 우리가 배운 새로운 추상화인 Traversable와 Monad, 그리고 이전에 배운 개념과 타입인 Either, IO 및 예외를 사용할 것입니다. 이를 위해, 꽤 많은 모듈이 필요합니다: import qualified HsBlog.Markup as Markup import qualified HsBlog.Html as Html import HsBlog.Convert (convert, convertStructure) import Data.List (partition) import Data.Traversable (for) import Control.Monad (void, when) import System.IO (hPutStrLn, stderr) import Control.Exception (catch, displayException, SomeException(..)) import System.Exit (exitFailure) import System.FilePath ( takeExtension , takeBaseName , (&lt;.&gt;) , (&lt;/&gt;) , takeFileName ) import System.Directory ( createDirectory , removeDirectoryRecursive , listDirectory , doesDirectoryExist , copyFile )  이번에 사용할 각 함수들이 어떤 역할을 하는지 확실하지 않다면 Hoogle을 참고하세요. 타입 시그니처와 문서를 읽고 ghci에서 실험해보세요. ","version":"Next","tagName":"h2"},{"title":"디렉터리 변환하기​","type":1,"pageTitle":"코드를 작성해봅시다!","url":"/learn-haskell-blog-generator/errors_and_files/implementation#디렉터리-변환하기","content":"먼저 다른 작은 함수들을 캡술화한 고차 함수인 convertDirectory의 설명으로 시작하겠습니다.convertDirectory는 꽤 명령형적인 모습을 하고 있으며, 우리가 해야할 작업을 다른 방식으로 설명하는 것처럼 보입니다. -- | 특정 디렉터리의 파일을 다른 디렉터리로 복사하고, '.txt' 파일을 '.html' 파일로 변환합니다. -- 읽기나 쓰기에 실패한 경우 stderr에 기록합니다. -- -- 출력 디렉터리 생성중에 예외가 발생할 수 있습니다. convertDirectory :: FilePath -&gt; FilePath -&gt; IO () convertDirectory inputDir outputDir = do DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir createOutputDirectoryOrExit outputDir let outputHtmls = txtsToRenderedHtml filesToProcess copyFiles outputDir filesToCopy writeFiles outputDir outputHtmls putStrLn &quot;Done.&quot;  여기서 우리는 각 IO 함수가 에러를 적절하게 처리하고, 필요할 때 프로젝트를 종료한다고 가정했습니다. 이제 단계별로 살펴보겠습니다. ","version":"Next","tagName":"h2"},{"title":"getDirFilesAndContent​","type":1,"pageTitle":"코드를 작성해봅시다!","url":"/learn-haskell-blog-generator/errors_and_files/implementation#getdirfilesandcontent","content":"-- | 애플리케이션에 필요한 디렉터리 내용 data DirContents = DirContents { dcFilesToProcess :: [(FilePath, String)] -- ^ 파일 경로와 그 내용 , dcFilesToCopy :: [FilePath] -- ^ Other file paths, to be copied directly -- ^ 다른 파일 경로, 직접 복사될 것 } -- | 디렉터리 내용을 반환합니다 getDirFilesAndContent :: FilePath -&gt; IO DirContents  getDirFilesAndContent는 처리를 위한 연관도니 파일들을 제공하는 역할을 합니다. -- 마크업으로 변환해야 할 파일(그리고 그들의 텍스트 내용)과 이미지나 스타일시트와 같이 그대로 복사할 다른 파일들입니다. -- | 디렉터리 내용을 반환합니다 getDirFilesAndContent :: FilePath -&gt; IO DirContents getDirFilesAndContent inputDir = do files &lt;- map (inputDir &lt;/&gt;) &lt;$&gt; listDirectory inputDir let (txtFiles, otherFiles) = partition ((== &quot;.txt&quot;) . takeExtension) files txtFilesAndContent &lt;- applyIoOnList readFile txtFiles &gt;&gt;= filterAndReportFailures pure $ DirContents { dcFilesToProcess = txtFilesAndContent , dcFilesToCopy = otherFiles }  이 함수는 네 가지 중요한 일을 합니다: 디렉터리 내의 모든 파일을 나열합니다파일들을 확장자에 따라 두 그룹으로 나눕니다.txt 파일의 내용을 읽고, 파일을 읽는 데 실패한 경우 보고합니다결과를 반환합니다. 결과를 더 명확하게 하기 위해 데이터 타입을 정의했습니다. (3)번은 나머지보다 조금 더 복잡합니다. 이를 살펴보겠습니다. applyIoOnList​  applyIoOnList는 다음과 같은 타입 시그니처를 가집니다: applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)]  이 함수는 IO 함수를 특정 값들의 리스트에 적용하고, 성공과 실패를 기록합니다. 한 번 구현해보세요! 어떤 함수를 사용해야 할지 힌트가 필요하다면, 이전에 작성한 가져오기 목록을 참고하세요. 정답 -- | IO 함수를 값들의 리스트에 적용하고, 성공과 실패를 기록합니다 applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)] applyIoOnList action inputs = do for inputs $ \\input -&gt; do maybeResult &lt;- catch (Right &lt;$&gt; action input) ( \\(SomeException e) -&gt; do pure $ Left (displayException e) ) pure (input, maybeResult)   applyIoOnList는 특정 IO 함수를(이번 경우 readFile) 특정 값들의 리스트(이번 경우 FilePath)에 적용하는 고차 함수입니다. 각 요소에 대해, 요소 그 자체와 IO 함수를 적용한 결과를 Either로 변환한 값을 함께 반환합니다. 여기서 Left 타입은 String으로, 에러를 나타냅니다. 이 함수의 타입 만으로도 함수가 어떤 일을 할지에 대해 많은 것을 알 수 있습니다. 타입이 다형적이기 때문에, a에 대해 할 수 있는 일은 함수에 적용하는 것 뿐이고, b를 생성할 수 있는 곳은 함수의 결과뿐입니다. 노트 이 함수를 처음 작성할 때는 readFile에만 특화되어 있었고, [FilePath]를 받아 IO [(FilePath, Either String String)]를 반환했습니다. 하지만 추후에 다른 사용 사례를 만나게 되었고(writeFiles와 copyFiles), action, 입력 타입, 반환 타입을 분리했습니다. 이 함수는 에러를 처리하기 위해 예외를 사용하고, Either를 사용해 성공과 실패를 모두 타입 시스템에 표현합니다. 이를 통해 예외 처리를 함수 호출자에게 미룸과 동시에 호출자가 예외 처리를 잊지 않도록 하였습니다! 다음에는, 에러를 보고하고 실패하는 모든 경우를 필터링하는 함수를 살펴보겠습니다. filterAndReportFailures​  filterAndReportFailures는 다음과 같은 타입 시그니처를 가집니다: filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)]  파일에 대한 작업의 실패를 필터링하고, stderr에 에러를 보고합니다. 한 번 구현해보세요! 정답 -- | 파일에 대한 작업의 실패를 필터링하고, stderr에 에러를 보고합니다. filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)] filterAndReportFailures = foldMap $ \\(file, contentOrErr) -&gt; case contentOrErr of Left err -&gt; do hPutStrLn stderr err pure [] Right content -&gt; pure [(file, content)] 이 코드는 조금 놀라울 수 있습니다 - 어떻게 foldMap을 사용할 수 있을까요? 기억을 떠올려보면, foldMap의 타입은 다음과 같습니다: foldMap :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m 이 함수의 일반적인 타입을 이번 예제에서 사용한 타입으로 치환해서 생각해보면 IO [(a, b)]는 monoid라는 것을 알 수 있습니다. - [a]는 임의의 a에 대해 [](빈 리스트)를 mempty로, ++를 &lt;&gt;로 사용하는 monoid이며,IO a는 임의의 a가 monoid일 때 pure mempty를 mempty로, liftA2 (&lt;&gt;)를 &lt;&gt;로 사용하는 monoid입니다! 만약 당신이 다른 방식으로 같은 동작을 하는 코드를 작성했다면, 그것도 괜찮습니다! 때때로 추상화를 사용해 더 간결한 코드를 작성할 수 있다는 점만 기억하시면 됩니다.  이러한 함수들은 유효한 정보를 가져오는 데 사용됩니다. 다음으로, 새 디렉토리를 만드는 코드를 살펴보겠습니다. ","version":"Next","tagName":"h3"},{"title":"createOutputDirectoryOrExit​","type":1,"pageTitle":"코드를 작성해봅시다!","url":"/learn-haskell-blog-generator/errors_and_files/implementation#createoutputdirectoryorexit","content":"-- | 출력 디렉터리를 생성하고 실패하면 프로그램을 종료합니다. createOutputDirectoryOrExit :: FilePath -&gt; IO () createOutputDirectoryOrExit outputDir = whenIO (not &lt;$&gt; createOutputDirectory outputDir) (hPutStrLn stderr &quot;Cancelled.&quot; *&gt; exitFailure) -- | 출력 디렉터리를 생성합니다. -- 디렉터리가 생성되었는지 여부를 반환합니다. createOutputDirectory :: FilePath -&gt; IO Bool createOutputDirectory dir = do dirExists &lt;- doesDirectoryExist dir create &lt;- if dirExists then do override &lt;- confirm &quot;Output directory exists. Override?&quot; when override (removeDirectoryRecursive dir) pure override else pure True when create (createDirectory dir) pure create  createOutputDirectoryOrExit는 이름 그대로의 일을 합니다 - 출력 디렉터리를 생성하고, 실패하면 프로그램을 종료합니다. createOutputDirectory는 사실 꽤 많은 작업을 수행하는 함수입니다. 디렉터리가 이미 존재하는지 확인하고, 사용자가 덮어쓰기를 원하는지 확인합니다. 만약 덮어쓰기를 원한다면, 디렉터리를 삭제하고 새 디렉터리를 생성합니다. 만약 덮어쓰기를 원하지 않는다면, 아무것도 하지 않고 사용자의 결정을 반환합니다. ","version":"Next","tagName":"h3"},{"title":"txtsToRenderedHtml​","type":1,"pageTitle":"코드를 작성해봅시다!","url":"/learn-haskell-blog-generator/errors_and_files/implementation#txtstorenderedhtml","content":"let outputHtmls = txtsToRenderedHtml filesToProcess   이 코드에서는 파일을 마크업으로 변환하고, 입력 파일 경로를 해당 출력 파일 경로로 변경합니다(.txt -&gt; .html). 그리고 인덱스 페이지를 빌드하고, 모든 것을 HTML로 변환합니다. 다음 타입 시그니처를 가지는 txtsToRenderedHtml 함수를 구현해보세요: txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]  힌트 다음 세 가지 함수를 정의해서 구현할 수 있습니다: txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)] toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document) convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)  정답 -- | 텍스트 파일을 마크업으로 변환하고, 인덱스를 빌드하고, html로 렌더링합니다. txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)] txtsToRenderedHtml txtFiles = let txtOutputFiles = map toOutputMarkupFile txtFiles index = (&quot;index.html&quot;, buildIndex txtOutputFiles) in map (fmap Html.render) (index : map convertFile txtOutputFiles) toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document) toOutputMarkupFile (file, content) = (takeBaseName file &lt;.&gt; &quot;html&quot;, Markup.parse content) convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html) convertFile (file, doc) = (file, convert file doc) 이 코드에서 흥미로울 점은 map (fmap Html.render) 부분입니다. 튜플에 fmap을 사용할 수 있는 이유는, Either처럼 두 번째 인자에 대해 Functor이기 때문입니다.  ","version":"Next","tagName":"h3"},{"title":"copyFiles 과 writeFiles​","type":1,"pageTitle":"코드를 작성해봅시다!","url":"/learn-haskell-blog-generator/errors_and_files/implementation#copyfiles-과-writefiles","content":"이제 남은 작업은 처리가 완료된 후 디렉터리 내용을 새로 생성된 디렉터리에 작성하는 것입니다: -- | 디렉터리에 파일을 복사하고, 오류를 stderr에 기록합니다. copyFiles :: FilePath -&gt; [FilePath] -&gt; IO () copyFiles outputDir files = do let copyFromTo file = copyFile file (outputDir &lt;/&gt; takeFileName file) void $ applyIoOnList copyFromTo files &gt;&gt;= filterAndReportFailures  여기서 다시 한 번 applyIoOnList를 사용해서 더 복잡한 작업을 수행합니다. 파일을 읽는 대신, 입력 경로에서 새로 생성된 출력 경로로 복사합니다. 그리고 결과([(FilePath, Either String ())] 타입)를 filterAndReportFailures에 전달해서 오류를 출력하고, 복사에 실패한 것들을 필터링합니다.filterAndReportFailures의 반환값에는 관심이 없기 때문에, void를 사용해서 버립니다. 그리고 ()를 반환합니다: -- | Write files to a directory, recording errors to stderr. writeFiles :: FilePath -&gt; [(FilePath, String)] -&gt; IO () writeFiles outputDir files = do let writeFileContent (file, content) = writeFile (outputDir &lt;/&gt; file) content void $ applyIoOnList writeFileContent files &gt;&gt;= filterAndReportFailures  이 코드는 타입이 다르다는 점을 제외하면 copyFiles와 거의 동일합니다. 하스켈의 매개변수 다형성과 추상화를 위한 타입 클래스의 조합은 정말 강력하고, 많은 코드를 줄일 수 있습니다.  applyIoOnList를 호출하고 이후에 filterAndReportFailures를 호출하는 패턴이 다시 한 번 나왔습니다. 이는 리팩토링의 후보가 될 수 있습니다. 한 번 시도해보세요! 작성한 코드에 대해 어떻게 생각하시나요? 이전보다 이해하기 쉽나요? 더 모듈화되었나요? 장단점은 무엇인가요?  ","version":"Next","tagName":"h3"},{"title":"요약​","type":1,"pageTitle":"코드를 작성해봅시다!","url":"/learn-haskell-blog-generator/errors_and_files/implementation#요약","content":"이제 우리는 디렉터리를 안전하게 변환하는 역할을 하는 HsBlog.Directory 모듈을 완성했습니다. 코드는 아마도 오류가 전체 프로그램을 충돌시키는 것을 허용한다면 훨씬 더 단순화될 수 있었을 것입니다. 하지만 때때로 이는 견고함을 위해 지불해야 하는 대가입니다. 어떤 것을 허용할 수 있는지, 그리고 어떤 것을 허용할 수 없는지 선택하는 것은 여러분에게 달렸습니다. 지금까지의 여정이 하스켈에서 에러 처리를 어떻게 접근해야 하는지에 대해 배울 수 있었기를 바랍니다. 전체 모듈 코드: HsBlog.Directory -- | 여러 파일을 처리하고 디렉토리를 변환합니다 module HsBlog.Directory ( convertDirectory , buildIndex ) where import qualified HsBlog.Markup as Markup import qualified HsBlog.Html as Html import HsBlog.Convert (convert, convertStructure) import Data.List (partition) import Data.Traversable (for) import Control.Monad (void, when) import System.IO (hPutStrLn, stderr) import Control.Exception (catch, displayException, SomeException(..)) import System.Exit (exitFailure) import System.FilePath ( takeExtension , takeBaseName , (&lt;.&gt;) , (&lt;/&gt;) , takeFileName ) import System.Directory ( createDirectory , removeDirectoryRecursive , listDirectory , doesDirectoryExist , copyFile ) -- | 특정 디렉터리의 파일을 다른 디렉터리로 복사하고, '.txt' 파일을 '.html' 파일로 변환합니다. -- 읽기나 쓰기에 실패한 경우 stderr에 기록합니다. -- -- 출력 디렉터리 생성중에 예외가 발생할 수 있습니다. convertDirectory :: FilePath -&gt; FilePath -&gt; IO () convertDirectory inputDir outputDir = do DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir createOutputDirectoryOrExit outputDir let outputHtmls = txtsToRenderedHtml filesToProcess copyFiles outputDir filesToCopy writeFiles outputDir outputHtmls putStrLn &quot;Done.&quot; ------------------------------------ -- * 디렉터리 내용 읽기 -- | 디렉터리 내용을 반환합니다 getDirFilesAndContent :: FilePath -&gt; IO DirContents getDirFilesAndContent inputDir = do files &lt;- map (inputDir &lt;/&gt;) &lt;$&gt; listDirectory inputDir let (txtFiles, otherFiles) = partition ((== &quot;.txt&quot;) . takeExtension) files txtFilesAndContent &lt;- applyIoOnList readFile txtFiles &gt;&gt;= filterAndReportFailures pure $ DirContents { dcFilesToProcess = txtFilesAndContent , dcFilesToCopy = otherFiles } -- | 애플리케이션에 필요한 디렉터리 내용 data DirContents = DirContents { dcFilesToProcess :: [(FilePath, String)] -- ^ File paths and their content , dcFilesToCopy :: [FilePath] -- ^ Other file paths, to be copied directly } ------------------------------------ -- * 인덱스 페이지 생성 buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html buildIndex files = let previews = map ( \\(file, doc) -&gt; case doc of Markup.Heading 1 heading : article -&gt; Html.h_ 3 (Html.link_ file (Html.txt_ heading)) &lt;&gt; foldMap convertStructure (take 2 article) &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;)) _ -&gt; Html.h_ 3 (Html.link_ file (Html.txt_ file)) ) files in Html.html_ &quot;Blog&quot; ( Html.h_ 1 (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;)) &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;) &lt;&gt; mconcat previews ) ------------------------------------ -- * 변환 -- | 텍스트 파일을 마크업으로 변환하고, 인덱스를 빌드하고, html로 렌더링합니다. txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)] txtsToRenderedHtml txtFiles = let txtOutputFiles = map toOutputMarkupFile txtFiles index = (&quot;index.html&quot;, buildIndex txtOutputFiles) in map (fmap Html.render) (index : map convertFile txtOutputFiles) toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document) toOutputMarkupFile (file, content) = (takeBaseName file &lt;.&gt; &quot;html&quot;, Markup.parse content) convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html) convertFile (file, doc) = (file, convert file doc) ------------------------------------ -- * 디렉터리에 출력 -- | 출력 디렉터리를 생성하고 실패하면 프로그램을 종료합니다. createOutputDirectoryOrExit :: FilePath -&gt; IO () createOutputDirectoryOrExit outputDir = whenIO (not &lt;$&gt; createOutputDirectory outputDir) (hPutStrLn stderr &quot;Cancelled.&quot; *&gt; exitFailure) -- | 출력 디렉터리를 생성합니다. -- 디렉터리가 생성되었는지 여부를 반환합니다. createOutputDirectory :: FilePath -&gt; IO Bool createOutputDirectory dir = do dirExists &lt;- doesDirectoryExist dir create &lt;- if dirExists then do override &lt;- confirm &quot;Output directory exists. Override?&quot; when override (removeDirectoryRecursive dir) pure override else pure True when create (createDirectory dir) pure create -- | 디렉터리에 파일을 복사하고, 오류를 stderr에 기록합니다. copyFiles :: FilePath -&gt; [FilePath] -&gt; IO () copyFiles outputDir files = do let copyFromTo file = copyFile file (outputDir &lt;/&gt; takeFileName file) void $ applyIoOnList copyFromTo files &gt;&gt;= filterAndReportFailures -- | Write files to a directory, recording errors to stderr. writeFiles :: FilePath -&gt; [(FilePath, String)] -&gt; IO () writeFiles outputDir files = do let writeFileContent (file, content) = writeFile (outputDir &lt;/&gt; file) content void $ applyIoOnList writeFileContent files &gt;&gt;= filterAndReportFailures ------------------------------------ -- * IO 작업과 오류 처리 -- | IO 함수를 값들의 리스트에 적용하고, 성공과 실패를 기록합니다 applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)] applyIoOnList action inputs = do for inputs $ \\input -&gt; do maybeResult &lt;- catch (Right &lt;$&gt; action input) ( \\(SomeException e) -&gt; do pure $ Left (displayException e) ) pure (input, maybeResult) -- | 파일에 대한 작업의 실패를 필터링하고, stderr에 에러를 보고합니다. filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)] filterAndReportFailures = foldMap $ \\(file, contentOrErr) -&gt; case contentOrErr of Left err -&gt; do hPutStrLn stderr err pure [] Right content -&gt; pure [(file, content)] ------------------------------------ -- * 유틸리티 confirm :: String -&gt; IO Bool confirm question = do putStrLn (question &lt;&gt; &quot; (y/n)&quot;) answer &lt;- getLine case answer of &quot;y&quot; -&gt; pure True &quot;n&quot; -&gt; pure False _ -&gt; do putStrLn &quot;잘못된 응답입니다. y 또는 n을 사용하세요.&quot; confirm question whenIO :: IO Bool -&gt; IO () -&gt; IO () whenIO cond action = do result &lt;- cond if result then action else pure ()  ","version":"Next","tagName":"h2"},{"title":"IO 다루기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/glue/io","content":"","keywords":"","version":"Next"},{"title":"순수 함수형 언어​","type":1,"pageTitle":"IO 다루기","url":"/learn-haskell-blog-generator/glue/io#순수-함수형-언어","content":"하스켈은 원래 비엄격적 의미론(non-strict semantics)을 가진 오픈 표준(open standard) 함수형 언어로 설계되었습니다. 이는 미래의 함수형 언어 설계 연구를 위한 통합 언어로 사용하기 위해 만들어졌습니다. GHC에서는, 비엄격적 의미론을 구현하기 위해 지연 평가(lazy evaluation) 전략을 사용합니다. (지연 평가에 대해서는 이전 장에서 다루었습니다.) 비엄격적 의미론을 위한 요구사항을 충족하고자 한다면 다음과 같은 고민을 해야 합니다: 어떻게 하면 단순히 표현식을 평가하는 것 이상의 일을 할 수 있는 언어를 설계할 수 있을지어떻게 하면 외부 세계와 상호작용을 모델링할 수 있을지어떻게 하면 I/O를 다룰지 지연평가 전략을 가진 언어에서 I/O 연산을 한다는 것은, 프로그램이 점점 커질 때, 평가 순서를 파악하기가 더욱 어려워진다는 것을 의미합니다. 다음과 같은 가상의 코드 예제를 생각해 봅시다 (실제로는 하스켈에서는 타입 에러가 발생합니다. 그 이유는 곧 알아보겠습니다): addWithInput :: Int -&gt; Int addWithInput n = readIntFromStdin + n main = let result1 = addWithInput 1 result2 = addWithInput 2 in print (result2 - result1)  이 가상의 프로그램은 표준 입력에서 두 개의 정수를 읽은 다음, 두 번째 정수(+2)에서 첫 번째 정수(+1)를 뺀 결과를 출력합니다. 만약 이 프로그램이 엄격한 언어라면, 우리는 연산 순서가 위에서 아래로 일어날 것이라고 예상할 수 있습니다. 하지만 지연 평가를 사용하는 언어에서는, 표현식의 결과가 필요해질 때까지 평가를 미룹니다. 따라서 result1과 result2는 둘 다 뺄셈 결과를 출력할 때까지 평가되지 않습니다. 그리고 뺄셈을 평가할 때, 두 인자를 왼쪽에서 오른쪽으로 평가합니다. 그래서 result2가 먼저 평가됩니다. result2를 평가하기 위해, addWithInput 함수에서 n을 2로 치환한 다음, 최상위 함수인 +를 평가합니다. 그리고 그 인자들을 평가합니다. 즉 readIntFromStdin과 n을 평가하는데, 이때 표준 입력에서 첫 번째 정수를 읽습니다. 평가 완료되면, result1의 평가로 넘어가며 표준 입력에서 두 번째 정수를 읽습니다. 이는 우리가 원하는 것과 정반대의 결과입니다! 이처럼, 지연 평가는 부작용(side effect)이 있는 코드를 다루기가 어렵습니다. 부작용이 있는 코드는 외부 세계에 영향을 줄 수 있거나, 외부 세계에 영향을 받을 수 있습니다. 이는 가변 메모리를 읽거나 쓰거나, I/O 연산을 수행하는 것을 포함합니다. 우리는 addWithInput과 같은 부작용이 있는 함수를 호출했으며, 이를 비순수 함수(impure function)라고 합니다. 비순수 함수는 동일한 입력을 받았을 때에도 다른 결과를 반환할 수 있습니다. 비순수 함수의 존재는 지연 평가를 이해하는 것을 더욱 어렵게 만들며, 또한 등식 추론(equational reasoning)을 사용하여 프로그램을 이해하는 것을 방해합니다. 그러므로, 하스켈은 부작용이 없는 순수한 함수와 표현식만을 허용합니다. 순수 함수는 항상 동일한 출력을 반환하며, 순수 표현식을 평가하는 것은 결정론적(deterministic)입니다. 그렇다면 어떻게 I/O 연산을 수행할 수 있을까요? 가능한 해결책은 많습니다. 하스켈에서는 IO라 불리는 인터페이스를 디자인해 이를 해결합니다.IO의 인터페이스는 I/O 표현과 비-I/O 표현을 구분하도록 강제하며, 또한 여러 IO 작업을 결합하기 위해서는 작업 순서를 지정해야 합니다. ","version":"Next","tagName":"h2"},{"title":"IO​","type":1,"pageTitle":"IO 다루기","url":"/learn-haskell-blog-generator/glue/io#io","content":"IO는 Html 타입처럼 사용자에게 내부 표현을 숨기는 불투명 타입(opaque type)입니다. 하지만 이번에는 IO가 모듈이 아닌 하스켈 언어에서 제공하는 내장 타입입니다. Maybe와 유사하게, IO는 IO 연산의 결과를 나타내는 페이로드 타입을 가집니다. 의미있는 결과가 없을 때는, 이를 나타내기 위해 유닛 타입인 ()을 사용합니다. (오직 () 하나만 값으로 가지는 타입입니다.) 다음은 몇 가지 IO 연산과 IO 연산을 반환하는 함수들입니다: putStrLn :: String -&gt; IO () getLine :: IO String getArgs :: IO [String] lookupEnv :: String -&gt; IO (Maybe String) writeFile :: FilePath -&gt; String -&gt; IO ()  더 많은 유용한 IO 함수와 연산은 base 패키지에 포함된 System.IO 모듈에서 찾을 수 있습니다. 각 함수가 IO &lt;something&gt;을 반환하는 것을 주목하세요. 이것은 무슨 의미일까요? IO a의 의미는 실행될 때 어떤 타입 a의 값을 생성하고, 실행 중에 I/O 효과를 가질 수 있는 프로그램(또는 서브루틴)의 설명입니다. IO a를 실행한다는 것과 평가한다는 것은 서로 다릅니다.IO a 표현식을 평가하는 것은 순수한 연산입니다 - 평가는 항상 동일한 프로그램의 설명으로 대체될 수 있습니다. 이는 순수성과 등식 추론을 유지하는 데 도움이 됩니다! 하스켈 런타임은 IO 작업이 실행되도록 하기 위해 프로그램의 진입점인 main 표현식(타입 IO ()을 가져야 함)을 실행합니다. 이를 위해 IO 작업은 main 표현식에 결합되어야 합니다. 이게 어떤 의미인지 살펴보겠습니다. ","version":"Next","tagName":"h2"},{"title":"IO 표현식을 결합하기​","type":1,"pageTitle":"IO 다루기","url":"/learn-haskell-blog-generator/glue/io#io-표현식을-결합하기","content":"Html.Structure 처럼, IO 인터페이스는 작은 IO 연산을 결합하여 더 큰 IO 연산을 만드는 결합자(combinator)를 제공합니다. 이 인터페이스는 또한 연산의 순서가 잘 정의되어 있는지를 보장합니다! Html.Structure를 위한 &lt;&gt; 연산자를 정의했던 것처럼, IO를 위한 결합자는 특정한 타입에 특화된 변형이 아니라 타입클래스 인스턴스(type-class instance)로 구현됩니다. (예를 들어 append_ 함수는 Structure에만 맞춰진 &lt;&gt;의 특수한 버전이었습니다). 이번 장에서는 특수한 타입 시그니처를 먼저 소개할 것입니다. 이는 툭수한 타입을 소개하는 것이 이해하기 쉬울 것이라고 생각하기 때문입니다. 하지만 이후 일반적인 버전에 대해서도 설명할 예정입니다. ","version":"Next","tagName":"h2"},{"title":">>=","type":1,"pageTitle":"IO 다루기","url":"/learn-haskell-blog-generator/glue/io##","content":"첫 번째 결합자는 &gt;&gt;=(bind) 입니다. 이는 가장 유용한 결합자입니다: (&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b  이 결합자는 두 개의 인자를 받습니다. 첫 번째는 IO 연산이며, 두 번째는 첫 번째 IO 연산의 결과를 받아 새로운 IO b를 반환하는 함수입니다. 위 함수를 사용하는 몇 가지 예제를 살펴보겠습니다: Echo getLine &gt;&gt;= (\\line -&gt; putStrLn line) &gt;&gt;=의 왼쪽의 getLine을 통해 표준입력으로부터 한 줄을 읽습니다. 이후 해당 입력은 &gt;&gt;=의 오른쪽의 람다 함수의 인자로 전달됩니다. 그리고 람다 함수가 실행되어 표준출력으로 해당 입력을 출력합니다.&gt;&gt;=의 역할은 왼쪽의 IO 연산의 결과를 오른쪽의 IO 연산을 반환하는 함수의 인자로 전달하는 것입니다. &gt;&gt;=는 연산의 순서를 정의합니다 - 왼쪽에서 오른쪽으로 실행됩니다. 각 하위 표현식의 타입은 다음과 같습니다: getLine :: IO String putStrLn :: String -&gt; IO () (&gt;&gt;=) :: IO String -&gt; (String -&gt; IO ()) -&gt; IO () line :: String 질문: 전체 표현식의 타입은 무엇일까요? Answer IO () 이 예제는 getLine &gt;&gt;= putStrLn 처럼 좀 더 간결한 형태인 포인트프리 스타일로 작성할 수 있습니다. 두 입력을 합하기 getLine &gt;&gt;= (\\honorific -&gt; getLine &gt;&gt;= (\\name -&gt; putStrLn (&quot;Hello &quot; ++ honorific ++ &quot; &quot; ++ name))) 이 서브루틴은 여러 연산을 결합합니다. 표준입력으로부터 두 줄을 읽고, 인사말을 출력합니다. &gt;&gt;= 를 사용해서 연산이 왼쪽에서 오른쪽으로 실행되도록 합니다.하스켈의 범위 규칙에 의해 honorific은 가장 안쪽의 함수에서도 사용할 수 있습니다. 위 코드는 약간 읽기 불편하기에, 괄호를 제거하고 들여쓰기를 추가해서 읽기 쉽게 만들 수 있습니다: getLine &gt;&gt;= \\honorific -&gt; getLine &gt;&gt;= \\name -&gt; putStrLn (&quot;Hello &quot; ++ honorific ++ &quot; &quot; ++ name)  더 많은 결합자를 살펴보겠습니다! ","version":"Next","tagName":"h3"},{"title":"*> 와 >>​","type":1,"pageTitle":"IO 다루기","url":"/learn-haskell-blog-generator/glue/io#-와-","content":"(*&gt;) :: IO a -&gt; IO b -&gt; IO b (&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b  *&gt;와 &gt;&gt;는 IO에 대해 같은 타입 시그니처를 가지며 같은 의미를 가집니다. 사실, *&gt;는 &gt;&gt;의 약간 더 일반화된 버전으로 항상 &gt;&gt; 대신에 사용할 수 있습니다.&gt;&gt;는 이전 버전과의 호환성을 위해 남아있는 것입니다. *&gt;는 첫 번째 IO 연산을 실행하고, 그 결과를 버립니다. 이후 두 번째 연산을 실행합니다. 이 함수는 &gt;&gt;=를 사용해서 구현할 수 있습니다: a *&gt; b = a &gt;&gt;= \\_ -&gt; b  이 결합자는 putStrLn처럼 유의미한 결과를 반환하지 않는 여러 IO 연산을 순서대로 실행할 때 유용합니다. putStrLn &quot;hello&quot; *&gt; putStrLn &quot;world&quot;  ","version":"Next","tagName":"h3"},{"title":"pure 와 return​","type":1,"pageTitle":"IO 다루기","url":"/learn-haskell-blog-generator/glue/io#pure-와-return","content":"pure :: a -&gt; IO a  *&gt;와 &gt;&gt;처럼, pure은 return은 더 일반화된 버전입니다.pure는 다른 언어의 관련 없는 키워드와 유사하지 않다는 장점이 있습니다. IO a는 프로그램의 설명이며, 실행될 때 a 타입의 값을 생성하고, 실행 중에 I/O 효과를 가질 수 있다는 것을 기억하시나요? pure를 사용하면, I/O를 하지 않는 IO a를 만들 수 있습니다. 이 IO a는 실행 시 특정 타입 a의 값을 생성합니다. pure에 전달한 값입니다! 이 함수는 IO에 의존하지만 효과가 없는 계산이 필요할 때 유용합니다. 예제: confirm :: IO Bool confirm = putStrLn &quot;Are you sure? (y/n)&quot; *&gt; getLine &gt;&gt;= \\answer -&gt; case answer of &quot;y&quot; -&gt; pure True &quot;n&quot; -&gt; pure False _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt; confirm  여기서 단순히 True나 False를 반환하려 하면 &gt;&gt;=타입으로 인해 에러가 발생합니다: (&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b  예제에서 &gt;&gt;=의 오른쪽(\\answer -&gt; case ...)의 타입은 String -&gt; IO Bool이어야 합니다. 왜냐하면: getLine :: IO String와 &gt;&gt;=의 타입을 통해 a는 String입니다.confirm :: IO Bool으로 인해 b는 Bool입니다. ","version":"Next","tagName":"h3"},{"title":"fmap 과 <$>​","type":1,"pageTitle":"IO 다루기","url":"/learn-haskell-blog-generator/glue/io#fmap-과-","content":"fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b  &lt;$&gt;는 fmap의 중위(infix) 버전입니다. 필요에 따라 사용하면 됩니다. 만약 표준입력으로부터 한 줄을 읽고, 마지막에 !를 붙여서 출력하고 싶다면 어떻게 해야 할까요?&gt;&gt;=와 pure를 사용해서 다음과 같이 작성할 수 있습니다: getLine &gt;&gt;= \\line -&gt; pure (line ++ &quot;!&quot;)  위와 같은 패턴은 fmap을 사용해 통합할 수 있습니다: fmap (\\line -&gt; line ++ &quot;!&quot;) getLine  fmap은 IO 작업에서 반환될 값에 함수를 적용하며, 이를 &quot;매핑(mapping)&quot;이라고도 합니다. (혹시 fmap과 map :: (a -&gt; b) -&gt; [a] -&gt; [b] 사이의 유사성을 눈치채셨나요?) ","version":"Next","tagName":"h3"},{"title":"요약​","type":1,"pageTitle":"IO 다루기","url":"/learn-haskell-blog-generator/glue/io#요약","content":"지금까지 살펴본 IO 결합자들의 목록입니다: -- IO 연산들의 체이닝: 왼쪽 IO 연산의 *결과*를 오른쪽 함수의 인자로 전달합니다. -- &quot;bind&quot;라고 읽습니다. (&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b -- 두 연산을 순서대로 실행하며, 첫 번째 연산의 결과를 버립니다. (*&gt;) :: IO a -&gt; IO b -&gt; IO b -- 특정한 값을 IO 문맥으로 리프트(lift)합니다. I/O 효과를 추가하지는 않습니다. pure :: a -&gt; IO a -- IO 연산의 페이로드 값에 함수를 적용(mapping)합니다. fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b  ","version":"Next","tagName":"h3"},{"title":"IO는 일급​","type":1,"pageTitle":"IO 다루기","url":"/learn-haskell-blog-generator/glue/io#io는-일급","content":"IO의 아름다운 점은 언어에서 완전히 일급(first class)인 구조체이며, Maybe, Either나 Structure와 별반 다르지 않다는 것입니다. 즉 IO를 함수에 전달하거나, 컨테이너에 넣을 수 있습니다.IO는 프로그램의 설명을 나타내며, 어떤 방식으로든 main에 결합하지 않으면 실제로 아무것도 하지 않습니다. 그저 값일 뿐입니다! 다음은 IO 연산을 입력으로 받는 함수의 예입니다: whenIO :: IO Bool -&gt; IO () -&gt; IO () whenIO cond action = cond &gt;&gt;= \\result -&gt; if result then action else pure ()  다음과 같이 사용할 수 있습니다: main :: IO () main = putStrLn &quot;This program will tell you a secret&quot; *&gt; whenIO confirm (putStrLn &quot;IO is actually pretty awesome&quot;) *&gt; putStrLn &quot;Bye&quot;  putStrLn &quot;IO is actually pretty awesome&quot;는 즉시 실행되지 않고, whenIO가 반환하는 것이 무엇인지에 따라 실행됩니다. 그리고 그 결과는 *&gt;와 결합되어 main 표현식의 일부가 됩니다. ","version":"Next","tagName":"h2"},{"title":"IO로 부터 벗어나기?​","type":1,"pageTitle":"IO 다루기","url":"/learn-haskell-blog-generator/glue/io#io로-부터-벗어나기","content":"위에서 살펴본 내용은 하스켈 언어에 큰 영향을 미칩니다.Html 타입에서, 우리는 Html을 문자열로 바꿀 수 있는 render :: Html -&gt; String 함수를 가지고 있었습니다. 하스켈에서는 순수성과 등식추론을 유지하기 위해 execute :: IO a -&gt; a와 같은 함수를 구현할 수 없습니다! 또한 IO는 불투명합니다. 우리는 IO의 내부를 살펴볼 수 없습니다. 따라서 우리는 IO가 허용하는 하스켈 API만 사용할 수 있습니다. 이는 우리가 IO를 특별하게 사용해야 한다는 것을 의미합니다! 하스켈에서는 한번 IO에 들어가면 더 이상 나오지 못합니다. 할 수 있는 일은 오직 여러 IO 연산들을 결합해서 더 큰 IO 연산을 만드는 것뿐입니다. 또한 IO a는 a로 대체할 수 없습니다. 예를 들어, getLine ++ &quot;!&quot;와 같이 작성할 수 없습니다. 왜냐하면 ++는 양쪽 모두 String이어야 하기 때문입니다. 하지만 getLine의 타입은 IO String이므로 타입이 일치하지 않습니다! 따라서 fmap을 사용해야 하며, 반환 타입은 IO String이어야 합니다. 하스켈에서는 IO 사용을 최소화하고 프로그램의 가장자리로 밀어 넣는 것을 선호합니다. 이 패턴을 흔히 기능적 코어, 명령형 쉘이라고 합니다. ","version":"Next","tagName":"h2"},{"title":"기능적 코어, 명령형 쉘​","type":1,"pageTitle":"IO 다루기","url":"/learn-haskell-blog-generator/glue/io#기능적-코어-명령형-쉘","content":"우리의 블로그 생성기 프로그램에서는 파일을 읽고, 파싱하고, HTML로 변환하며, 결과를 콘솔에 출력하고자 합니다. 많은 프로그래밍 언어에서는 파일로부터 읽는 것과 파싱하는 것을, 콘솔에 출력하는 것과 HTML로 변환하는 것을 번갈아 처리합니다. 하지만 하스켈에서는 이를 분리합니다. 파싱작업은 파일 핸들이 아닌 String 값을 대상으로 하며, Html은 콘솔에 직접 출력하는 대신 String으로 변환합니다. IO를 분리하고 프로그램의 가장자리로 밀어 넣는 방식은 많은 유연성을 제공합니다.IO가 없는 함수는 테스트와 검증이 쉽고, (결정적인 평가를 보장하기 때문입니다!) 더 모듈화되며, 다양한 상황에서 작동할 수 있습니다(표준 입력에서 읽기, 네트워크 소켓에서 읽기, HTTP 응답전송 등). 이러한 패턴은 하스켈 프로그램을 만들 때 자주 사용되며, 특히 배치 프로그램에 적합합니다. ","version":"Next","tagName":"h2"},{"title":"블로그 생성기 만들기​","type":1,"pageTitle":"IO 다루기","url":"/learn-haskell-blog-generator/glue/io#블로그-생성기-만들기","content":"이제 블로그 생성기를 만들어 봅시다. 다음과 같은 인터페이스를 제공하고자 합니다: 사용자가 인자 없이 프로그램을 호출하면, 표준 입력에서 읽고, 표준 출력에 씁니다.사용자가 프로그램을 두 개의 인자와 함께 호출하면, 첫 번째 인자는 입력 파일 이름이 되고, 두 번째 인자는 출력 파일 이름이 됩니다.출력 파일이 이미 존재하는 경우, 사용자에게 덮어쓸 것인지 물어봅니다.그 외 입력의 경우, 올바른 사용법을 설명하는 일반적인 메시지를 출력합니다. 이를 위해 다음과 같은 함수가 필요합니다: getArgs :: IO [String] -- 프로그램 인자를 가져옵니다. getContents :: IO String -- 표준 입력에서 모든 내용을 읽습니다. readFile :: FilePath -&gt; IO String -- 파일의 모든 내용을 읽습니다. writeFile :: FilePath -&gt; String -&gt; IO () -- 문자열을 파일에 씁니다. doesFileExist :: FilePath -&gt; IO Bool -- 파일이 존재하는지 확인합니다.  그리고 다음과 모듈을 가져와야 합니다: import System.Directory (doesFileExist) import System.Environment (getArgs)  다음 가져오기 구문은 Prelude에서 이미 제공하기 때문에 추가할 필요가 없습니다: -- Prelude에서 가져옴 import System.IO (getContents, readFile, writeFile)   문서를 마크업으로 파싱하고, HTML로 변환하고, HTML을 문자열로 렌더링하는 함수를 만듭니다. 이 함수는 process :: Title -&gt; String -&gt; String 형태를 갖습니다. 정답 process :: Html.Title -&gt; String -&gt; String process title = Html.render . convert title . Markup.parse  블로그 생성기를 위한 &quot;명령형 쉘&quot;을 구현하세요.main에서 시작해서, getArgs의 결과를 패턴 매칭하고, 무엇을 할지 결정하세요. 이전 예제를 참고하세요. 정답 -- Main.hs module Main where import qualified Markup import qualified Html import Convert (convert) import System.Directory (doesFileExist) import System.Environment (getArgs) main :: IO () main = getArgs &gt;&gt;= \\args -&gt; case args of -- 인자가 없는경우: 표준 입력에서 읽고, 표준 출력에 씁니다. [] -&gt; getContents &gt;&gt;= \\content -&gt; putStrLn (process &quot;Empty title&quot; content) -- 인자로 입력과 출력 파일 경로가 있는 경우 [input, output] -&gt; readFile input &gt;&gt;= \\content -&gt; doesFileExist output &gt;&gt;= \\exists -&gt; let writeResult = writeFile output (process input content) in if exists then whenIO confirm writeResult else writeResult -- 그 외 입력의 경우 _ -&gt; putStrLn &quot;Usage: runghc Main.hs [-- &lt;input-file&gt; &lt;output-file&gt;]&quot; process :: Html.Title -&gt; String -&gt; String process title = Html.render . convert title . Markup.parse confirm :: IO Bool confirm = putStrLn &quot;Are you sure? (y/n)&quot; *&gt; getLine &gt;&gt;= \\answer -&gt; case answer of &quot;y&quot; -&gt; pure True &quot;n&quot; -&gt; pure False _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt; confirm whenIO :: IO Bool -&gt; IO () -&gt; IO () whenIO cond action = cond &gt;&gt;= \\result -&gt; if result then action else pure ()   ","version":"Next","tagName":"h2"},{"title":"Do 표기법​","type":1,"pageTitle":"IO 다루기","url":"/learn-haskell-blog-generator/glue/io#do-표기법","content":"IO액션을 연결하기 위해 &gt;&gt;=를 사용할 수도 있지만, 하스켈은 명령형 프로그래밍과 비슷한 더 편리한 문법적 설탕인 do 표기법을 제공합니다. do 블록은 do 키워드로 시작하고, 다음과 같은 형태의 하나 이상의 &quot;문장&quot;으로 이어집니다: IO () 타입의 표현식, 예를 들어: putStrLn &quot;Hello&quot;if True then putStrLn &quot;Yes&quot; else putStrLn &quot;No&quot; let 블록, 예를 들어 let x = 1또는 다음과 같이 여러 let 선언: let x = 1 y = 2 여기서 in은 생략합니다. 바인딩 &lt;변수&gt; &lt;- &lt;표현식&gt;, 예를 들어 line &lt;- getLine  그리고 마지막 &quot;문장&quot;은 IO &lt;무언가&gt; 타입의 표현식이어야 합니다. 이것은 do 블록의 결과 타입이 됩니다. 위 세 가지 문장은 하스켈 컴파일러를 통해 다음과 같은 형태로 변환됩니다: &lt;표현식&gt; *&gt;,let ... in&lt;표현식&gt; &gt;&gt;= \\&lt;변수&gt; 예를 들어 다음 코드는: greeting :: IO () greeting = do putStrLn &quot;Tell me your name.&quot; let greet name = &quot;Hello, &quot; ++ name ++ &quot;!&quot; name &lt;- getLine putStrLn (greet name)  다음 코드와 동일합니다: greeting :: IO () greeting = putStrLn &quot;Tell me your name.&quot; *&gt; let greet name = &quot;Hello, &quot; ++ name ++ &quot;!&quot; in getLine &gt;&gt;= \\name -&gt; putStrLn (greet name)  let과 &lt;-의 차이를 이해하는 것은 중요합니다.let은 표현식에 새로운 이름을 지정하는데 사용되고 이후 라인에서 접근할 수 있습니다. 그리고 &lt;-는 IO a 안의 결과 a를 새로운 이름에 바인딩하는데 사용되고 이후 라인에서 접근할 수 있습니다. code\toperator\t왼쪽 타입\t오른쪽 타입\t설명let gretting = &quot;hello&quot;\t=\tString\tString\t양쪽 교환 가능 let mygetline = getLine\t=\tIO String\tIO String\tgetLine에 새로운 이름을 지정 name &lt;- getLine\t&lt;-\tString\tIO String\tgetLine의 결과를 변수에 바인딩 Do 표기법은 매우 흔하고, &gt;&gt;=를 직접 사용하는 것보다 선호하는 경우가 많습니다.  연습문제: 이 장의 예제를 do 표기법으로 변경하세요. 연습문제: 블로그 생성기에 대한 코드를 do 표기법으로 변경하세요. 정답 -- Main.hs module Main where import qualified Markup import qualified Html import Convert (convert) import System.Directory (doesFileExist) import System.Environment (getArgs) main :: IO () main = do args &lt;- getArgs case args of -- 인자가 없는경우: 표준 입력에서 읽고, 표준 출력에 씁니다. [] -&gt; do content &lt;- getContents putStrLn (process &quot;Empty title&quot; content) -- 인자로 입력과 출력 파일 경로가 있는 경우 [input, output] -&gt; do content &lt;- readFile input exists &lt;- doesFileExist output let writeResult = writeFile output (process input content) if exists then whenIO confirm writeResult else writeResult -- 그 외 입력의 경우 _ -&gt; putStrLn &quot;Usage: runghc Main.hs [-- &lt;input-file&gt; &lt;output-file&gt;]&quot; process :: Html.Title -&gt; String -&gt; String process title = Html.render . convert title . Markup.parse confirm :: IO Bool confirm = do putStrLn &quot;Are you sure? (y/n)&quot; answer &lt;- getLine case answer of &quot;y&quot; -&gt; pure True &quot;n&quot; -&gt; pure False _ -&gt; do putStrLn &quot;Invalid response. use y or n&quot; confirm whenIO :: IO Bool -&gt; IO () -&gt; IO () whenIO cond action = do result &lt;- cond if result then action else pure ()   ","version":"Next","tagName":"h2"},{"title":"요약​","type":1,"pageTitle":"IO 다루기","url":"/learn-haskell-blog-generator/glue/io#요약-1","content":"이번 장에서는 &quot;순수 함수형&quot;이 무엇인지, 순수 함수형을 추구하는 이유는 무엇인지, 그리고 하스켈의 I/O 인터페이스가 프로그램의 명세를 만들 수 있게 하는지 살펴보았습니다. 우리는 또한 중요한 이정표를 달성했습니다. 우리는 프로그램을 하나의 문서에서 실행하고 HTML로 렌더링된 결과를 얻을 수 있도록 필요한 구성 요소들을 충분히 구현했습니다! 하지만, 우리의 명령줄 인터페이스는 여전히 부족합니다. 여러 게시글로 구성된 블로그를 렌더링하고, 인덱스 페이지를 만들고, 더 많은 작업을 해야합니다. 아직 이 프로그램을 블로그 생성기라고 부르기에는 더 많은 작업이 남아 있습니다. 계속 진행해봅시다! Git 커밋을 통해이번에 수정한 내역과 현재까지 코드 를 확인할 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"마크업을 HTML로 변환하기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/glue/markup-to-html","content":"","keywords":"","version":"Next"},{"title":"한정된 가져오기 (Qualified Imports)​","type":1,"pageTitle":"마크업을 HTML로 변환하기","url":"/learn-haskell-blog-generator/glue/markup-to-html#한정된-가져오기-qualified-imports","content":"이번에는 모듈을 가져올 때 한정된 가져오기(qualified imports)를 사용했습니다. 한정된 가져오기는 가져온 모듈의 이름을 일반 모듈 이름 공간에 노출하지 않으며, 모듈을 사용하려면 모듈 이름으로 접두사를 붙여야 합니다. 예를 들어 parse를 사용하려면 Markup.parse로 작성해야 합니다. 만약 Html.Internal을 한정된 가져오기로 가져왔다면 Html.Internal.el로 작성해야 합니다. 이는 약간 길어 보입니다. as 키워드를 사용하여 모듈에 새 이름을 지정할 수도 있습니다: import qualified Html.Internal as HI  그러면 HI.el로 작성할 수 있습니다. 개인적으로 한정된 가져오기를 사용하는 것을 선호합니다. 왜냐하면 코드를 읽는 사람이 어디에서 가져온 이름인지 추측할 필요가 없기 때문입니다. 또한 한정된 가져오기를 사용하도록 설계된 모듈들도 있습니다. 예를 들어 map, set, vector와 같은 컨테이너 타입의 API는 매우 유사합니다. 만약 하나의 모듈에서 여러 컨테이너를 사용하려면 singleton과 같은 함수를 작성할 때, 한정된 가져오기를 사용해야 GHC가 어떤 singleton 함수를 참조하는지 알 수 있습니다. 일부 사람들은 한정된 가져오기 대신 가져오기 목록(import list)을 선호합니다. 한정된 이름들이 약간 지저분하고 장황하기 때문입니다. 저는 종종 가져오기 목록 대신 한정된 가져오기를 선호하지만, 두 가지 방법 모두 사용해 보고 어떤 것이 더 좋은지 확인해 보세요. 가져오기에 대한 더 많은 정보는 위키 문서를 참고하세요. ","version":"Next","tagName":"h2"},{"title":"Markup.Structure를 Html.Structure로 변환하기​","type":1,"pageTitle":"마크업을 HTML로 변환하기","url":"/learn-haskell-blog-generator/glue/markup-to-html#markupstructure를-htmlstructure로-변환하기","content":"마크업 구조를 HTML 구조로 변환하는 과정은 직관적입니다. 마크업 구조를 패턴 매칭하고 연관된 HTML API를 사용하면 됩니다. convertStructure :: Markup.Structure -&gt; Html.Structure convertStructure structure = case structure of Markup.Heading 1 txt -&gt; Html.h1_ txt Markup.Paragraph p -&gt; Html.p_ p Markup.UnorderedList list -&gt; Html.ul_ $ map Html.p_ list Markup.OrderedList list -&gt; Html.ol_ $ map Html.p_ list Markup.CodeBlock list -&gt; Html.code_ (unlines list)  $는 무엇인가요? The dollar sign ($) is an operator that we can use to group expressions, like we do with parenthesis. we can replace the $ with invisible parenthesis around the expressions to the left of it, and around the expression to the right of it. So that: Html.ul_ $ map Html.p_ list is understood as: (Html.ul_) (map Html.p_ list) It is a function application operator, it applies the argument on the right of the dollar to the function on the left of the dollar. $ is right-associative and has very low precedence, which means that: it groups to the right, and other operators bind more tightly. For example the following expression: filter (2&lt;) $ map abs $ [-1, -2, -3] &lt;&gt; [4, 5, 6] is understood as: (filter (2&lt;) ((map abs) ([1, -2, 3] &lt;&gt; [-4, 5, 6])) Which is also equivalent to the following code with less parenthesis: filter (2&lt;) (map abs ([1, -2, 3] &lt;&gt; [-4, 5, 6])) See how information flows from right to left and that &lt;&gt; binds more tightly? This operator is fairly common in Haskell code and it helps us reduce some clutter, but feel free to avoid it in favor of parenthesis if you'd like, it's not like we're even saving keystrokes with $! 위 코드를 -Wall 플래그와 함께 컴파일하면 패턴 매칭이 완전하지 않다(non-exhaustive)는 경고가 나옵니다. 이는 현재 h1이 아닌 제목을 처리할 방법이 없기 때문입니다. 이 문제를 해결하는 몇 가지 방법이 있습니다: 경고 무시하기- 이 방법은 언젠가 런타임에서 문제가 발생하고 사용자가 슬퍼할 것입니다.다른 경우를 패턴 매칭하고 error 함수를 사용하여 사용자에게 적절한 오류 메시지를 표시합니다. - 위와 동일한 단점이 있지만, 컴파일 시 경고가 발생하지 않습니다.패턴을 매칭하고 잘못된 작업을 수행합니다. - 사용자는 여전히 슬퍼할 것입니다.Either를 사용하여 타입 시스템에 오류를 인코딩합니다. 이후 장에서 이 방법을 살펴보겠습니다.입력을 제한하기 - Markup.Heading을 숫자 대신 지원하는 특정 제목으로 변경합니다. 이것은 합리적인 접근 방식입니다.임의의 제목을 지원하는 함수를 구현하기 - 간단하게 구현할 수 있습니다.  연습문제: 임의의 제목(예: &lt;h1&gt;, &lt;h2&gt; 등)을 지원하는 함수 h_ :: Natural -&gt; String -&gt; Structure를 구현하세요. 정답 import Numeric.Natural h_ :: Natural -&gt; String -&gt; Structure h_ n = Structure . el (&quot;h&quot; &lt;&gt; show n) . escape Html.hs에서 함수를 내보내는 것을 잊지 마세요! 연습문제: convertStructure를 h_를 사용하도록 수정하세요. 정답 convertStructure :: Markup.Structure -&gt; Html.Structure convertStructure structure = case structure of Markup.Heading n txt -&gt; Html.h_ n txt Markup.Paragraph p -&gt; Html.p_ p Markup.UnorderedList list -&gt; Html.ul_ $ map Html.p_ list Markup.OrderedList list -&gt; Html.ol_ $ map Html.p_ list Markup.CodeBlock list -&gt; Html.code_ (unlines list)   ","version":"Next","tagName":"h2"},{"title":"Document -> Html​","type":1,"pageTitle":"마크업을 HTML로 변환하기","url":"/learn-haskell-blog-generator/glue/markup-to-html#document---html","content":"Html 문서를 생성하기 위해서는 html_ 함수를 사용해야 합니다. 이 함수는 Title과 Structure 두 인자를 받습니다. 제목의 경우, 단순하게 파일의 이름을 사용할 수 있습니다. 마크업 Document(마크업 Structure의 리스트)를 HTML Structure로 변환하려면 각 마크업 Structure를 변환하고 이를 하나로 합쳐야 합니다. 각 마크업 Structure를 변환하는 함수 convertStructure를 이미 구현했기에, map을 활용하여 다음과 같은 함수를 얻을 수 있습니다. map convertStructure :: Markup.Document -&gt; [Html.Structure]  Html.Structure의 리스트를 하나로 합치기 위해 재귀 함수를 사용할 수 있습니다. 하지만 리스트가 비어있는 경우를 처리하는 기본 사례에서 문제가 발생합니다. 이를 어떻게 처리할 수 있을까요? 단순히 빈 HTML 구조를 표현하는 더미 Html.Structure를 만들어서 사용할 수 있습니다. Html.Internal 모듈에 추가해 보겠습니다: empty_ :: Structure empty_ = Structure &quot;&quot;   이를 활용해 재귀 함수를 작성해 보세요! 정답 concatStructure :: [Structure] -&gt; Structure concatStructure list = case list of [] -&gt; empty_ x : xs -&gt; x &lt;&gt; concatStructure xs   이전에 &lt;&gt; 함수를 Semigroup의 인스턴스로 구현한 것을 기억하시나요?Semigroup는 (&lt;&gt;) :: a -&gt; a -&gt; a를 구현하는 것을 추상화한 것이었고,&lt;&gt;는 결합법칙을 만족해야 했습니다(a &lt;&gt; (b &lt;&gt; c) = (a &lt;&gt; b) &lt;&gt; c). Semigroup 인스턴스가 있고 또한 &quot;빈&quot; 값을 가지는 값도 가지는 상황이 자주 발생합니다. 예를 들어 문자열은 결합할 수 있고, 빈 문자열은 &quot;빈&quot; 값을 나타냅니다. 이는 실제로 monoid라는 추상화로 알려진 패턴입니다. ","version":"Next","tagName":"h2"},{"title":"Monoids​","type":1,"pageTitle":"마크업을 HTML로 변환하기","url":"/learn-haskell-blog-generator/glue/markup-to-html#monoids","content":"사실 &quot;빈 값&quot;이라는 의미는 모든 것을 잘 설명하지 못하며 추상화에 그렇게 유용하지도 않습니다. 대신 &quot;항등원(identity element)&quot;이라는 설명을 사용할 수 있으며 이는 다음 법칙을 만족해야 합니다: x &lt;&gt; &lt;identity&gt; = x&lt;identity&gt; &lt;&gt; x = x 다르게 말하면, 이 &quot;빈&quot; 값을 이용하여 &lt;&gt;에 다른 하나의 인자를 전달하면 다른 인자를 그대로 얻을 수 있습니다. String의 경우, 빈 문자열 &quot;&quot;이 이를 만족합니다: &quot;&quot; &lt;&gt; &quot;world&quot; = &quot;world&quot; &quot;hello&quot; &lt;&gt; &quot;&quot; = &quot;hello&quot;  &quot;world&quot;와 &quot;hello&quot; 뿐만 아니라 어떤 문자열에 대해서도 이 법칙이 성립합니다. 잠시 하스켈 세계에서 벗어나 생각해봅시다. 정수집합과 + 연산의 경우, +를 결합법칙을 만족하는 이항 연산자로(&lt;&gt; 대신), 0을 항등원으로 보면 monoid를 만족하는 것을 알 수 있습니다: 17 + 0 = 17 0 + 99 = 99  따라서 정수집합과 + 연산 semigroup을 만족하며 0과 함께 monoid를 만족합니다. 이를 통해 다음과 같은 사실을 알 수 있습니다: monoid는 semigroup보다 더 구체적인 추상화입니다. semigroup에 항등원이라는 새로운 조건을 추가했습니다.이 추상화는 유용할 수 있습니다! concatStructure라는 일반적인 함수를 작성할 수 있습니다. 이 함수는 monoid에 대해서만 작동합니다. 실제로, base 패키지에는 Monoid라는 타입 클래스가 있으며 Semigroup를 슈퍼 클래스(super class)로 가집니다. class Semigroup a =&gt; Monoid a where mempty :: a  노트 사실 위 정의는 간략하게 표현한 버전입니다.실제 정의는 하위 호환성 및 성능을 고려하기에 조금 더 복잡합니다. 하스켈에서 Semigroup은 Monoid가 나온 이후에 도입되었습니다! 이제 HTML Structure 데이터 타입에 Monoid 인스턴스를 추가할 수 있습니다: instance Monoid Structure where mempty = empty_  이제 concatStructure 함수대신 다음과 같은 라이브러리 함수를 사용할 수 있습니다: mconcat :: Monoid a =&gt; [a] -&gt; a  이 함수는 이론적으로 다음과 같이 구현되어 있습니다: mconcat :: Monoid a =&gt; [a] -&gt; a mconcat list = case list of [] -&gt; mempty x : xs -&gt; x &lt;&gt; mconcat xs  Semigroup은 Monoid의 슈퍼 클래스이므로, =&gt; 왼쪽에 Semigroup a를 추가하지 않아도 &lt;&gt; 함수를 사용할 수 있습니다.Monoid a 제약을 추가하면 Semigroup a 제약도 자동으로 추가됩니다! mconcat 함수는 concatStructure 함수와 매우 유사하지만, Structure 이외의 모든 Monoid에 대해서도 작동합니다! 추상화를 통해 공통 패턴을 식별하고 코드를 재사용할 수 있습니다! 노트 사실 하스켈에서 정수, + 연산, 0은 Monoid의 인스턴스가 아닙니다. 왜냐하면 정수는 * 연산과 1과도 monoid를 이룰 수 있기 때문입니다! 하스켈에서 하나의 타입에는 하나의 인스턴스만 존재할 수 있습니다. 대신, Sum과 Product라는 두 개의 newtype이 존재하며 이들은 Monoid의 인스턴스입니다.ghci에서 이들을 사용하는 방법은 다음과 같습니다: ghci&gt; import Data.Monoid ghci&gt; Product 2 &lt;&gt; Product 3 -- 여기서 Product는 데이터 생성자입니다 Product {getProduct = 6} ghci&gt; getProduct (Product 2 &lt;&gt; Product 3) 6 ghci&gt; getProduct $ mconcat $ map Product [1..5] 120  ","version":"Next","tagName":"h2"},{"title":"또 다른 추상화?​","type":1,"pageTitle":"마크업을 HTML로 변환하기","url":"/learn-haskell-blog-generator/glue/markup-to-html#또-다른-추상화","content":"지금까지 계속 map과 mconcat을 연속해서 사용했습니다. 이와 같은 패턴을 통합할 수 있는 함수가 있을까요? 실제로 foldMap과 같은 함수가 있으며, 리스트뿐만 아니라 &quot;접거나(folded)&quot; &quot;축소(reduced)&quot;할 수 있는 모든 데이터 구조에 대해서 작동합니다. 이러한 추상화와 타입 클래스를 Foldable이라고 합니다. 더 간단한 Foldable의 이해를 위해 fold를 살펴보겠습니다: fold :: (Foldable t, Monoid m) =&gt; t m -&gt; m -- 다음 함수와 비교해보세요 mconcat :: Monoid m =&gt; [m] -&gt; m  mconcat은 단지 리스트에 대한 fold의 특수한 경우입니다. 또한 fold는 Foldable과 Monoid를 구현한 어떠한 쌍에 대해서도 사용할 수 있습니다. 예를 들어 []와 Structure 또는 Maybe와 Product Int 또는 특별한 이진 트리와 String을 사용할 수 있습니다. 하지만 Foldable의 kind는 * -&gt; *이어야 합니다. 따라서 Html은 Foldable이 될 수 없습니다. foldMap 함수는 &lt;&gt; 함수를 사용하여 요소를 결합하기 전에, Foldable의 인자(payload)타입에 원하는 함수를 적용할 수 있도록 해줍니다: foldMap :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m -- 다음 특수한 경우와 비교해보세요 -- - t ~ [] -- - m ~ Html.Structure -- - a ~ Markup.Structure foldMap :: (Markup.Structure -&gt; Html.Structure) -&gt; [Markup.Structure] -&gt; Html.Structure  이름에서 알 수 있듯이, foldMap은 &quot;접기(fold)&quot; 전에 &quot;매핑(map)&quot;을 수행합니다. 여기서 잠시 멈추고 고민해보면 &quot;이 '매핑(map)'은 리스트 뿐만 아니라 다른 추상화에도 적용할 수 있지 않을까?&quot;라고 생각할 수 있습니다. 네 맞습니다! 매우 중요하고 기본적인 추상화인 Functor가 존재합니다. 하지만 이번 장에서는 충분히 많은 추상화를 다루었으므로, 이에 대해서는 다음 장에서 다루도록 하겠습니다! ","version":"Next","tagName":"h2"},{"title":"변환 모듈 마무리하기​","type":1,"pageTitle":"마크업을 HTML로 변환하기","url":"/learn-haskell-blog-generator/glue/markup-to-html#변환-모듈-마무리하기","content":"convert 함수를 구현하면서 이번 장을 마무리하겠습니다: convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html convert title = Html.html_ title . foldMap convertStructure  이제 모든 구현을 완료했으며 마크업 문서를 HTML로 변환할 수 있습니다: Convert.hs module Convert where import qualified Markup import qualified Html convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html convert title = Html.html_ title . foldMap convertStructure convertStructure :: Markup.Structure -&gt; Html.Structure convertStructure structure = case structure of Markup.Heading n txt -&gt; Html.h_ n txt Markup.Paragraph p -&gt; Html.p_ p Markup.UnorderedList list -&gt; Html.ul_ $ map Html.p_ list Markup.OrderedList list -&gt; Html.ol_ $ map Html.p_ list Markup.CodeBlock list -&gt; Html.code_ (unlines list)  ","version":"Next","tagName":"h2"},{"title":"요약​","type":1,"pageTitle":"마크업을 HTML로 변환하기","url":"/learn-haskell-blog-generator/glue/markup-to-html#요약","content":"이번 장에서는 다음과 같은 내용을 배웠습니다: 한정된 가져오기오류 처리 방법Monoid 타입 클래스와 추상화Foldable 타입 클래스와 추상화 다음에는 하스켈에서 IO를 다루는 방법을 다루겠습니다! 이곳에서 Git 커밋을 확인할 수 있고,지금까지 코드를 확인할 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"프로젝트의 명세를 정의하기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/glue/project","content":"","keywords":"","version":"Next"},{"title":"프로젝트 만들기​","type":1,"pageTitle":"프로젝트의 명세를 정의하기","url":"/learn-haskell-blog-generator/glue/project#프로젝트-만들기","content":"외부 패키지를 사용하는 방법은 여러 가지가 있습니다. 빠른 실험을 위해, 외부 패키지를 사용하여 프로그램을 빌드하거나 실행할 수 있도록 stack이나 cabal에게 요청할 수 있습니다. 하지만 프로그램이 커지고, 더 많은 의존성을 사용하고, 더 많은 기능이 필요할수록, 프로그램과 라이브러리를 위한 프로젝트 명세를 만드는 것이 좋습니다. 프로젝트 명세는 cabal 파일에 작성됩니다.cabal init --libandexe나 stack new를 사용하여 cabal이나 stack에게 명세를 생성하도록 요청할 수 있지만, 나중에 파일을 직접 편집해야 할 수도 있습니다. 지금은 단순히 hs-blog.cabal에 다음 예제를 붙여넣고 편집합시다. cabal-version: 2.4 name: 이름은 &lt;name&gt;.cabal과 일치해야 합니다. version: 버전은 PvP를 사용해야 합니다. synopsis: 시놉시스는 hackage 패키지 목록과 검색에 표시됩니다. description: 설명은 라이브러리의 상단에 표시됩니다. homepage: 홈페이지 url bug-reports: 이슈 추적기 url license: 라이선스 이름 license-file: 라이선스 파일 author: 작성자 이름 maintainer: 메인테이너 이메일 category: 쉼표로 구분된 Hackage 카테고리 extra-doc-files: README.md common common-settings default-language: Haskell2010 ghc-options: -Wall library import: common-settings hs-source-dirs: src build-depends: base , directory exposed-modules: HsBlog HsBlog.Convert HsBlog.Html HsBlog.Html.Internal HsBlog.Markup -- other-modules: executable hs-blog-gen import: common-settings hs-source-dirs: app main-is: Main.hs build-depends: base , &lt;package-name&gt; ghc-options: -O  각 항목에 대한 자세한 내용을 하나씩 살펴보겠습니다. package metadatacommon settingslibraryexecutable. ","version":"Next","tagName":"h2"},{"title":"Package metadata​","type":1,"pageTitle":"프로젝트의 명세를 정의하기","url":"/learn-haskell-blog-generator/glue/project#package-metadata","content":"패키지 메타데이터 항목들은 주석 내용만 보고도 어떤 내용인지 직관적으로 알 수 있습니다. 다만 다음 항목들에 대해서는 좀 더 살펴볼 필요가 있습니다. cabal-version: 어떤 cabal 버전으로 이 프로젝트를 빌드할 수 있는지 정의합니다. 예제에서는 2.4 이상을 지정했습니다. 각 버전에 대한 정보는 문서를 참고하세요.name: 라이브러리와 패키지의 이름을 정의합니다. .cabal 파일의 이름과 일치해야 합니다. 보통 소문자로 시작합니다.Hackage에서 패키지 이름이 이미 사용중인지 확인하세요.version: 일부 하스켈 패키지는 semver을 사용하지만, 대부분 PvP를 사용합니다.license: Most Haskell packages use BSD-3-Clause. Neil Mitchell blogged about this. You can find more licenses if you'd like at choosealicense.com.license: 대부분의 하스켈 패키지는 BSD-3-Clause를 사용합니다. 이에 대한 Neil Mitchell의 글을 참고하세요. 더 많은 라이선스를 찾으려면 choosealicense.com을 참고하세요.extra-doc-files: README나 CHANGELOG와 같은 추가 문서 파일을 포함합니다. 우리 프로젝트에 맞게 각 항목을 채워넣어봅시다. cabal-version: 2.4 name: hs-blog version: 0.1.0.0 synopsis: 마크업 파일을 통한 커스텀 블로그 생성기 description: 이 패키지는 커스텀 마크업 형식의 파일을 HTML로 변환하는 정적 블로그 생성기를 제공합니다. 이 커스텀 마크업 형식의 파서와 HTML 프리티 프린터 EDSL을 정의합니다. 이 패키지는 온라인 책 'Learn Haskell Blog Generator'의 예제 프로젝트로 사용됩니다. 자세한 내용은 README를 참고하세요. homepage: https://github.com/soupi/learn-haskell-blog-generator bug-reports: https://github.com/soupi/learn-haskell-blog-generator/issues license: BSD-3-Clause license-file: LICENSE.txt author: Gil Mizrahi maintainer: gilmi@posteo.net category: Learning, Web extra-doc-files: README.md  ","version":"Next","tagName":"h3"},{"title":"Common settings​","type":1,"pageTitle":"프로젝트의 명세를 정의하기","url":"/learn-haskell-blog-generator/glue/project#common-settings","content":"Cabal 패키지 설명에는 라이브러리, 실행 파일, 테스트 스위트 등 여러 &quot;타겟&quot;을 포함할 수 있습니다. Cabal 2.2 이후로는 공통 stanza를 사용하여 다른 타겟들 사이에서 공유할 설정을 그룹화할 수 있습니다. 이렇게 하면 각 타겟마다 설정을 반복할 필요가 없습니다. 예제에서는 common-settings라는 새로운 공통 stanza를 만들었습니다. 여기에는 기본 언어(Haskell은 98과 2010 두 가지 표준이 있습니다)설정과 GHC에 -Wall 옵션을 주어 컴파일하도록 지시합니다. common common-settings default-language: Haskell2010 ghc-options: -Wall  이후 타켓 설정에서 import: common-settings를 추가하면 이 설정들이 자동으로 추가됩니다. ","version":"Next","tagName":"h3"},{"title":"Library​","type":1,"pageTitle":"프로젝트의 명세를 정의하기","url":"/learn-haskell-blog-generator/glue/project#library","content":"library 명세에는 다음 항목들을 정의합니다: 라이브러리를 빌드하는 데 필요한 설정(우리는 common-settings를 import합니다)소스 파일이 위치한 디렉토리라이브러리를 빌드하는 데 필요한 패키지라이브러리에서 외부에 노출할 모듈라이브러리에서 외부에 노출하지 않을 모듈, 이 모듈들은 외부에서 사용할 수 없습니다. 이는 내부 유틸리티 함수 모듈과 같은 모듈을 노출하지 않을 때 사용합니다. 예제에서는 내부 유틸리티 함수 모듈이 없으므로 other-modules 라벨을 주석 처리했습니다. 보통 패키지의 버전 범위(version bounds)를 지정하는 것이 일반적입니다. 버전 범위는 이 라이브러리가 동작하는 패키지 버전을 지정합니다. 이는 cabal gen-bounds 명령으로 생성할 수도 있습니다. library import: common-settings hs-source-dirs: src build-depends: base , directory exposed-modules: HsBlog HsBlog.Convert HsBlog.Html HsBlog.Html.Internal HsBlog.Markup -- other-modules:  모듈을 위한 추가적인 계층을 정의했으며, 기존과 다른 소스 디렉토리를 지정했음을 주목하세요. 따라서 파일들을 약간 옮겨야 하고 각 파일의 module 이름과 import 문을 변경해야 합니다. 이는 사용자가 import할 다른 패키지와 충돌을 피하기 위함입니다.  위 작업을 진행해보세요. 정답 Main.hs -&gt; src/HsBlog.hs module HsBlog ( main , process ) where import qualified HsBlog.Markup as Markup import qualified HsBlog.Html as Html import HsBlog.Convert (convert) Convert.hs -&gt; src/HsBlog/Convert.hs module HsBlog.Convert where import qualified HsBlog.Markup as Markup import qualified HsBlog.Html as Html Html.hs -&gt; src/HsBlog/Html.hs module HsBlog.Html ... import HsBlog.Html.Internal Html/Internal.hs -&gt; src/HsBlog/Html/Internal.hs module HsBlog.Html.Internal where Markup.hs -&gt; src/HsBlog/Markup.hs module HsBlog.Markup   ","version":"Next","tagName":"h3"},{"title":"Executable​","type":1,"pageTitle":"프로젝트의 명세를 정의하기","url":"/learn-haskell-blog-generator/glue/project#executable","content":"우리는 코드를 라이브러리와 실행 파일, 두 부분으로 나누었습니다. 그 이유는 무엇일까요? 첫째, 라이브러리는 다른 사람들이 사용할 수 있습니다. 만약 우리가 코드를 공개하면 누군가는 이를 사용하고 더 발전시킬 수 있습니다. 하지만 실행 파일은 다른 프로젝트에서 import할 수 없습니다. 둘째, 라이브러리에 대해 유닛 테스트를 작성할 수 있습니다. 보통 대부분의 로직을 라이브러리로 작성하고, 그 위에 간단한 실행 파일을 제공하는 것이 유용합니다. Executable 명세는 libraries 항목과 매우 유사합니다. 예제에서는 다음 항목들을 정의합니다: 실행 파일의 이름소스 디렉토리'Main'을 정의한 파일hs-blog로 이름지은 우리 라이브러리를 importGHC에 전달할 추가 옵션, 예를 들어 -O를 주어 최적화를 하도록 합니다. executable hs-blog-gen import: common-settings hs-source-dirs: app main-is: Main.hs build-depends: base , hs-blog ghc-options: -O  executable 명세에는 여러 실행 파일을 정의할 수 있습니다. 예제에서는 하나만 정의했습니다.  연습문제: 새로운 파일을 추가하세요: app/Main.hs. 이 파일은 HsBlog를 import하고 main을 실행합니다. 정답 -- app/Main.hs module Main where import qualified HsBlog main :: IO () main = HsBlog.main   ","version":"Next","tagName":"h3"},{"title":"Test-suites​","type":1,"pageTitle":"프로젝트의 명세를 정의하기","url":"/learn-haskell-blog-generator/glue/project#test-suites","content":"패키지의 테스트를 실행하기 위한 명세를 정의합니다. 이후 장에서 다룰 예정입니다. ","version":"Next","tagName":"h3"},{"title":"최종 .cabal 파일​","type":1,"pageTitle":"프로젝트의 명세를 정의하기","url":"/learn-haskell-blog-generator/glue/project#최종-cabal-파일","content":"cabal-version: 2.4 name: hs-blog version: 0.1.0.0 synopsis: 마크업 파일을 통한 커스텀 블로그 생성기 description: 이 패키지는 커스텀 마크업 형식의 파일을 HTML로 변환하는 정적 블로그 생성기를 제공합니다. 이 커스텀 마크업 형식의 파서와 HTML 프리티 프린터 EDSL을 정의합니다. 이 패키지는 온라인 책 'Learn Haskell Blog Generator'의 예제 프로젝트로 사용됩니다. 자세한 내용은 README를 참고하세요. homepage: https://github.com/soupi/learn-haskell-blog-generator bug-reports: https://github.com/soupi/learn-haskell-blog-generator/issues license: BSD-3-Clause license-file: LICENSE.txt author: Gil Mizrahi maintainer: gilmi@posteo.net category: Learning, Web extra-doc-files: README.md common common-settings default-language: Haskell2010 ghc-options: -Wall library import: common-settings hs-source-dirs: src build-depends: base , directory exposed-modules: HsBlog HsBlog.Convert HsBlog.Html HsBlog.Html.Internal HsBlog.Markup -- other-modules: executable hs-blog-gen import: common-settings hs-source-dirs: app main-is: Main.hs build-depends: base , hs-blog ghc-options: -O  README.md 파일과 LICENSE.txt 파일도 추가할 수 있습니다: README.md 원하는 내용을 넣을 수 있습니다. # hs-blog 이 프로그램은 언젠가 정적 블로그 생성기가 될 것입니다. [이 책을 읽어보세요](https://lhbg-book.link).  LICENSE.txt 예제에서는 저자의 이름으로 BSD-3-Clause를 적용했습니다. 여러분의 프로젝트에는 여러분의 이름을 적어주세요 :) BSD 3-Clause License Copyright (c) 2021-2022, Gil Mizrahi All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ","version":"Next","tagName":"h2"},{"title":"cabal.project와 stack.yaml​","type":1,"pageTitle":"프로젝트의 명세를 정의하기","url":"/learn-haskell-blog-generator/glue/project#cabalproject와-stackyaml","content":"cabal.project와stack.yaml파일은 각각 cabal과 stack에서 사용합니다. 이는 패키지를 빌드하는 방법에 대한 추가적인 정보를 제공합니다.cabal.project파일은 cabal을 사용하기 위해 반드시 필요하지는 않지만, stack.yaml파일은 stack을 사용하기 위해 반드시 필요합니다. stack.yaml파일에는 다음 두 중요한 필드가 있습니다: resolver: 패키지와 GHC 버전에 대한 스냅샷을 정의합니다. 이번에는 (글 작성시점 기준) lts 브랜치의 가장 최신 버전(lts-18.22)을 사용할 것입니다.이 링크에서 이 스냅샷에 포함된 패키지들과 그 버전, 그리고 GHC 버전을 확인할 수 있습니다.packages: 빌드할 패키지들의 위치를 정의합니다. 이번에는 현재 디렉토리에 있는 하나의 패키지만 사용할 것입니다. 프로젝트 디렉토리에 stack.yaml파일을 추가합니다: resolver: lts-18.22 packages: - .  추가 옵션과 설정에 대한 자세한 내용은 각각의 사용자 가이드를 참고하세요. ","version":"Next","tagName":"h2"},{"title":"사용법​","type":1,"pageTitle":"프로젝트의 명세를 정의하기","url":"/learn-haskell-blog-generator/glue/project#사용법","content":"이제 직접 runghc Main.hs을 수행하지 않고, stack 또는 cabal을 사용하여 프로그램을 빌드하고 실행할 것입니다. (저는 주로 stack을 사용하지만, 어떤 것을 사용하든 상관없습니다.) ","version":"Next","tagName":"h2"},{"title":"cabal을 사용하는 경우​","type":1,"pageTitle":"프로젝트의 명세를 정의하기","url":"/learn-haskell-blog-generator/glue/project#cabal을-사용하는-경우","content":"프로젝트 빌드하기 - 처음 실행시, cabal은 패키지 의존성을 다운로드하고 PATH에 있는 GHC를 사용하여 프로젝트를 빌드합니다. cabal은 각 프로젝트 패키지를 캐시하기에, 새로운 프로젝트가 같은 패키지와 같은 버전을 사용한다면 (그리고 같은 플래그 설정을 사용한다면) 패키지를 다시 설치할 필요가 없습니다. 이전 버전의 cabal에서는 패키지를 전역 또는 샌드박스에 설치할 수 있었습니다. 각 샌드박스(그리고 전역)에는 하나의 패키지 버전만 설치할 수 있었고, 사용자들은 보통 프로젝트마다 다른 샌드박스를 만들었고, 프로젝트 간에 패키지를 공유하지 않았습니다. 새로운 빌드 시스템으로 인해, 같은 패키지의 여러 버전을 전역으로 설치할 수 있게 되었고, 각 프로젝트는 샌드박스를 적용할 필요없이 패키지 의존성들이 모두 함께 동작하도록 특정 버전을 선택할 수 있습니다. 이 변경으로 인해 패키지 공유가 증가하고, 충돌을 피하고 샌드박스를 수동으로 관리할 필요가 없어졌습니다. 참고: 새로운 빌드 시스템 구현은 이제 기본값이며, cabal 명령어는 v2-로 접두사를 붙이지 않아도 됩니다. 하지만 cabal 문서에서는 여전히 새 명령어를 참조하기 위해 접두사를 언급할 것입니다. 익혀두면 좋은 몇 가지 중요한 명령어가 있습니다: cabal update  update명령어는 원격 패키지 저장소(기본값은 Hackage)에서 정보를 가져와 로컬 패키지 인덱스를 업데이트합니다. 이 인덱스에는 패키지 이름, 버전, 의존성 등 패키지에 대한 다양한 정보가 포함됩니다. cabal update는 보통 패키지 의존성을 가져오기 전에 실행하는 명령어입니다. cabal build  build명령어는 (library와 executable 등의) 다양한 타겟들을 컴파일합니다. 또한 기존에 설치되지 않은 패키지 의존성들을 가져와 설치합니다. 실행파일을 빌드하면, cabal build는 실행파일이 생성된 위치를 알려줍니다. 또한 cabal exec -- which hs-blog-gen과 같은 명령어를 사용하여 실행파일의 경로를 찾을 수 있습니다. cabal run hs-blog-gen -- &lt;프로그램 인자&gt;  run명령어는 타겟(예제에서는 hs-blog-gen이라는 이름을 붙인 executable)을 컴파일한 다음 실행합니다.-- 을 사용하면 cabal에게 전달한 인자와 타겟 프로그램에 전달한 인자를 구분할 수 있습니다. cabal repl hs-blog  repl명령어는 타겟의(예제에서는 hs-blog라는 이름을 붙인 library) ghci를 실행합니다. 이는 타겟의 패키지의 의존성과 모듈을 ghci에서 사용할 수 있도록 로드합니다. cabal clean  clean명령어는 빌드한 빌드 아티팩트를 삭제합니다. cabal에는 이 외에도 흥미로운 명령어들이 있습니다. 예를 들어, cabal freeze는 프로젝트를 빌드할 때 사용한 패키지 버전과 플래그를 기록하는 파일을 생성하고,cabal sdist는 프로젝트 소스를 패키지 tarball로 묶어 Hackage에 업로드할 수 있습니다. 더 많은 내용을 알고싶다면 Cabal 사용자 가이드를 참고하세요. ","version":"Next","tagName":"h3"},{"title":"stack을 사용하는 경우​","type":1,"pageTitle":"프로젝트의 명세를 정의하기","url":"/learn-haskell-blog-generator/glue/project#stack을-사용하는-경우","content":"프로젝트 빌드하기 - 처음 실행할 때, stack은 이 프로젝트를 위한(stack.yaml 파일의 resolver에 명시한) GHC를 설치하고 의존성 패키지를 다운로드하고 프로젝트를 컴파일합니다. stack은 이러한 설치를 캐싱하여 같은 resolver를 사용하는 이후 프로젝트에서는 재설치없이 캐시를 사용합니다. 이는 완전한 패키지 공유와 샌드박스 사이의 중간 정도의 접근법입니다. 이제 (cabal 명령어와 비슷한) stack 명령어를 살펴보겠습니다: stack build  build명령어는 cabal에서 언급한 것과 동일한 타겟을 컴파일합니다. - 만약 설치되어 있지 않다면 GHC와 패키지 의존성을 설치합니다. 실행파일을 빌드하면, stack build는 실행파일이 생성된 위치를 알려줍니다. 또한 stack exec -- which hs-blog-gen과 같은 명령어를 사용하여 실행파일의 경로를 찾을 수 있습니다. stack exec hs-blog-gen -- &lt;프로그램 인자&gt;  exec명령어는 프로그램 인자를 전달해 실행파일을 실행합니다. stack ghci hs-blog  ghci명령어는 라이브러리 모듈과 패키지를 ghci에서 사용할 수 있도록 로드합니다. stack clean  clean명령어는 빌드 아티팩트를 삭제합니다. Stack 사용자 가이드에는 stack이 어떻게 동작하는지와 효과적으로 사용하는 방법에 대한 더 많은 정보가 있습니다. ","version":"Next","tagName":"h3"},{"title":"빌드 아티팩트​","type":1,"pageTitle":"프로젝트의 명세를 정의하기","url":"/learn-haskell-blog-generator/glue/project#빌드-아티팩트","content":"stack과 cabal은 빌드 아티팩트를 생성합니다. 이 빌드 아티팩트는 보통 버전 관리에 포함하지 않습니다. 빌드 아티팩트는 dist, dist-newstyle 그리고 .stack-work 디렉토리에 있습니다. 우리는 이들을 .gitignore 파일(다른 버전관리 프로그램을 사용한다면 이와 비슷한 파일)에 추가하여 무시할 수 있습니다. dist dist-newstyle .stack-work  ","version":"Next","tagName":"h3"},{"title":"패키지 찾기​","type":1,"pageTitle":"프로젝트의 명세를 정의하기","url":"/learn-haskell-blog-generator/glue/project#패키지-찾기","content":"사용할 패키지를 찾는것은 지금 당장은 쉽지 않은 과정입니다. 여러 사람들이 작성한 패키지를 어떻게 선택하는가,추천 리스트, 책 등을 참고할 수 있습니다. 저의 제안은 다음과 같습니다: 흥미로운 튜토리얼을 찾아보고, 어떤 패키지가 사용되었는지 확인합니다.Hackage의 다운로드 수를 확인합니다.관련 패키지를 찾기위해 Stackage의 패키지 시놉시스를 확인합니다.소셜 네트워크 채널에서 사람들의 추천을 확인합니다. 하지만 때때로 사람들은 적절하지 않은 솔루션과, 너무 복잡하거나 실험적인 패키지를 추천하기도 합니다. 패키지의 의존성 개수를 확인하는 것도 중요합니다. 많은 의존성을 추가하면 컴파일 시간과 코드 크기에 영향을 미칩니다. 때때로 패키지를 비교하거나 패키지가 필요한지 고려할 때 사용할 수 있는 좋은 방법입니다. ","version":"Next","tagName":"h2"},{"title":"요약​","type":1,"pageTitle":"프로젝트의 명세를 정의하기","url":"/learn-haskell-blog-generator/glue/project#요약","content":"지믁까지 라이브러리를 위한 패키지 명세를 만들었고, stack 또는 cabal을 사용하여 프로그램을 빌드했습니다. 이후 장에서는 본격적으로 외부 패키지를 추가할 것인데, cabal 파일의 build-depends 섹션에만 추가하면 됩니다. 그러면 패키지 관리자가 필요한 패키지를 다운로드하고 설치할 것입니다! 우리는 프로젝트 디렉토리 구조를 변경하였는데 다음과 같습니다: . ├── app │ └── Main.hs ├── hs-blog.cabal ├── LICENSE.txt ├── README.md ├── src │ ├── HsBlog │ │ ├── Convert.hs │ │ ├── Html │ │ │ └── Internal.hs │ │ ├── Html.hs │ │ └── Markup.hs │ └── HsBlog.hs └── stack.yaml 4 directories, 10 files  이 패키지 포맷은 다른 하스켈 개발자들이 사용할 수 있도록 Hackage에 배포될 수 있습니다! Git 커밋을 통해이번에 수정한 내역과 현재까지 코드 를 확인할 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"Hello, world!","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/hello","content":"","keywords":"","version":"Next"},{"title":"하스켈 소스 파일​","type":1,"pageTitle":"Hello, world!","url":"/learn-haskell-blog-generator/hello#하스켈-소스-파일","content":"하스켈 소스 파일은 여러 정의들로 구성됩니다. 가장 일반적인 형태의 정의는 다음과 같습니다: &lt;이름&gt; = &lt;표현식&gt;  다음과 같은 제약사항이 있습니다: 이름은 소문자로 시작해야 합니다파일 내에서 이름은 한 번만 사용할 수 있습니다 어떤 파일이 main이라는 정의를 가지고 있다면, 해당 파일은 실행 가능한 파일로 간주됩니다. 또한 main의 표현식은 프로그램의 시작점이 됩니다. 첫 번째 하스켈 소스코드 파일을 작성해 보겠습니다. hello.hs라는 이름의 새로운 파일을 만들고 다음과 같이 작성하세요: main = putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;  위 코드에서 main이라는 이름을 정의하고 putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;라는 표현식을 바인딩했습니다. main의 정의는 &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot; 값을 입력으로 putStrLn 함수를 호출한다는 의미입니다.putStrLn 함수는 하나의 문자열을 입력으로 받고 표준 출력으로 해당 문자열을 출력합니다. 주의 하스켈에서 함수에 인자를 전달할 때 괄호를 사용하지 않아도 됩니다. 이 프로그램을 실행하면 다음과 같은 텍스트가 화면에 출력됩니다: &lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;  주의할 점은 main = 부분을 생략하고 단순히 putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;만 작성할 수는 없습니다. 왜나하면 이는 정의가 아니기 때문입니다. 파이썬이나 OCaml과 같은 언어에서는 허용되지만 하스켈이나 C와 같은 언어에서는 허용되지 않습니다. ","version":"Next","tagName":"h2"},{"title":"프로그램 컴파일하기​","type":1,"pageTitle":"Hello, world!","url":"/learn-haskell-blog-generator/hello#프로그램-컴파일하기","content":"프로그램을 실행하기 위해, ghc라는 커맨드라인 프로그램을 사용하여 hello.hs라는 파일을 컴파일할 수 있습니다: &gt; ghc hello.hs [1 of 1] Compiling Main ( hello.hs, hello.o ) Linking hello ...  hello.hs 파일을 ghc에 전달하면 다음과 같은 파일들이 생성됩니다: hello.o - 오브젝트 파일hello.hi - 하스켈 인터페이스 파일hello - 네이티브 실행 파일 컴파일 이후에, hello라는 파일을 실행할 수 있습니다: &gt; ./hello &lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;  ","version":"Next","tagName":"h2"},{"title":"인터프리터로 실행하기​","type":1,"pageTitle":"Hello, world!","url":"/learn-haskell-blog-generator/hello#인터프리터로-실행하기","content":"다른 방법으로, 컴파일과 아티팩트 파일 생성 단계를 생략하고 runghc라는 커맨드라인 프로그램을 사용하여 소스 파일을 직접 실행할 수 있습니다: &gt; runghc hello.hs &lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;  프로그램 실행 결과를 파일로 저장하고 Firefox 브라우저를 사용하여 해당 파일을 열 수도 있습니다. &gt; runghc hello.hs &gt; hello.html &gt; firefox hello.html  위 명령어는 Firefox를 실행하고 Hello, world!라는 텍스트가 있는 웹 페이지를 표시합니다. 이번 튜토리얼에서는 runghc를 사용하는 것을 추천합니다. 컴파일 하는것이 더 빠른 프로그램을 생성하지만, 프로그램을 개발하고 자주 변경하는 동안에는 인터프리터를 사용하는 것이 피드백을 더 빠르게 받을 수 있기 때문입니다. 하스켈 툴체인에 대해 더 자세히 알고 싶다면 이 글을 참고하세요. 하지만 지금 당장은 위 내용만 알아도 충분합니다. ","version":"Next","tagName":"h2"},{"title":"더 많은 바인딩​","type":1,"pageTitle":"Hello, world!","url":"/learn-haskell-blog-generator/hello#더-많은-바인딩","content":"putStrLn 함수에 직접 문자열을 전달하는 대신, HTML 문자열을 정의하는 새로운 이름을 만들어서 전달할 수도 있습니다. 이전에 만든 hello.hs 파일을 다음과 같이 수정하세요: main = putStrLn myhtml myhtml = &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;  참고: 바인딩의 정의 순서는 중요하지 않습니다. ","version":"Next","tagName":"h2"},{"title":"HTML 출력 라이브러리 만들기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html","content":"HTML 출력 라이브러리 만들기 이번 장에서는 함수, 타입, 모듈과 같은 기본적인 하스켈 빌딩 블록을 살펴보고, 이를 사용하여 마크업 블로그 포스트를 HTML 페이지로 변환하는 라이브러리를 만들어 보겠습니다. 아직 HTML에 대한 지식이 없다면 MDN의 HTML 튜토리얼을 먼저 읽어 보는 것을 추천합니다.","keywords":"","version":"Next"},{"title":"내장 도메인 특화 언어","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/edsls","content":"내장 도메인 특화 언어 이번 장에서는 하스켈에서 자주 볼 수 있는 패턴 중 하나인 &quot;내장 도메인 특화 언어(Embedded Domain Specific Languages, 줄여서 EDSLs)&quot;를 만들어 보겠습니다. 도메인 특화 언어(Domain Specific Languages)는 특정 도메인에 맞춰 특화된 프로그래밍 언어입니다. 반대로, 일반적인 프로그래밍 언어는 여러 도메인에서 잘 동작하도록 만들어져 있습니다. DLS의 예로는 다음과 같은 것들이 있습니다: make - 빌드 시스템을 정의하는 데 사용됩니다.DOT - 그래프를 정의하는 데 사용됩니다.Sed - 텍스트 변환을 정의하는 데 사용됩니다.CSS - 스타일링을 정의하는 데 사용됩니다.HTML - 웹 페이지를 정의하는 데 사용됩니다. 내장 도메인 특화 언어(EDSL)는 다른 프로그래밍 언어에 내장된 작은 언어입니다. EDSL로 작성된 프로그램은 해당 프로그래밍 언어에서 유효한 프로그램입니다. 예를 들어, 우리가 지금까지 작성한 HTML 라이브러리도 EDSL이라고 할 수 있습니다. 이 라이브러리는 (HTML 문자열을 반환하여) 웹 페이지를 만드는 데 사용되며, 유효한 하스켈 코드입니다! 하스켈에서는 도메인에 특화된 로직을 표현하기 위해 EDSL을 자주 만들고 사용합니다. 예를들면 동시성, 커맨드 라인 옵션 파싱, JSON, HTML, 빌드 시스템 작성, 테스트 작성 등을 위한 EDSL을 가지고 있습니다. 이런 특화된 언어는 특정 문제를 간결하고 (그리고 종종 안전하게) 해결할 수 있기 때문에 유용합니다. 또한 문법 강조, 호스트 언어의 다양한 도구 등과 같은 언어의 모든 기능을 사용할 수 있습니다. 하지만 EDSL을 만들 때 호스트 언어의 문법과 의미론과 같은 규칙을 준수해야 하는 단점이 있습니다. 몇몇 언어는 이러한 단점을 해결하기 위해 매크로나 언어 확장 기능과 같은 메타 프로그래밍 기능을 제공합니다. 하스켈도 이와 같은 기능을 제공하지만, 많은 EDSLs에서는 이러한 기능이 필요하지 않을 정도로 충분히 표현력이 있고 간결합니다. 대신, 많은 하스켈 EDSL은 조합자 패턴(combinator pattern) 이라는 것을 주로 사용합니다. 이 패턴에서는 원시(primitive) 와 조합자(combinator) 를 정의합니다. 원시는 언어의 기본적인 구성 요소이고, 조합자는 원시를 조합하여 더 복잡한 구조를 만드는 함수입니다. 지금까지 작성한 HTML EDSL에서 원시는 html_, title_ 등의 함수입니다. 이 함수들은 단일 HTML 노드를 생성하는 데 사용되며, 다른 생성된 노드를 입력으로 전달하고&lt;&gt; 함수를 사용하여 더 복잡한 구조를 만듭니다. 우리의 HTML EDSL을 개선할 수 있는 몇 가지 방법이 있습니다: 하스켈의 타입 시스템을 사용하여 유효한 HTML만 생성할 수 있도록 할 수 있습니다. 예를 들어, &lt;head&gt; 노드 없이 &lt;title&gt; 노드를 생성하지 못하게 하거나, 사용자 콘텐츠에 특수 문자를 포함할 수 있으며, 사용자가 유효하지 않은 작업을 시도할 때 타입 오류를 발생시킬 수 있습니다. HTML EDSL을 모듈로 만들어서 다른 모듈에서 재사용할 수 있도록 할 수 있습니다. 이후 섹션에서는 커스텀 타입을 정의하고 모듈을 사용하여 오류를 줄이는 방법을 살펴보고, 하스켈의 연결 리스트에 대해 살펴보겠습니다.","keywords":"","version":"Next"},{"title":"멋진 옵션 파싱","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/glue/optparse","content":"","keywords":"","version":"Next"},{"title":"명령줄 파서 만들기​","type":1,"pageTitle":"멋진 옵션 파싱","url":"/learn-haskell-blog-generator/glue/optparse#명령줄-파서-만들기","content":"optparse-applicative 패키지는 꽤 괜찮은문서, 를 가지고 있습니다. 하지만 이 장에서 중요한 몇 가지 사항을 다룰 것입니다. 일반적으로, 우리가 해야 할 일은 네 가지가 있습니다: 모델을 정의합니다 - 프로그램의 다양한 옵션과 명령을 설명하는 ADT를 정의합니다.실행할 때 모델 타입의 값을 생성하는 파서를 정의합니다.파서를 프로그램 인자 입력에 실행합니다.모델을 패턴 매칭하고 옵션에 따라 올바른 작업을 호출합니다. ","version":"Next","tagName":"h2"},{"title":"모델 정의하기​","type":1,"pageTitle":"멋진 옵션 파싱","url":"/learn-haskell-blog-generator/glue/optparse#모델-정의하기","content":"먼저 우리의 명령줄 인터페이스를 상상해봅시다. 어떤 기능이 있을까요? 단일 파일이나 입력 스트림을 파일이나 출력 스트림으로 변환해거나, 디렉토리 전체를 처리하고 새 디렉토리를 생성할 수 있어야 합니다. 우리는 이를 ADT로 모델링 할 수 있습니다: data Options = ConvertSingle SingleInput SingleOutput | ConvertDir FilePath FilePath deriving Show data SingleInput = Stdin | InputFile FilePath deriving Show data SingleOutput = Stdout | OutputFile FilePath deriving Show  SingleInput과 SingleOutput을 Maybe FilePath로 표현하는 것도 하나의 방법입니다. 하지만 이 경우 각 문맥에서 Nothing이 무엇을 의미하는지 기억해야 합니다. 각 옵션에 대한 적절한 이름을 가진 새로운 타입을 만드는 것이 코드의 의미를 이해하는데 도움이 됩니다. 인터페이스 관점에서, 사용자가 단일 입력 소스를 변환하려면 convert 명령어를 사용하고 옵션으로 --input FILEPATH와 --output FILEPATH를 제공하여 파일에서 읽거나 쓰게할 수 있습니다. 만약 사용자가 하나 이상의 옵션을 제공하지 않으면 표준 입력/출력에서 읽거나 쓸 것입니다. 만약 사용자가 디렉토리를 변환하려면 convert-dir 명령어를 사용하고--input FILEPATH와 --output FILEPATH를 필수로 입력해야 합니다. ","version":"Next","tagName":"h3"},{"title":"파서 만들기​","type":1,"pageTitle":"멋진 옵션 파싱","url":"/learn-haskell-blog-generator/glue/optparse#파서-만들기","content":"이 과정에서 가장 흥미로운 부분입니다. 어떻게 모델에 맞는 파서를 만들 수 있을까요? optparse-applicative 라이브러리는 Parser라는 새로운 타입을 제공합니다.Parser는 Maybe나 IO와 같이 kind가 * -&gt; *인 타입입니다.Int, Bool 또는 Options와 같은 구체적인 타입을 제공해야 Parser는 (값을 가지는) 구체적인 타입이 될 수 있습니다. Parser a는 명령줄 인자가 성공적으로 파싱된 경우 타입 a의 값을 생성하는 명령줄 파서의 명세를 의미합니다. 이는 IO a가 a의 값을 생성하는 프로그램의 명세를 의미하는 것과 유사합니다. 이 두 타입의 주요 차이점은 IO a를 a로 변환할 수 없지만 (우리는 단지 IO 연산을 연결하고 Haskell 런타임이 그것들을 실행하게 합니다),Parser a를 프로그램 인자를 의미하는 문자열 목록을 받고 인자를 파싱할 수 있으면 a를 생성하는 함수로 변환할 수 있다는 것입니다. 이전 EDSL과 마찬가지로, 이 라이브러리는 조합자 패턴을 사용합니다. 우리는 파서를 만들기 위한 원시값들과 작은 파서를 큰 파서로 조합하는 방법을 익혀야 합니다. 작은 파서의 예제를 살펴봅시다: inp :: Parser FilePath inp = strOption ( long &quot;input&quot; &lt;&gt; short 'i' &lt;&gt; metavar &quot;FILE&quot; &lt;&gt; help &quot;Input file&quot; ) out :: Parser FilePath out = strOption ( long &quot;output&quot; &lt;&gt; short 'o' &lt;&gt; metavar &quot;FILE&quot; &lt;&gt; help &quot;Output file&quot; )  strOption는 파서를 만드는 함수입니다. 이 함수는 인자로 조합된 옵션 수정자를 받아 문자열을 파싱하는 파서를 반환합니다. 타입을 FilePath로 지정할 수도 있는데, FilePath가 String의 별칭이기 때문입니다. 파서 빌더는 값을 파싱하는 방법을 설명하고, 수정자는 플래그 이름, 플래그 이름의 약어, 사용법 및 도움말 메시지에 대한 내용과 같은 속성을 설명합니다. 사실 strOption는 IsString 인터페이스를 구현하는 어떤 문자열 타입이라도 반환할 수 있습니다. 그 예로 text 패키지에서 가져온 훨씬 효율적인 유니코드 텍스트 타입인 Text가 있습니다.String은 Char의 링크드 리스트로 구현되지만, Text는 바이트 배열로 구현되기 때문에 Text가 더 효율적입니다. 텍스트 값을 위해 String 대신 Text를 사용하는게 좋습니다. 지금까지는 사용하지 않았는데 이는 String보다 약간 사용하기 불편하기 때문입니다. 하지만 텍스트를 표현할때 많이 사용하는 타입입니다! 보시다시피, 수정자는 &lt;&gt; 함수를 사용하여 합성할 수 있습니다. 즉, 수정자는 Semigroup 타입클래스의 인스턴스를 구현했다는 것을 의미합니다! 이러한 인터페이스로 인해, 우리는 모든 수정자 옵션을 제공할 필요가 없이 필요한 항목만 제공하면 됩니다. 따라서 우리가 짧은 플래그 이름을 가지고 싶지 않다면, 추가할 필요가 없습니다. Functor​ 우리가 정의한 데이터 타입을 위해, Parser FilePath를 정의했다는 것은 우리가 원하는 방향으로 큰 파서를 만들 수 있는 좋은 시작이지만, ConvertSingle에 필요한 것은 아닙니다.SingleInput과 SingleOutput을 위한 Parser가 필요합니다. 만약 FilePath가 있다면, InputFile 생성자를 사용하여 SingleInput으로 변환할 수 있습니다.InputFile도 함수라는 것을 기억하세요: InputFile :: FilePath -&gt; SingleInput OutputFile :: FilePath -&gt; SingleOutput  그러나 파서를 변환하려면 다음과 같은 타입의 함수가 필요합니다: f :: Parser FilePath -&gt; Parser SingleInput g :: Parser FilePath -&gt; Parser SingleOutput  다행히도, Parser 인터페이스는 FilePath -&gt; SingleInput와 같은 함수를 &quot;lift&quot;하는 함수를 제공합니다. 즉 Parser FilePath -&gt; Parser SingleInput와 같은 타입의 함수를 만들어줍니다. 이 함수는 어떠한 입력과 출력 모두에 대해 작동하기에 a -&gt; b 타입의 함수가 있다면 인자로 전달해 Parser a -&gt; Parser b 타입의 새 함수를 얻을 수 있습니다. 이러한 함수를 fmap이라고 부릅니다: fmap :: (a -&gt; b) -&gt; Parser a -&gt; Parser b -- 또는 중위 표기법으로 (&lt;$&gt;) :: (a -&gt; b) -&gt; Parser a -&gt; Parser b  우리는 이전에 다른 타입의 인터페이스에서 fmap을 보았습니다: fmap :: (a -&gt; b) -&gt; [a] -&gt; [b] fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b  fmap은 &lt;&gt;, show와 같은 타입클래스 함수입니다. 이는 Functor라는 타입클래스에 속합니다: class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b  그리고 다음과 같은 법칙이 있습니다: -- 1. 항등 법칙: -- 값들을 변경하지 않으면 아무것도 변경되지 않아야 합니다. fmap id = id -- 2. 합성 법칙: -- lift한 함수를 합성하는 것은 fmap으로 lift한 함수를 합성하는 것과 같습니다. fmap (f . g) == fmap f . fmap g  fmap을 구현하고 위 법칙을 따르는 타입은 Functor의 인스턴스가 될 수 있습니다. f의 kind가 * -&gt; *라는 것을 기억하세요.fmap의 타입 시그니처를 통해 f의 kind를 추론할 수 있습니다: a와 b의 kind는 *입니다. 왜냐하면 함수의 인자/반환 타입으로 사용되기 때문입니다.f a의 kind는 *입니다. 왜냐하면 함수의 인자로 사용되기 때문입니다.그러므로 f의 kind는 * -&gt; *입니다. 데이터 타입 하나를 선택해 Functor 인스턴스를 구현해봅시다. 먼저 * -&gt; * kind를 가진 데이터 타입을 선택해야 합니다. Maybe가 적합합니다. 이제 fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b 함수를 구현해야 합니다. 다음은 매우 간단하고 (그리고 잘못된) 구현입니다: mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b mapMaybe func maybeX = Nothing  한 번 컴파일해보세요! 성공적으로 컴파일됩니다! 하지만 불행하게도 첫 번째 법칙을 만족하지 않습니다.fmap id = id는 mapMaybe id (Just x) == Just x를 의미합니다. 그러나 정의에서 mapMaybe id (Just x) == Nothing이라는 것을 명확히 알 수 있습니다. 이는 하스켈이 법칙을 만족할 수 있게 보장해주지 않는다는 것과 이러한 법칙이 중요하다는 것을 보여줍니다. 법칙을 만족하지 않는 Functor 인스턴스는 우리가 기대하는 것과 다르게 동작할 것입니다. 다시 한 번 시도해봅시다! mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b mapMaybe func maybeX = case maybeX of Nothing -&gt; Nothing Just x -&gt; Just (func x)  이 mapMaybe는 법칙을 만족합니다. 이는 대수학을 통해 증명할 수 있습니다. - 만약 치환을 통해 등식의 한쪽에서 다른 쪽으로 도달할 수 있다면, 법칙은 성립합니다. Functor는 매우 중요한 타입클래스이며, 많은 타입이 이 인터페이스를 구현합니다. 우리가 알고 있는 것처럼, IO, Maybe, [], Parser 모두 * -&gt; * kind를 가지며 그들의 &quot;payload&quot; 타입에 대해 fmap을 사용할 수 있습니다. 종종 사람들은 타입클래스가 무엇을 의미하는지에 대한 비유나 은유를 찾으려고 합니다. 하지만 Functor`와 같은 재미있는 이름의 타입클래스는 일반적으로 모든 경우에 적합한 비유나 은유를 가지고 있지 않습니다. 은유를 포기하고 법칙을 가진 인터페이스로 그 자체로 생각하는 것이 더 쉽습니다. Parser에 대해 fmap을 사용해, FilePath를 반환하는 파서를 SingleInput 또는 SingleOutput을 반환하는 파서로 변환할 수 있습니다: pInputFile :: Parser SingleInput pInputFile = fmap InputFile parser where parser = strOption ( long &quot;input&quot; &lt;&gt; short 'i' &lt;&gt; metavar &quot;FILE&quot; &lt;&gt; help &quot;Input file&quot; ) pOutputFile :: Parser SingleOutput pOutputFile = OutputFile &lt;$&gt; parser -- fmap 과 &lt;$&gt; 는 같은 의미입니다. where parser = strOption ( long &quot;output&quot; &lt;&gt; short 'o' &lt;&gt; metavar &quot;FILE&quot; &lt;&gt; help &quot;Output file&quot; )  Applicative​ 이제 pInputFile :: Parser SingleInput과 pOutputFile :: Parser SingleOutput 두 개의 파서를 가지고 있습니다. 우리는 이 두 파서를 결합해 Options를 만들려고 합니다.SingleInput과 SingleOutput이 있다면 ConvertSingle 생성자를 사용해볼 수 있습니다: ConvertSingle :: SingleInput -&gt; SingleOutput -&gt; Options  혹시 이전에 fmap을 활용해 본 것처럼 비슷한 트릭을 사용할 수 있을까요? 이진 함수(binary function)를 리프트해 Parser에서도 동작하게 하는 함수가 존재할까요? 존재한다면 아마 이런 타입 시그니처를 가지고 있을 것입니다: ??? :: (SingleInput -&gt; SingleOutput -&gt; Options) -&gt; (Parser SingleInput -&gt; Parser SingleOutput -&gt; Parser Options)  네. 이런 함수가 존재합니다. 이 함수는 liftA2라고 불리며 Applicative 타입클래스에 정의되어 있습니다.Applicative (또는 applicative functor)는 세 개의 주요 함수를 가지고 있습니다: class Functor f =&gt; Applicative f where pure :: a -&gt; f a liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b  Applicative는 많은 인스턴스가 존재하는 또 다른 매우 인기있는 타입클래스입니다. 모든 Monoid는 Semigroup인 것처럼, 모든 Applicative은 Functor입니다. 이는 Applicative 인터페이스를 구현하고자 하는 타입은 Functor 인터페이스도 구현해야 한다는 것을 의미합니다. 특정 함수 f를 리프트 하는 일반적인 functor의 기능을 넘어, applicative functor는 타입 a를 f a로 &quot;리프트&quot;하는 것 외에도, 특정 f의 여러 인스턴스에 함수를 적용할 수 있습니다. 아마 pure는 이미 익숙할 것입니다. 예전에 IO에 대해 이야기할 때 보았을 것입니다.IO에 대해, pure는 IO를 수행하지 않고도 특정 반환 값을 가지는 IO 액션을 만들어줍니다.Parser에 대해 pure를 사용하면, 파싱을 하지 않고도 특정 값을 반환하는 Parser를 만들 수 있습니다. liftA2와 &lt;*&gt;는 둘 다 서로를 활용해 구현할 수 있는 함수입니다. 사실 &lt;*&gt;가 두 함수 중 더 유용합니다. 왜냐하면 fmap (또는 중위 연산자 &lt;$&gt;)과 함께 사용하면 두 개 이상의 많은 인자를 가진 함수에도 적용할 수 있기 때문입니다. 두 파서를 하나로 결합하기위해, liftA2 또는 &lt;$&gt;와 &lt;*&gt;의 조합을 사용할 수 있습니다: -- with liftA2 pConvertSingle :: Parser Options pConvertSingle = liftA2 ConvertSingle pInputFile pOutputFile -- with &lt;$&gt; and &lt;*&gt; pConvertSingle :: Parser Options pConvertSingle = ConvertSingle &lt;$&gt; pInputFile &lt;*&gt; pOutputFile  &lt;$&gt;와 &lt;*&gt;는 모두 왼쪽으로 결합되므로, 다음과 같은 보이지 않는 괄호가 있습니다: pConvertSingle :: Parser Options pConvertSingle = (ConvertSingle &lt;$&gt; pInputFile) &lt;*&gt; pOutputFile  위 코드가 타입체크에 성공하는지 증명하기 위해, 각 하위 표현식의 타입을 살펴봅시다: pConvertSingle :: Parser Options pInputFile :: Parser SingleInput pOutputFile :: Parser SingleOutput ConvertSingle :: SingleInput -&gt; SingleOutput -&gt; Options (&lt;$&gt;) :: (a -&gt; b) -&gt; Parser a -&gt; Parser b -- 여기서 `a`는 `SingleInput`이고 `b`는 `SingleOutput -&gt; Options`입니다. ConvertSingle &lt;$&gt; pInputFile :: Parser (SingleOutput -&gt; Options) (&lt;*&gt;) :: Parser (a -&gt; b) -&gt; Parser a -&gt; Parser b -- 여기서 `a -&gt; b`는 `SingleOutput -&gt; Options`이며, `a`는 `SingleOutput`이고 `b`는 `Options`입니다. -- 따라서 (ConvertSingle &lt;$&gt; pInputFile) &lt;*&gt; pOutputFile :: Parser Options  &lt;$&gt;과 &lt;*&gt;를 사용하면 원하는 만큼 많은 파서를 연결할 수 있습니다. 이는 커링(currying)과 매개변수 다형성(parametric polymorphism) 두 가지 이유 때문입니다. Haskell에서 함수는 정확히 하나의 인자를 받고 정확히 하나의 값을 반환하기 때문에, 여러 인자를 가진 함수는 a -&gt; b와 같이 표현할 수 있습니다. applicative functor의 법칙에 대한 내용은 Typeclassopedia글을 참고하세요. 이 글은 다양한 유용한 타입클래스와 그들의 법칙에 대해 이야기합니다. Applicative functor는 매우 중요한 개념이며 다양한 파서 인터페이스 (명령줄 뿐만아니라 JSON이나 일반적인 파서), I/O, 동시성, 비결정성 등에서 사용됩니다. 이 라이브러리의 이름이 optparse-applicative인 이유도 파서를 만들기 위해 Applicative 인터페이스를 주요 API로 사용하기 때문입니다.  연습문제: Options의 생성자 ConvertDir에 대해서도 유사한 인터페이스를 만드세요. 정답 pInputDir :: Parser FilePath pInputDir = strOption ( long &quot;input&quot; &lt;&gt; short 'i' &lt;&gt; metavar &quot;DIRECTORY&quot; &lt;&gt; help &quot;Input directory&quot; ) pOutputDir :: Parser FilePath pOutputDir = strOption ( long &quot;output&quot; &lt;&gt; short 'o' &lt;&gt; metavar &quot;DIRECTORY&quot; &lt;&gt; help &quot;Output directory&quot; ) pConvertDir :: Parser Options pConvertDir = ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir   Alternative​ 사실 ConvertSingle는 입출력으로 표준 입력과 출력을 사용할 수도 있습니다. 지금까지 --input과 --output 플래그를 사용하여 파일을 읽거나 쓰는 하나의 옵션만 제공했습니다. 이제 우리는 이 플래그를 선택적으로 사용할 수 있게해, 지정하지 않았다면 표준 입출력을 사용하도록 만들려고 합니다.Control.Applicative의 optional 함수를 사용하여 이를 수행할 수 있습니다: optional :: Alternative f =&gt; f a -&gt; f (Maybe a)  optional은 Alternative 타입 클래스의 인스턴스인 타입에 대해 작동합니다: class Applicative f =&gt; Alternative f where (&lt;|&gt;) :: f a -&gt; f a -&gt; f a empty :: f a  Alternative는 Monoid 타입 클래스와 매우 유사하지만, applicative functor에서 작동합니다. 이 타입 클래스는 자주 사용되지 않으며, 주로 파싱 라이브러리에서만 사용됩니다. 이는 두 개의 Parser를 결합할 수 있는 인터페이스를 제공합니다 - 첫 번째 파서가 파싱에 실패하면 다른 파서를 시도합니다. 또한 현재 우리에게 도움이 되는 optional과 같은 유용한 함수를 제공합니다. pSingleInput :: Parser SingleInput pSingleInput = fromMaybe Stdin &lt;$&gt; optional pInputFile pSingleOutput :: Parser SingleOutput pSingleOutput = fromMaybe Stdout &lt;$&gt; optional pOutputFile  fromMaybe :: a -&gt; Maybe a -&gt; a를 사용하여 Maybe 값을 a로 추출할 수 있습니다. 이는 Nothing이 아닌 경우에는 a를 반환하고, Nothing인 경우에는 기본값을 반환합니다. 이제 더 적절한 함수들을 사용해 pConvertSingle을 다시 작성할 수 있습니다: pConvertSingle :: Parser Options pConvertSingle = ConvertSingle &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput  명령과 서브파서​ 현재 인터페이스는 두 가지 가능한 동작을 가지고 있습니다. 단일 소스를 변환하거나 디렉토리를 변환하는 것입니다. 적절한 동작을 선택하기 위한 좋은 인터페이스는 명령을 통해 선택하는 것입니다. 사용자가 단일 소스를 변환하려면 convert, 디렉토리를 변환하려면 convert-dir를 사용할 수 있습니다. 우리는 subparser와 command 함수를 사용하여 이를 수행할 수 있습니다: subparser :: Mod CommandFields a -&gt; Parser a command :: String -&gt; ParserInfo a -&gt; Mod CommandFields a  subparser는 명령 수정자(command modifiers) (이는 command 함수로 만들 수 있습니다)를 입력으로 받아 Parser를 생성합니다.command는 명령 이름(&quot;convert&quot; 또는 &quot;convert-dir&quot;)과 ParserInfo a를 입력으로 받아 명령 수정자를 생성합니다. 이전에 보았던 것처럼 이러한 수정자들은 Monoid 인스턴스를 가지고 있으며, 여러 명령을 옵션으로 사용할 수 있도록 합칠 수 있습니다. ParserInfo a는 info 함수를 사용하여 생성할 수 있습니다: info :: Parser a -&gt; InfoMod a -&gt; ParserInfo a  이 함수는 주어진 Parser를 도움말, 설명과 같은 추가정보를 감싸, 프로그램과 각 서브 명령이 추가정보를 출력할 수 있도록 합니다. ParserInfo는 어떻게 만드는지 살펴보겠습니다: pConvertSingleInfo :: ParserInfo Options pConvertSingleInfo = info (helper &lt;*&gt; pConvertSingle) (progDesc &quot;Convert a single markup source to html&quot;)  helper는 파서가 실패할 때 출력할 도움말을 추가합니다. 명령도 생성해봅시다: pConvertSingleCommand :: Mod CommandFields Options pConvertSingleCommand = command &quot;convert&quot; pConvertSingleInfo  subparser를 사용하여 두 옵션을 결합해 Parser Options를 만들어보세요. 정답 pOptions :: Parser Options pOptions = subparser ( command &quot;convert&quot; ( info (helper &lt;*&gt; pConvertSingle) (progDesc &quot;Convert a single markup source to html&quot;) ) &lt;&gt; command &quot;convert-dir&quot; ( info (helper &lt;*&gt; pConvertDir) (progDesc &quot;Convert a directory of markup files to html&quot;) ) )  ParserInfo​ 이제 파서를 완성했으므로, ParserInfo로 감싸고 몇 가지 정보를 추가하여 실행할 준비가 되었습니다: opts :: ParserInfo Options opts = info (helper &lt;*&gt; pOptions) ( fullDesc &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot; &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot; )  ","version":"Next","tagName":"h3"},{"title":"파서 실행하기​","type":1,"pageTitle":"멋진 옵션 파싱","url":"/learn-haskell-blog-generator/glue/optparse#파서-실행하기","content":"optparse-applicative는 인자를 파싱하는데 IO를 사용하지 않는 인터페이스를 제공합니다. 하지만 가장 편리한 방법은 인자를 가져오고, 파싱을 시도하고, 실패하면 오류와 도움말 메시지를 출력하는 것을 optparse-applicative에 맡기는 것입니다. 이는 execParser :: ParserInfo a -&gt; IO a 함수로 수행할 수 있습니다. 새로운 모듈에 이러한 옵션을 파싱하는 코드를 작성하고, app/Main.hs에서 가져올 수 있습니다. 다음은 지금까지 작업한 코드입니다: app/OptParse.hs -- | 명령줄 옵션 파싱 module OptParse ( Options(..) , SingleInput(..) , SingleOutput(..) , parse ) where import Data.Maybe (fromMaybe) import Options.Applicative ------------------------------------------------ -- * 명령줄 옵션 모델 -- | 모델 data Options = ConvertSingle SingleInput SingleOutput | ConvertDir FilePath FilePath deriving Show -- | 단일 입력 소스 data SingleInput = Stdin | InputFile FilePath deriving Show -- | 단일 출력 sink data SingleOutput = Stdout | OutputFile FilePath deriving Show ------------------------------------------------ -- * Parser -- | 명령줄 옵션 파싱 parse :: IO Options parse = execParser opts opts :: ParserInfo Options opts = info (pOptions &lt;**&gt; helper) ( fullDesc &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot; &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot; ) -- | 모든 옵션에 대한 파서 pOptions :: Parser Options pOptions = subparser ( command &quot;convert&quot; ( info (helper &lt;*&gt; pConvertSingle) (progDesc &quot;Convert a single markup source to html&quot;) ) &lt;&gt; command &quot;convert-dir&quot; ( info (helper &lt;*&gt; pConvertDir) (progDesc &quot;Convert a directory of markup files to html&quot;) ) ) ------------------------------------------------ -- * 단일 소스를 위한 파서 -- | 단일 소스를 위한 옵션 파서 pConvertSingle :: Parser Options pConvertSingle = ConvertSingle &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput -- | 단일 입력 소스를 위한 파서 pSingleInput :: Parser SingleInput pSingleInput = fromMaybe Stdin &lt;$&gt; optional pInputFile -- | 단일 출력 sink를 위한 파서 pSingleOutput :: Parser SingleOutput pSingleOutput = fromMaybe Stdout &lt;$&gt; optional pOutputFile -- | 입력 파일 파서 pInputFile :: Parser SingleInput pInputFile = fmap InputFile parser where parser = strOption ( long &quot;input&quot; &lt;&gt; short 'i' &lt;&gt; metavar &quot;FILE&quot; &lt;&gt; help &quot;Input file&quot; ) -- | 출력 파일 파서 pOutputFile :: Parser SingleOutput pOutputFile = OutputFile &lt;$&gt; parser where parser = strOption ( long &quot;output&quot; &lt;&gt; short 'o' &lt;&gt; metavar &quot;FILE&quot; &lt;&gt; help &quot;Output file&quot; ) ------------------------------------------------ -- * 디렉토리 변환 파서 pConvertDir :: Parser Options pConvertDir = ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir -- | 입력 디렉토리 파서 pInputDir :: Parser FilePath pInputDir = strOption ( long &quot;input&quot; &lt;&gt; short 'i' &lt;&gt; metavar &quot;DIRECTORY&quot; &lt;&gt; help &quot;Input directory&quot; ) -- | 출력 디렉토리 파서 pOutputDir :: Parser FilePath pOutputDir = strOption ( long &quot;output&quot; &lt;&gt; short 'o' &lt;&gt; metavar &quot;DIRECTORY&quot; &lt;&gt; help &quot;Output directory&quot; )  ","version":"Next","tagName":"h3"},{"title":"Options에 대한 패턴 매칭​","type":1,"pageTitle":"멋진 옵션 파싱","url":"/learn-haskell-blog-generator/glue/optparse#options에-대한-패턴-매칭","content":"명령줄 파서를 실행하고 나면, 모델에 대한 패턴 매칭을 통해 올바른 함수를 호출할 수 있습니다. 현재 프로그램은 이러한 종류의 API를 노출하지 않습니다. 따라서 src/HsBlog.hs 모듈로 이동하고 API를 변경합니다.main을 삭제하고 대신 두 개의 새 함수를 추가할 수 있습니다: convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO () convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()  Handle은 파일 시스템 객체에 대한 I/O 추상화입니다. stdin과 stdout를 포함합니다. 이전에는 writeFile과 getContents를 사용했습니다. - 이 함수들은 Handle이 표준 I/O라고 가정하거나, FilePath를 열고 작업할 수 있습니다. 이제는 System.IO에서 Handle을 가져오는 명시적인 버전을 사용할 수 있습니다: convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO () convertSingle title input output = do content &lt;- hGetContents input hPutStrLn output (process title content)  지금은 convertDirectory의 구현은 남겨두고, 다음 장에서 구현하겠습니다. app/Main.hs에서 Options에 대한 패턴 매칭이 필요하며 HsBlog의 함수들을 호출해야 합니다. app/Main.hs와 src/HsBlog.hs의 전체 코드를 살펴보겠습니다: app/Main.hs -- | hs-blog-gen 프로그램의 진입점 module Main where import OptParse import qualified HsBlog import System.Exit (exitFailure) import System.Directory (doesFileExist) import System.IO main :: IO () main = do options &lt;- parse case options of ConvertDir input output -&gt; HsBlog.convertDirectory input output ConvertSingle input output -&gt; do (title, inputHandle) &lt;- case input of Stdin -&gt; pure (&quot;&quot;, stdin) InputFile file -&gt; (,) file &lt;$&gt; openFile file ReadMode outputHandle &lt;- case output of Stdout -&gt; pure stdout OutputFile file -&gt; do exists &lt;- doesFileExist file shouldOpenFile &lt;- if exists then confirm else pure True if shouldOpenFile then openFile file WriteMode else exitFailure HsBlog.convertSingle title inputHandle outputHandle hClose inputHandle hClose outputHandle ------------------------------------------------ -- * Utilities -- | Confirm user action confirm :: IO Bool confirm = putStrLn &quot;Are you sure? (y/n)&quot; *&gt; getLine &gt;&gt;= \\answer -&gt; case answer of &quot;y&quot; -&gt; pure True &quot;n&quot; -&gt; pure False _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt; confirm  src/HsBlog.hs -- HsBlog.hs module HsBlog ( convertSingle , convertDirectory , process ) where import qualified HsBlog.Markup as Markup import qualified HsBlog.Html as Html import HsBlog.Convert (convert) import System.IO convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO () convertSingle title input output = do content &lt;- hGetContents input hPutStrLn output (process title content) convertDirectory :: FilePath -&gt; FilePath -&gt; IO () convertDirectory = error &quot;Not implemented&quot; process :: Html.Title -&gt; String -&gt; String process title = Html.render . convert title . Markup.parse  .cabal 파일에 몇 가지 작은 수정이 필요합니다. 먼저, executable 섹션에 directory 의존성을 추가해야 합니다. 왜냐하면 Main에서 System.Directory 라이브러리를 사용하기 때문입니다. 다음으로, OptParse 모듈을 executable 섹션의 other-modules에 추가해야 합니다.  executable hs-blog-gen import: common-settings hs-source-dirs: app main-is: Main.hs + other-modules: + OptParse build-depends: base + , directory , optparse-applicative , hs-blog ghc-options: -O  ","version":"Next","tagName":"h3"},{"title":"요약​","type":1,"pageTitle":"멋진 옵션 파싱","url":"/learn-haskell-blog-generator/glue/optparse#요약","content":"지금까지 optparse-applicative 라이브러리에 대해 배웠습니다. 이 라이브러리는 선언적인 방법으로 강력한 명령줄 인터페이스를 만드는 데 사용할 수 있습니다.hs-blog-gen --help (또는 이전 장에서 논의한 cabal/stack 명령어를 사용해서)를 실행해, 결과를 확인해 보세요: hs-blog-gen - a static blog generator Usage: hs-blog-gen COMMAND Convert markup files or directories to html Available options: -h,--help Show this help text Available commands: convert Convert a single markup source to html convert-dir Convert a directory of markup files to html  그동안 우리는 Functor와 Applicative이라는 두 가지 강력한 새로운 추상화를 배웠습니다. 또한 Monoid라는 추상화를 다시 살펴보았습니다. 이 라이브러리를 통해 이러한 추상화가 API와 DSL을 구축하는 데 얼마나 유용한지 알아보았습니다. 우리는 이 책의 나머지 부분에서 이러한 추상화를 계속 만나게 될 것입니다.  추가 연습문제: 출력 파일이나 디렉토리가 이미 존재하는 경우에도 덮어써도 괜찮다는 것을 의미하는 --replace 플래그를 추가하세요.  Git 커밋을 통해이번에 수정한 내역과 현재까지 코드 를 확인할 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"문자 이스케이프 처리하기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/escaping-characters","content":"","keywords":"","version":"Next"},{"title":"연결 리스트​","type":1,"pageTitle":"문자 이스케이프 처리하기","url":"/learn-haskell-blog-generator/html/escaping-characters#연결-리스트","content":"하스켈에서 연결 리스트(linked lists)는 매우 일반적인 데이터 구조입니다. 그래서 이를 위한 특별한 구문(syntax)이 존재합니다: 리스트의 유형은 대괄호로 표시되며 대괄호 안에는 요소의 타입이 있습니다. 예를 들어: [Int] - 정수의 리스트[Char] - 문자의 리스트[String] - 문자열의 리스트[[String]] - 문자열의 리스트의 리스트[a] - 임의의 단일 유형의 리스트 (모든 요소는 동일한 타입이어야 함) 빈 리스트는 다음과 같이 작성됩니다: []리스트에 요소를 추가하는 것은 : 연산자를 사용하여 수행합니다 (이를 cons라고 함). 이 연산자는 오른쪽 결합성(right-associative)을 가집니다 (예: -&gt;). 예를 들어: 1 : [], 또는 1 : 2 : 3 : [].위 리스트는 다음과 같이 작성할 수 있습니다: [1] 및 [1, 2, 3]. 또한, 문자열은 문자의 연결 리스트입니다 - 문자열은 다음과 같이 정의됩니다:type String = [Char]이므로 우리는 문자열을 리스트와 동일한 방식으로 사용할 수 있습니다. 노트 연결 리스트는 편리한 데이터 구조이지만, 모든 경우에 적합한 것은 아닙니다. 특히 공간 효율성이 떨어지고, 데이터 추가, 임의 접근(random access) 등에 느립니다. 따라서 String을 사용하는 것이 효율적이지 않을 수 있습니다. 그래서 외부 패키지에서 제공하는 Text라는 다른 문자열 타입을 사용하는 것을 권장합니다.Text와 다른 데이터 구조에 대해서는 이후에 다루겠습니다! 리스트에 대한 연산을 패턴 매칭과 재귀(recursion)를 사용하여 구현할 수 있습니다. 이에 대한 자세한 내용은 ADT를 소개할 때 다루겠습니다. 지금은, Data.List 모듈에 있는 다양한 함수를 사용하겠습니다. 그 중에서 map과concat 함수를 사용하겠습니다. ","version":"Next","tagName":"h2"},{"title":"map​","type":1,"pageTitle":"문자 이스케이프 처리하기","url":"/learn-haskell-blog-generator/html/escaping-characters#map","content":"map을 사용하면 리스트의 각 요소에 함수를 적용할 수 있습니다. 이 함수의 타입 시그니처는 다음과 같습니다: map :: (a -&gt; b) -&gt; [a] -&gt; [b]  예를 들면: map not [False, True, False] == [True, False, True]  또는 이전에 정의한 escape 함수처럼, 각 문자열을 이스케이프할 때 사용할 수 있습니다: map escapeChar ['&lt;','h','1','&gt;'] == [&quot;&amp;lt;&quot;,&quot;h&quot;,&quot;1&quot;,&quot;&amp;gt;&quot;]  하지만 escapeChar의 타입은 Char -&gt; String이므로,map escapeChar ['&lt;','h','1','&gt;']의 반환 타입은 [String]이자만, 원하는 것은 String입니다. 그래서 리스트를 평평하게(flatten) 만들어 줄 concat 함수가 필요합니다. ","version":"Next","tagName":"h3"},{"title":"concat​","type":1,"pageTitle":"문자 이스케이프 처리하기","url":"/learn-haskell-blog-generator/html/escaping-characters#concat","content":"concat의 타입은 다음과 같습니다: concat :: [[a]] -&gt; [a]  이 함수는 리스트의 리스트를 받아서 리스트를 반환합니다. 예제의 경우, concat은 [String]을 받아서 String을 반환합니다.String은 [Char]의 타입 별칭(type alias)이므로, 실제로는 [[Char]] -&gt; [Char]입니다. ","version":"Next","tagName":"h3"},{"title":"GHCi​","type":1,"pageTitle":"문자 이스케이프 처리하기","url":"/learn-haskell-blog-generator/html/escaping-characters#ghci","content":"우리가 작성한 코드를 빠르게 확인하는 방법 중 하나는 GHCi라는 대화식 개발 환경(interactive development environment)을 사용하는 것입니다.ghci를 실행하면 대화식 프롬프트가 열리고, 하스켈 표현식을 작성하고 평가할 수 있습니다. 이를 &quot;Read-Evaluate-Print Loop&quot; (REPL)이라고 합니다. 예를 들면: ghci&gt; 1 + 1 2 ghci&gt; putStrLn &quot;Hello, world!&quot; Hello, world!  새로운 이름도 정의할 수 있습니다: ghci&gt; double x = x + x ghci&gt; double 2 4  :{와 :}로 코드 블록을 감싸면 여러 줄의 코드를 작성할 수 있습니다: ghci&gt; :{ | escape :: String -&gt; String | escape = | let | escapeChar c = | case c of | '&lt;' -&gt; &quot;&amp;lt;&quot; | '&gt;' -&gt; &quot;&amp;gt;&quot; | '&amp;' -&gt; &quot;&amp;amp;&quot; | '&quot;' -&gt; &quot;&amp;quot;&quot; | '\\'' -&gt; &quot;&amp;#39;&quot; | _ -&gt; [c] | in | concat . map escapeChar | :} ghci&gt; escape &quot;&lt;html&gt;&quot; &quot;&amp;lt;html&amp;gt;&quot;  하스켈 소스 파일은 :load(또는 :l로 줄여서) 명령어로 불러올 수 있습니다: ghci&gt; :load Html.hs [1 of 1] Compiling Html ( Html.hs, interpreted ) Ok, one module loaded. ghci&gt; render (html_ &quot;&lt;title&gt;&quot; (p_ &quot;&lt;body&gt;&quot;)) &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&amp;lt;title&amp;gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;  라이브러리 모듈도 불러올 수 있습니다: ghci&gt; import Data.Bits ghci&gt; shiftL 32 1 64 ghci&gt; clearBit 33 0 32  표현식의 타입을 알고 싶다면 :type(또는 :t로 줄여서) 명령어를 사용할 수도 있습니다: λ&gt; :type escape escape :: String -&gt; String  ghci를 종료하려면, :quit(또는 :q로 줄여서) 명령어를 사용합니다: ghci&gt; :quit Leaving GHCi.  GHCi는 빠른 실험과 탐색에 유용한 도구입니다. 위에서 몇 가지 예를 보았습니다 - escape 함수에 문자열 &quot;&lt;html&gt;&quot;을 전달하면 &quot;&amp;lt;html&amp;gt;&quot;라는 문자열을 반환합니다. 이 문자열은 브라우저에서 HTML 태그 대신 &lt;html&gt;로 렌더링됩니다. 만약 특정한 함수가 무엇을 하는지 이해하기 어렵다면, GHCi에서 테스트해보세요. 다양한 입력을 넣어보고, 예상한 결과와 일치하는지 확인하세요. 구체적인 예제를 실행하는 것은 코드를 이해하는 데 많은 도움이 될 수 있습니다! 팁 GHCi에 대해 더 자세히 알고 싶다면, GHC 사용자 가이드에서 더 자세한 소개를 찾을 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"이스케이프​","type":1,"pageTitle":"문자 이스케이프 처리하기","url":"/learn-haskell-blog-generator/html/escaping-characters#이스케이프","content":" 현재 우리가 작성한 라이브러리는 오직 다음 항목만 지원합니다: 페이지 제목문단제목 더 진행하기 전에, escape 함수를 적용해 HTML 생성을 안전하게 만들려고 합니다. escape 함수를 적용해보세요. 정답 html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; (escape title)) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot; . escape h1_ :: String -&gt; Structure h1_ = Structure . el &quot;h1&quot; . escape   수정된 Html.hs Html.hs module Html ( Html , Title , Structure , html_ , p_ , h1_ , append_ , render ) where -- * Types newtype Html = Html String newtype Structure = Structure String type Title = String -- * EDSL html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; (escape title)) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot; . escape h1_ :: String -&gt; Structure h1_ = Structure . el &quot;h1&quot; . escape append_ :: Structure -&gt; Structure -&gt; Structure append_ c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) -- * Render render :: Html -&gt; String render html = case html of Html str -&gt; str -- * Utilities el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; getStructureString :: Structure -&gt; String getStructureString content = case content of Structure str -&gt; str escape :: String -&gt; String escape = let escapeChar c = case c of '&lt;' -&gt; &quot;&amp;lt;&quot; '&gt;' -&gt; &quot;&amp;gt;&quot; '&amp;' -&gt; &quot;&amp;amp;&quot; '&quot;' -&gt; &quot;&amp;quot;&quot; '\\'' -&gt; &quot;&amp;#39;&quot; _ -&gt; [c] in concat . map escapeChar  hello.hs 파일에서 유효하지 않은 HTML을 제공하면 제대로 동작하는지 확인해보세요! 이제 우리는 작은 HTML 라이브러리를 안전하게 사용할 수 있습니다. 그러나 사용자가 예상하지 못한 유효한 사용 사례, 예를 들어 순서 없는 목록을 추가하려는 경우에는 어떻게 해야 할까요? 우리는 라이브러리를 확장하는 것을 완전히 막고 있습니다. 다음에는 이에 대해 이야기 해보겠습니다. ","version":"Next","tagName":"h2"},{"title":"연습문제","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/exercises","content":"","keywords":"","version":"Next"},{"title":"1. 순서 없는 목록​","type":1,"pageTitle":"연습문제","url":"/learn-haskell-blog-generator/html/exercises#1-순서-없는-목록","content":"HTML에서 순서 없는 목록은 다음 형태를 가집니다: &lt;ul&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;/ul&gt;  라이브러리에 다음 함수를 추가하고자 합니다: ul_ :: [Structure] -&gt; Structure  이제 사용자는 다음과 같이 작성할 수 있습니다: ul_ [ p_ &quot;item 1&quot; , p_ &quot;item 2&quot; , p_ &quot;item 3&quot; ]  그리고 다음 결과를 얻습니다: &lt;ul&gt; &lt;li&gt;&lt;p&gt;item 1&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;item 2&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;item 3&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt;  ","version":"Next","tagName":"h2"},{"title":"2. 순서 있는 목록​","type":1,"pageTitle":"연습문제","url":"/learn-haskell-blog-generator/html/exercises#2-순서-있는-목록","content":"순서없는 목록과 유사하지만, &lt;ul&gt; 대신 &lt;ol&gt;을 사용합니다. ","version":"Next","tagName":"h2"},{"title":"3. 코드 블록​","type":1,"pageTitle":"연습문제","url":"/learn-haskell-blog-generator/html/exercises#3-코드-블록","content":"&lt;p&gt;와 유사하지만, &lt;pre&gt; 태그를 사용합니다. code_라는 함수를 정의하세요. ","version":"Next","tagName":"h2"},{"title":"정답​","type":1,"pageTitle":"연습문제","url":"/learn-haskell-blog-generator/html/exercises#정답","content":"순서없는 목록 ul_ :: [Structure] -&gt; Structure ul_ = Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString)  순서있는 목록 ol_ :: [Structure] -&gt; Structure ol_ = Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString) 노트 위 두 함수를 하나의 함수로 합칠 수 있습니다. 코드 블록 code_ :: String -&gt; Structure code_ = Structure . el &quot;pre&quot; . escape  ","version":"Next","tagName":"h2"},{"title":"유연한 HTML 콘텐츠 (함수)","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/html-content","content":"","keywords":"","version":"Next"},{"title":"들여쓰기​","type":1,"pageTitle":"유연한 HTML 콘텐츠 (함수)","url":"/learn-haskell-blog-generator/html/html-content#들여쓰기","content":"하스켈은 어떻게 정의가 완료되었는지 알 수 있을까요? 정답은 하스켈은 들여쓰기를 사용하여 표현식이 어떻게 그룹화되어야 하는지 알 수 있다는 것입니다. 하스켈의 들여쓰기 법칙은 약간 까다로울 수 있지만, 일반적으로 다음과 같습니다: 표현식의 일부가 되어야 하는 코드는 해당 표현식의 시작보다 더 들여쓰기되어야 합니다. 만약 두 표현식이 동일한 들여쓰기를 가지고 있다면, 이들은 서로 독립적이라고 할 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"들여쓰기 팁​","type":1,"pageTitle":"유연한 HTML 콘텐츠 (함수)","url":"/learn-haskell-blog-generator/html/html-content#들여쓰기-팁","content":"들여쓰기할 공백의 개수를 선택하고 (2개, 4개 등) 이를 유지하세요. 탭보다는 공백을 사용하세요.한 번에 두 번 이상 들여쓰기를 하지 마십시오.확실하지 않은 경우 필요에 따라 줄을 삭제하고 한 번 들여쓰기합니다. 다음과 같은 예제가 있습니다: main = putStrLn &quot;Hello, world!&quot;  또는: main = putStrLn (wrapHtml &quot;Hello, world!&quot;)  다음 스타일은 피하세요. 들여쓰기 단계를 두 개 이상 사용하거나 완전히 무시하고 있습니다: main = putStrLn (wrapHtml &quot;Hello, world!&quot;)  main = putStrLn (wrapHtml &quot;Hello, world!&quot;)  ","version":"Next","tagName":"h3"},{"title":"내부 기능 노출하기 (내부 모듈)","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/internal-modules","content":"","keywords":"","version":"Next"},{"title":"내부 모듈​","type":1,"pageTitle":"내부 기능 노출하기 (내부 모듈)","url":"/learn-haskell-blog-generator/html/internal-modules#내부-모듈","content":"이를 위해 내부 모듈을 노출하여 고급 사용자에게 일부 유연성을 제공할 수 있습니다. 내부 모듈은 언어 개념이 아니라 하스켈에서 흔히 볼 수 있는 디자인 패턴(또는 관용구)입니다. 내부 모듈은 &lt;something&gt;.Internal과 같이 이름이 지정된 모듈로, 해당 모듈의 모든 기능과 구현 세부 사항을 노출합니다. 예를 들어, 내부 구현을 Html 모듈에 작성하는 대신 모든 항목을 내보내는 Html.Internal 모듈에 작성합니다. 그리고 해당 모듈을 Html 모듈에 가져와서 (이전처럼) 우리가 원하는 API만 명시적으로 내보냅니다. Internal 모듈은 보통 불안정하고 사용하기 위험하다고 알려져 있습니다. 만약 외부 하스켈 라이브러리를 사용할 때 Internal 모듈을 사용하게 되면, 모든 문제를 해결하고 나서 라이브러리 저장소에 이슈를 열어주세요! ","version":"Next","tagName":"h3"},{"title":"수정하기​","type":1,"pageTitle":"내부 기능 노출하기 (내부 모듈)","url":"/learn-haskell-blog-generator/html/internal-modules#수정하기","content":"이제 Html 이라는 디렉터리를 만들고 그 안에 Internal.hs라는 파일을 만듭니다. 이 모듈의 이름은 Html.Internal이어야 합니다. 이 모듈은 이전에 Html 모듈에 있었던 모든 코드를 포함하지만, 모듈 선언문을 수정해 내보내기 목록을 생략할 것입니다: Html/Internal.hs module Html.Internal where ...  이제 Html.hs 파일에서 Html/Internal.hs로 옮긴 코드를 제거하고 대신 내부 모듈을 가져옵니다: Html.hs module Html ( Html , Title , Structure , html_ , p_ , h1_ , append_ , render ) where import Html.Internal  이제 사용자는 Html 모듈을 가져와 안전하게 라이브러리를 사용할 수 있습니다. 만약 사용자가 라이브러리를 통해 순서없는 목록(ul, ui 태그)기능을 구현하고 싶다면, Html.Internal 모듈을 사용할 수 있습니다. 수정된 Html.hs 과 Html/Internal.hs Html.hs module Html ( Html , Title , Structure , html_ , p_ , h1_ , append_ , render ) where import Html.Internal Html/Internal.hs module Html.Internal where -- * Types newtype Html = Html String newtype Structure = Structure String type Title = String -- * EDSL html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; (escape title)) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot; . escape h1_ :: String -&gt; Structure h1_ = Structure . el &quot;h1&quot; . escape append_ :: Structure -&gt; Structure -&gt; Structure append_ c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) -- * Render render :: Html -&gt; String render html = case html of Html str -&gt; str -- * Utilities el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; getStructureString :: Structure -&gt; String getStructureString content = case content of Structure str -&gt; str escape :: String -&gt; String escape = let escapeChar c = case c of '&lt;' -&gt; &quot;&amp;lt;&quot; '&gt;' -&gt; &quot;&amp;gt;&quot; '&amp;' -&gt; &quot;&amp;amp;&quot; '&quot;' -&gt; &quot;&amp;quot;&quot; '\\'' -&gt; &quot;&amp;#39;&quot; _ -&gt; [c] in concat . map escapeChar  ","version":"Next","tagName":"h3"},{"title":"요약​","type":1,"pageTitle":"내부 기능 노출하기 (내부 모듈)","url":"/learn-haskell-blog-generator/html/internal-modules#요약","content":"사실 우리 프로젝트 내에서만 사용한다면, Internal 모듈은 필요하지 않습니다. 프로그램과 HTML EDSL의 소스 코드는 동일한 프로젝트에 있으며, Html 모듈에 직접 접근 할 수 있기 때문입니다. 우리는 원할 때 언제든지 모듈을 수정 할 수 있습니다. 하지만 만약 다른 개발자가 사용하기 위해 HTML EDSL을 라이브러리로 출시하려고 한다면, 사용자가 내부 구현에 접근할 수 있도록 Internal 모듈을 노출하는 것이 좋습니다. 이렇게 하면 사용자가 라이브러리를 사용하는 데 어려움을 겪지 않을 수 있습니다! 소스 코드로부터 패키지를 만드는 방법에 대해서는 이후에 다룰 예정입니다. ","version":"Next","tagName":"h2"},{"title":"모듈을 사용하여 잘못된 사용 방지하기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/modules","content":"","keywords":"","version":"Next"},{"title":"모듈​","type":1,"pageTitle":"모듈을 사용하여 잘못된 사용 방지하기","url":"/learn-haskell-blog-generator/html/modules#모듈","content":"각 하스켈 소스 파일은 모듈입니다. 모듈 이름은 소스 파일 이름과 같아야 하며 대문자로 시작해야 합니다. 하위 디렉토리도 모듈 이름에 포함되어야 하며 하위 디렉토리를 나타내기 위해 .을 사용합니다. 다음 장에서 이를 자세히 살펴보겠습니다. 위 규칙의 유일한 예외는 프로그램의 진입점 모듈입니다.main의 정의가 존재하는 이름이 'Main'인 모듈을 말합니다. 이 모듈의 소스 파일 이름은 원하는 대로 지을 수 있습니다. 모듈 정의는 다음과 같습니다: module &lt;모듈 이름&gt; ( &lt;내보내기(export) 목록&gt; ) where  모듈 내의 모든 항목을 내보내고 싶다면 내보내기 목록을 생략할 수 있지만 그렇게 하지 않겠습니다. 우리의 작은 라이브러리를 사용하는 방법을 제어하기 위해 원하는 함수와 타입만 내보내겠습니다. Html.hs라는 이름의 새 소스 파일을 만들고 다음과 같이 모듈 선언 코드를 파일 상단에 추가합니다: module Html ( Html , Title , Structure , html_ , p_ , h1_ , append_ , render ) where  다음 항목은 내보내지 않습니다: 새로 정의한 타입의 생성자는 제외하고 타입만 내보냅니다. 생성자도 내보내고 싶다면 Html(Html) 또는 Html(..)와 같이 작성하면 됩니다. 이렇게 하면 사용자가 Structure &quot;Hello&quot;와 같이 직접 Structure를 만들 수 없습니다. 라이브러리가 사용하는 내부 함수, 예를 들어 el과 getStructureString입니다. hello.hs 파일에서 HTML과 관련된 함수들도 Html.hs로 옮깁니다: newtype Html = Html String newtype Structure = Structure String type Title = String html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; title) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot; h1_ :: String -&gt; Structure h1_ = Structure . el &quot;h1&quot; el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; append_ :: Structure -&gt; Structure -&gt; Structure append_ c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) getStructureString :: Structure -&gt; String getStructureString content = case content of Structure str -&gt; str render :: Html -&gt; String render html = case html of Html str -&gt; str  이제 import구문을 사용해서 이 모듈을 가져오는 경우 우리가 내보낸 것만 가져올 수 있습니다. hello.hs 파일 상단에 다음 코드를 추가합니다: import Html  이제 hello.hs 파일은 다음과 같이 변경됩니다: hello.hs import Html main :: IO () main = putStrLn (render myhtml) myhtml :: Html myhtml = html_ &quot;My title&quot; ( append_ (h1_ &quot;Heading&quot;) ( append_ (p_ &quot;Paragraph #1&quot;) (p_ &quot;Paragraph #2&quot;) ) )  그리고 Html.hs 파일은 다음과 같이 변경됩니다: Html.hs module Html ( Html , Title , Structure , html_ , p_ , h1_ , append_ , render ) where newtype Html = Html String newtype Structure = Structure String type Title = String html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; title) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot; h1_ :: String -&gt; Structure h1_ = Structure . el &quot;h1&quot; el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; append_ :: Structure -&gt; Structure -&gt; Structure append_ c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) getStructureString :: Structure -&gt; String getStructureString content = case content of Structure str -&gt; str render :: Html -&gt; String render html = case html of Html str -&gt; str  정보 HTML 값을 만드는 함수의 접미사로 밑줄(_)을 사용한것을 눈치채신 분도 있을겁니다. 이는 미학적인 결정으로, 개인적으로 EDSL을 더 쉽게 인식할 수 있다고 생각했기 때문입니다. 또한 head와 같은 하스켈 표준 라이브러리에 정의된 함수와의 이름 충돌을 피할 수 있기에 유용합니다. 이 아이디어는 lucid라는 하스켈 HTML 라이브러리에서 가져왔습니다! ","version":"Next","tagName":"h2"},{"title":"타입으로 안전한 HTML 구성하기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/safer-construction","content":"","keywords":"","version":"Next"},{"title":"newtype​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#newtype","content":"newttype 선언은 기존 값 집합에 대해 새로운 타입을 정의하는 방법입니다. 이는 기존 값을 재사용하지만 다른 의미를 부여하고 두 가지를 혼동되지 않도록 하기에 유용합니다. 예를 들어, 초, 분, 그램, 엔을 정수 값으로 표현할 수 있지만, 초와 그램을 잘못 섞어 쓰는걸 원하진 않을것입니다. 우리가 만드는 프로그램의 경우 구조화된 HTML을 텍스트 값으로 표현하고 싶지만, 유효한 HTML이 아닌 평범한 문자열과 구분하고 싶습니다. newtype 선언은 다음과 같이 생겼습니다: newtype &lt;타입 이름&gt; = &lt;생성자&gt; &lt;기존 타입&gt;  예를들면 Html 타입을 다음과 같이 정의할 수 있습니다: newtype Html = Html String  등호 왼쪽의 Html은 타입 이름 공간(namespace)에 존재합니다. 즉, :: 뒤에만 나올 수 있는 이름입니다. 등호 오른쪽의 Html은 표현식 (혹은 terms/values) 이름 공간에 존재합니다. 즉, 표현식에서만 나올 수 있는 이름입니다. (곧 그 위치를 살펴보겠습니다). 두 이름, &lt;타입 이름&gt;과 &lt;생성자&gt;는 같을 필요는 없지만, 일반적으로 같습니다. 그리고 두 이름 모두 대문자로 시작해야 합니다. newtype 선언의 오른쪽은 해당 타입의 모양을 의미합니다. 위의 경우, Html 타입의 값은 Html 생성자와 그 뒤에 오는 문자열 타입의 표현식을 가지고 있습니다. 예를 들면 Html &quot;hello&quot; 또는 Html (&quot;hello &quot; &lt;&gt; &quot;world&quot;)가 될 수 있습니다. 생성자는 인자를 받아서 새로운 타입의 반환하는 함수로 생각할 수 있습니다: Html :: String -&gt; Html  주의 Html 타입의 표현식을 String 타입의 표현식과 같은 방식으로 사용할 수 없습니다. 즉, &quot;hello &quot; &lt;&gt; Html &quot;world&quot;는 타입 에러가 발생합니다. 이것은 캡슐화(encapsulation)가 필요할 때 유용합니다. 기본 타입에 대한 표현과 함수를 정의하고 사용할 수 있지만, 관련 없는(우리 도메인과 관련이 없는) 타입들과 혼동되지 않도록 합니다. 미터와 피트가 모두 숫자가 될 수 있지만, 우리는 변환 없이 실수로 미터와 피트를 더하는 것을 원치 않습니다.  이제 유용한 몇 가지 타입을 더 만들어 보겠습니다. 우리는 다음 두 가지 타입을 사용할 것입니다: 완전한 HTML 문서&lt;body&gt; 태그 안에 들어갈 수 있는 제목과 문단과 같은 HTML 구조에 대한 타입 우리는 두 가지 타입이 혼용되지 않기를 원합니다. 정답 newtype Html = Html String newtype Structure = Structure String   ","version":"Next","tagName":"h2"},{"title":"newtype 사용하기​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#newtype-사용하기","content":"newtype이 감싸고 있는 내부 타입을 사용하려면, 우선 그 타입을 추출해야 합니다. 이를 위해 패턴 매칭을 사용합니다. 패턴 매칭은 두 가지 방법으로 사용할 수 있습니다. 하나는 case 표현식이고, 다른 하나는 함수 정의입니다. case 표현식은 switch 표현식과 비슷하며 다음과 같이 생겼습니다: case &lt;표현식&gt; of &lt;패턴&gt; -&gt; &lt;표현식&gt; ... &lt;패턴&gt; -&gt; &lt;표현식&gt; &lt;표현식&gt;은 추출하고자 하는 것이고, &lt;패턴&gt;은 그것의 구체적인 모양입니다. 예를 들어, Structure 타입을 정의했다고 가정해 봅시다. 이 타입의 String 값을 추출하고 싶다면 다음과 같이 합니다: getStructureString :: Structure -&gt; String getStructureString struct = case struct of Structure str -&gt; str 이렇게 하면 Structure에서 String을 추출하고 반환할 수 있습니다. 이후 장에서 data 선언을 소개할 것입니다. (이는 struct + enum의 혼성체와 비슷합니다.) 여기서는 여러 생성자를 가진 타입을 정의할 수 있습니다. 그러면 case 표현식의 여러 패턴이 더 의미가 있게 될 것입니다. 다른 방법으로, 함수를 정의할 때, 인자에 대해 패턴 매칭을 사용할 수 있습니다: func &lt;패턴&gt; = &lt;표현식&gt; 예를 들면: getStructureString :: Structure -&gt; String getStructureString (Structure str) = str 이제 이전에 정의한 html_, body_, p_ 등의 함수를 String 대신에 새로운 타입을 사용하도록 변경할 수 있습니다. 그 전에, 우리의 코드를 더 간결하게 만들 수 있는 또 다른 연산자를 만나보겠습니다. newtype의 또 다른 유용한 점은, 표현식을 감싸고 추출하는 것이 실제로는 성능에 영향을 주지 않는다는 것입니다! 컴파일러는 newtype 생성자의 감싸고 추출하는 것을 제거하고 기본 타입을 사용합니다. 우리가 정의한 타입과 생성자는 오직 우리가 코드를 작성할 때 기존 타입과 새로운 타입을 구분하는 데 도움을 주는 것이고,코드가 실행 중에는 필요하지 않습니다. newtype은 타입 안전성을 제공하면서도 성능에 영향을 주지 않습니다! ","version":"Next","tagName":"h2"},{"title":"함수 합성​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#함수-합성","content":"또 다른 흥미롭고 굉장히 자주 쓰이는 연산자로 (하스켈 일반 라이브러리 함수인) . (compose)가 있습니다. 이 연산자는 수학에서 알고 있는 합성 연산자(∘)와 비슷하게 생겼습니다. 연산자의 타입과 구현을 살펴보겠습니다: (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c (.) f g x = f (g x)  이 연산자는 3 개의 인자를 받습니다: 두 개의 함수(여기서는 f와 g라고 부릅니다)와 세 번째 인자 x입니다. 그런 다음 x를 두 번째 함수 g에 전달하고, g x의 결과를 첫 번째 함수 f에 전달합니다. g 함수가 a 타입의 값을 받고 b 타입의 값을 반환하고, f 함수가 b 타입의 값을 받고 c 타입의 값을 반환한다는 점을 주목하세요. 또 다른 주목해야 할 점으로 소문자로 시작하는 타입이 있는데 이는 타입 변수(type variables)라 합니다. 이는 일반적인 변수와 비슷합니다. content는 hello나 world처럼 어떤 문자열이 될 수 있듯이, 타입 변수는 Bool, String, String -&gt; String 등 어떤 타입이 될 수 있습니다. 이러한 기능을 매개변수 다형성(parametric polymorphism)이라고 합니다. (다른 언어에서는 이를 제네릭(generics)이라고 부릅니다.) 주의해야 할 점은 타입 변수는 반드시 서명(signature)과 일치해야 한다는 것입니다. 예를 들어, a -&gt; a라는 서명을 가진 함수를 정의하려고 한다면, 입력 타입과 반환 타입은 반드시 일치해야 하지만, 어떤 타입이든 될 수 있습니다. 그래서 이 서명을 가진 함수를 구현하는 유일한 방법은 다음과 같습니다: id :: a -&gt; a id x = x  항등 함수를 의미하는 id는 받은 값을 그대로 반환합니다. 만약 다른 방법을 사용하려고 하면, 예를 들어 &quot;hello&quot;와 같은 임의의 값을 반환하거나,x를 알고 있는 타입의 값처럼 사용해 x + x와 같은 표현식을 작성하면, 타입 오류가 발생합니다. -&gt; 연산자는 오른쪽으로 결합되는 것을 기억하시나요? 이 서명은 다음과 같이 해석할 수 있습니다: (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)  이는 마치 함수가 두 함수를 받아서 합성한 함수를 반환하는 것처럼 보이지 않나요? 이제 이 연산자를 사용해 HTML 함수를 다시 작성해보겠습니다.p_ 함수부터 시작해보겠습니다. 기존 정의는 다음과 같았습니다: p_ :: String -&gt; String p_ = el &quot;p&quot;  이제, 다음과 같이 작성할 수 있습니다: p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot;  p_ 함수는 문단을 의미하는 임의의 String을 받아서 &lt;p&gt;와 &lt;/p&gt; 태그로 감싼 후, 타입을 더 자세히 살펴보겠습니다: Structure :: String -&gt; Structureel &quot;p&quot; :: String -&gt; String(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)Structure . el &quot;p&quot; :: String -&gt; Structure 표현식 Structure . el &quot;p&quot;가 타입 검사를 통과하는 이유와, 타입이 String -&gt; Structure인 이유를 살펴보겠습니다. ","version":"Next","tagName":"h2"},{"title":"펜과 종이로 타입 검사하기​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#펜과-종이로-타입-검사하기","content":"표현식이 어떻게 타입 검사를 통과하는지 이해하고 싶다면, 체계적으로 타입 검사를 해보는 것이 좋습니다. 다음 예제를 살펴보겠습니다. 이 예제에서 우리는 다음 표현식을 타입 검사하려고 합니다. p_ = Structure . el &quot;p&quot;  우선, 가장 바깥쪽 함수의 타입을 적습니다. 이 경우에는 연산자 .의 타입입니다: (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)  그런 다음, 우리는 이 함수에 적용할 인자의 타입과 함수서명의 타입과 비교합니다. 먼저, .의 두 개의 인자의 타입을 확인합니다: Structure :: String -&gt; Structureel &quot;p&quot; :: String -&gt; String 다행히 . 연산자는 두 개의 인자를 받고, 다음과 같은 타입을 가집니다: b -&gt; ca -&gt; b 주의 함수가 받을 수 있는 인자의 수보다 더 많은 인자를 적용하면 타입 오류가 발생합니다. . 연산자는 우리가 제공한 인자의 수만큼 인자를 받기 때문에, 다음 단계로 넘어갑니다: 타입 검사의 다음 단계는 입력 타입과 (연산자의 서명을 통해) 예상되는 타입을 비교하는 것입니다. 두 타입을 비교할 때, 둘 간의 동등성(equivalence)를 확인합니다. 여기에는 몇 가지 가능한 시나리오가 있습니다: 두 타입이 Int, Bool과 같은 구체적(concrete)(타입 변수가 아닌)이고 단순한 타입인 경우, 두 타입이 같은지 확인합니다. 만약 같다면, 타입 검사를 통과하고 계속 진행합니다. 만약 다르다면, 타입 검사를 통과하지 못하고 오류를 발생시킵니다.두 타입이 더 복잡한 경우(예를 들어 둘 다 함수인 경우), 입력과 출력을 비교합니다. 만약 입력과 출력이 일치한다면, 두 타입이 일치한다고 판단합니다.두 타입중 하나가 타입 변수인 특별한 경우가 있습니다. 이 경우, 타입 검사를 방정식처럼 처리합니다. 그리고 어딘가에 적어둡니다. 다음에 이 타입 변수를 볼 때, 방정식에 있는 값으로 대체합니다. 이것을 타입 변수에 값을 할당(assign) 한다고 생각하면 됩니다. 위 예제에서, 우리는 다음 두 가지 타입을 비교해야 합니다: String -&gt; Structure 과 b -&gt; cString -&gt; String 과 a -&gt; b 하나씩 살펴보겠습니다. 먼저, String -&gt; Structure과 b -&gt; c를 비교해보겠습니다: 두 타입이 복잡하므로, 두 타입이 모두 함수라는 것을 확인하고, 입력과 출력을 비교합니다.String과 b, 그리고 Structure와 c를 비교합니다.b는 타입 변수이므로, 어딘가에 적어둡니다. b는 String과 동등하다고 적어둡니다.b ~ String (우리는 ~를 동등함을 나타내는 기호로 사용합니다).같은 방식으로 c도 Structure와 동등하다고 적어둡니다. c ~ Structure. 지금까지 문제는 없습니다. 이제 String -&gt; String과 a -&gt; b를 비교해보겠습니다: 두 타입이 복잡하므로, 두 타입이 모두 함수라는 것을 확인하고, 입력과 출력을 비교합니다.String과 a를 비교합니다. a ~ String으로 적어둡니다.String과 b를 비교합니다. b는 이미 적어둔 방정식을 가지고 있습니다.b ~ String이라고 적어둔 것을 기억합니다. b를 String으로 대체하고, 이 타입과 비교합니다. String과 String을 비교하므로, 타입 검사를 통과합니다. 우리는 무사히 표현식을 타입 검사했고, 다음과 같은 타입 변수의 동등성을 찾았습니다: a ~ Stringb ~ Stringc ~ Structure 이제, 다음 표현식의 타입을 찾아보겠습니다: p_ = Structure . el &quot;p&quot;  이 표현식의 타입을 찾기 위해, 우리가 찾은 방정식을 사용하여 타입 변수를 대체하고, 우리가 적용한 인자를 제거합니다. 그래서 다음과 같은 타입을 얻습니다: (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)  그리고 다음과 같이 타입 변수를 대체합니다: (.) :: (String -&gt; Structure) -&gt; (String -&gt; String) -&gt; (String -&gt; Structure)  그리고 함수를 적용하면서 두 개의 인자를 제거합니다: Structure . el &quot;p&quot; :: String -&gt; Structure  이제, 우리는 이 표현식의 타입을 찾았습니다! 다행히, 하스켈은 이 과정을 대신 해줄 수 있습니다. 하지만 하스켈이 타입 에러를 발생시키는 경우, 그 이유를 이해하지 못하는 상황이 발생할 수 있습니다. 이럴때 위와 같은 과정을 거치면, 타입이 일치하지 않는 부분을 찾을 수 있고, 그 부분을 해결할 수 있습니다. 주의 만약 우리가 매개변수화된 다형성을 가진 함수를 두 번 이상 사용하거나, 비슷한 타입 변수 이름을 가진 다른 함수를 사용한다면, 이름이 같다고 해서 모든 인스턴스에서 타입 변수가 일치할 필요는 없습니다. 각 인스턴스는 고유한 타입 변수 집합을 가집니다. 예를 들어: id :: a -&gt; a ord :: Char -&gt; Int chr :: Int -&gt; Char incrementChar :: Char -&gt; Char incrementChar c = chr (ord (id c) + id 1) 위의 코드에서 id를 두 번 사용합니다. (예시로 사용하기 위함일 뿐 좋은 구조는 아닙니다) 첫 번째 id는 Char를 인자로 받고, a는 Char와 동등합니다. 두 번째 id는 Int를 인자로 받고, 구별된 a는 Int와 동등합니다. 이 상황은 오직 최상위(top-level)에 정의한 함수에만 적용됩니다. 만약 우리가 incrementChar에 인자로 전달할 지역 함수를 정의하고,id와 같은 타입 시그니처를 가진다면, 모든 사용처에서 타입이 일치해야 합니다. 다음 코드의 경우: incrementChar :: (a -&gt; a) -&gt; Char -&gt; Char incrementChar func c = chr (ord (func c) + func 1) 타입 에러가 발생합니다. 직접 확인해보세요! ","version":"Next","tagName":"h3"},{"title":"구조 확장하기​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#구조-확장하기","content":"이전에 우리는 풍부한 HTML 컨텐츠를 만들고 위해 노드를 이어붙이기 위해 &lt;&gt; 연산자를 사용했습니다. 하지만 이제 String을 사용하지 않으므로, 다른 방법을 사용해야 합니다. 물론 하스켈에서 타입클래스로 불리는 기능을 통해 &lt;&gt; 연산자를 오버로딩하여 사용할 수 있지만, 이번에는 append_라는 이름의 새로운 함수를 만들고, 타입클래스에 대해서는 나중에 다루겠습니다. append_는 두 개의 Structure를 인자로 받고, 첫 번째 Structure의 내부 String을 두 번째 Structure에 붙여서 새로운 Structure를 반환합니다.  append_ 함수를 구현해보세요. 정답 append_ :: Structure -&gt; Structure -&gt; Structure append_ (Structure a) (Structure b) = Structure (a &lt;&gt; b)   ","version":"Next","tagName":"h2"},{"title":"Html을 String으로 되돌리기​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#html을-string으로-되돌리기","content":"유효한 Html 값을 만들었으니, 브라우저에서 출력할 수 있도록 Html을 String으로 변환할 수 있는 함수가 필요합니다. 이를 위해 Html을 String으로 변환한 후 putStrLn에 전달하는 함수가 필요합니다.  render 함수를 구현해보세요. 정답 render :: Html -&gt; String render html = case html of Html str -&gt; str   ","version":"Next","tagName":"h2"},{"title":"type​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#type","content":"타입에 새로운 이름을 붙이는 방법은 또 다른 방법이 있습니다. type 정의는 newtype 정의와 매우 유사합니다. 유일한 차이점은 생성자 없이 타입 이름을 참조한다는 것입니다: type &lt;type-name&gt; = &lt;existing-type&gt;  이전 예제에서 type을 사용하면 다음과 같이 작성할 수 있습니다: type Title = String  type은 newtype과 다르게 타입 이름에 대한 별칭입니다.Title을 String의 타입 별칭으로 선언했다는 것은, 두 타입은 서로 대체 가능하고, 언제든지 하나를 다른 하나로 사용할 수 있다는 것을 의미합니다: &quot;hello&quot; :: Title &quot;hello&quot; :: String  위 코드는 모두 유효합니다. type은 때때로 코드 가독성을 높이기 위해 사용합니다. 같은 타입을 다르게 구별할 수 있는 newtype에 비해 type은 덜 유용합니다. ","version":"Next","tagName":"h2"},{"title":"또 다른 문제​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#또-다른-문제","content":" 이전 장에서 작성한 코드를 새로운 타입을 사용하도록 변경해보세요. 팁 이제 makeHtml과 html_를 합치고 body_, head_, title_을 제거할 수 있습니다.html_에서 el을 직접 호출할 수 있으며, 타입은 Title -&gt; Structure -&gt; Html가 됩니다. 이러면 HTML EDSL이 덜 유연하지만 더 간결해집니다. 대안으로, HtmlHead와 HtmlBody라는 newtype을 만들고 html_에 전달할 수 있습니다. 하지만 이번에는 API를 간단하게 유지하기 위해 사용하지 않았고 이후 장에서 다룰 예정입니다. 정답 hello.hs main :: IO () main = putStrLn (render myhtml) myhtml :: Html myhtml = html_ &quot;My title&quot; ( append_ (h1_ &quot;Heading&quot;) ( append_ (p_ &quot;Paragraph #1&quot;) (p_ &quot;Paragraph #2&quot;) ) ) newtype Html = Html String newtype Structure = Structure String type Title = String html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; title) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot; h1_ :: String -&gt; Structure h1_ = Structure . el &quot;h1&quot; el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; append_ :: Structure -&gt; Structure -&gt; Structure append_ c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) getStructureString :: Structure -&gt; String getStructureString content = case content of Structure str -&gt; str render :: Html -&gt; String render html = case html of Html str -&gt; str   ","version":"Next","tagName":"h2"},{"title":"아직 안전하지 않나요?​","type":1,"pageTitle":"타입으로 안전한 HTML 구성하기","url":"/learn-haskell-blog-generator/html/safer-construction#아직-안전하지-않나요","content":"이제 우리는 문단과 제목이 필요한 곳에 &quot;Hello&quot;같은 문자열을 사용할 수 없게 만들었습니다. 하지만 Structure &quot;hello&quot;처럼 제목도 문단도 아닌 값을 사용할 수 있는 문제가 남아있습니다. 사용자의 실수를 방지할 수 있게 노력했지만 아직 원하는만큼 불변성을 강제하지 못했습니다. 다음 장에서는 모듈(modules)과 스마트 생성자(smart constructors)를 사용해 Structure &quot;hello&quot;와 같은 표현식을 사용할 수 없게 만들어보겠습니다. ","version":"Next","tagName":"h2"},{"title":"요약","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/summary","content":"요약 이번 장에서는 매우 최소한의 HTML EDSL을 만들었습니다. 이후에 이 라이브러리를 사용하여 커스텀 마크업 형식의 텍스트를 HTML로 변환할 것입니다. 이번 장에서 우리는 다음과 같은 것들을 배웠습니다: 함수를 정의하고 사용하는 방법타입과 타입 시그니처내장 도메인 특화 언어. 연산자를 사용하여 함수를 합성newtype을 사용하여 잘못된 사용을 방지모듈을 정의하는 방법과 내부 모듈 패턴newtype과 모듈을 사용하여 캡슐화하기 지금까지 작성한 라이브러리 코드는 다음과 같습니다: hello.hs import Html main :: IO () main = putStrLn (render myhtml) myhtml :: Html myhtml = html_ &quot;My title&quot; ( append_ (h1_ &quot;Heading&quot;) ( append_ (p_ &quot;Paragraph #1&quot;) (p_ &quot;Paragraph #2&quot;) ) ) Html.hs module Html ( Html , Title , Structure , html_ , h1_ , p_ , ul_ , ol_ , code_ , append_ , render ) where import Html.Internal Html/Internal.hs module Html.Internal where -- * Types newtype Html = Html String newtype Structure = Structure String type Title = String -- * EDSL html_ :: Title -&gt; Structure -&gt; Html html_ title content = Html ( el &quot;html&quot; ( el &quot;head&quot; (el &quot;title&quot; (escape title)) &lt;&gt; el &quot;body&quot; (getStructureString content) ) ) p_ :: String -&gt; Structure p_ = Structure . el &quot;p&quot; . escape h1_ :: String -&gt; Structure h1_ = Structure . el &quot;h1&quot; . escape ul_ :: [Structure] -&gt; Structure ul_ = Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString) ol_ :: [Structure] -&gt; Structure ol_ = Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString) code_ :: String -&gt; Structure code_ = Structure . el &quot;pre&quot; . escape append_ :: Structure -&gt; Structure -&gt; Structure append_ c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) -- * Render render :: Html -&gt; String render html = case html of Html str -&gt; str -- * Utilities el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; getStructureString :: Structure -&gt; String getStructureString content = case content of Structure str -&gt; str escape :: String -&gt; String escape = let escapeChar c = case c of '&lt;' -&gt; &quot;&amp;lt;&quot; '&gt;' -&gt; &quot;&amp;gt;&quot; '&amp;' -&gt; &quot;&amp;amp;&quot; '&quot;' -&gt; &quot;&amp;quot;&quot; '\\'' -&gt; &quot;&amp;#39;&quot; _ -&gt; [c] in concat . map escapeChar 저장소 코드에서 확인할 수도 있습니다.","keywords":"","version":"Next"},{"title":"사용자 정의 마크업 언어","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/markup","content":"사용자 정의 마크업 언어 이번 장에서는 간단한 마크업 언어를 정의하고, 이 언어로 작성된 문서를 하스켈 데이터 구조로 만드는 방법을 알아보겠습니다. 이번에 만들 마크업 언어는 다음과 같은 기능을 가질 것입니다: 제목: * 문자를 앞에 붙입니다.단락: 빈 줄이 없는 그룹의 라인들순서 없는 목록: 각 줄이 - 로 시작합니다.순서 있는 목록: 각 줄이 # 로 시작합니다.코드 블록: 각 줄이 &gt; 로 시작합니다. 다음 예제 문서를 보겠습니다: * Compiling programs with ghc Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries. Create a new Haskell source file named hello.hs, and write the following code in it: &gt; main = putStrLn &quot;Hello, Haskell!&quot; Now, we can compile the program by invoking ghc with the file name: &gt; ➜ ghc hello.hs &gt; [1 of 1] Compiling Main ( hello.hs, hello.o ) &gt; Linking hello ... GHC created the following files: - hello.hi - Haskell interface file - hello.o - Object file, the output of the compiler before linking - hello (or hello.exe on Microsoft Windows) - A native runnable executable. GHC will produce an executable when the source file satisfies both conditions: # Defines the main function in the source file # Defines the module name to be Main, or does not have a module declaration Otherwise, it will only produce the .o and .hi files. 이 문서는 다음 HTML로 변환됩니다: &lt;h1&gt;Compiling programs with ghc&lt;/h1&gt; &lt;p&gt; Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries. &lt;/p&gt; &lt;p&gt; Create a new Haskell source file named hello.hs, and write the following code in it: &lt;/p&gt; &lt;pre&gt; main = putStrLn &quot;Hello, Haskell!&quot; &lt;/pre&gt; &lt;p&gt;Now, we can compile the program by invoking ghc with the file name:&lt;/p&gt; &lt;pre&gt; ➜ ghc hello.hs [1 of 1] Compiling Main ( hello.hs, hello.o ) Linking hello ... &lt;/pre&gt; &lt;p&gt;GHC created the following files:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;hello.hi - Haskell interface file&lt;/li&gt; &lt;li&gt;hello.o - Object file, the output of the compiler before linking&lt;/li&gt; &lt;li&gt; hello (or hello.exe on Microsoft Windows) - A native runnable executable. &lt;/li&gt; &lt;/ul&gt; &lt;p&gt; GHC will produce an executable when the source file satisfies both conditions: &lt;/p&gt; &lt;ol&gt; &lt;li&gt;Defines the main function in the source file&lt;/li&gt; &lt;li&gt; Defines the module name to be Main, or does not have a module declaration &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;Otherwise, it will only produce the .o and .hi files.&lt;/p&gt; ","keywords":"","version":"Next"},{"title":"타입 시그니처를 추가하기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/html/type-signatures","content":"","keywords":"","version":"Next"},{"title":"익명/람다 함수​","type":1,"pageTitle":"타입 시그니처를 추가하기","url":"/learn-haskell-blog-generator/html/type-signatures#익명람다-함수","content":"하스켈 함수는 일급이며 모든 함수는 정확히 하나의 인자를 받는다는 점에 나아가, 지금까지 사용한 함수 정의 문법은 단지 문법적 설탕(syntactic sugar)이라는 점을 언급하려 합니다. 우리는 어디에서나 익명 함수 (이름이 없는 함수)를 정의할 수 있습니다. 익명함수는 람다 함수(lambda function) 라고도 불립니다. 이는 모든 함수형 언어의 핵심이며 형식적 수학 시스템인 람다 대수(lambda calculus)에서 유래되었습니다. &quot;hello&quot;와 같은 표현식이 위치할 수 있는 모든곳에 다음과 같은 문법으로 익명 함수를 정의할 수 있습니다. \\&lt;argument&gt; -&gt; &lt;expression&gt;  \\ 기호(그리스 문자 람다 'λ'와 유사한 모양)는 람다 함수의 시작을 나타내며,-&gt; 기호는 함수의 본문의 시작지점을 나타냅니다. 람다 함수를 체인으로 연결하여 &quot;다중 인자 함수&quot;를 만들 수도 있습니다: three = (\\num1 -&gt; \\num2 -&gt; num1 + num2) 1 2  이전과 같이, 함수의 인자를 주어진 값으로 대체하여 함수를 평가합니다. 위의 예제에서 num1을 1로 대체하면 (\\num2 -&gt; 1 + num2) 2가 됩니다. 그리고 num2를 2로 대체하면 1 + 2가 됩니다. 추후에 이에 대해 더 자세히 다루겠습니다. 이제 다음과 같은 함수가 있다면 el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;  하스켈은 실제로 다음과 같이 해석합니다: el :: String -&gt; (String -&gt; String) el = \\tag -&gt; \\content -&gt; &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;  이러한 형태는 하스켈 함수가 왜 항상 하나의 인자만 받는지에 대한 이유를 잘 보여줍니다. 익명 함수에 대한 문법적 설탕을 하나 더 소개하겠습니다: 다중 인자 익명 함수를 정의할 때, 다음과 같이 작성할 수 있습니다: \\&lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; -&gt; &lt;expression&gt;  예를 들면: three = (\\num1 num2 -&gt; num1 + num2) 1 2  하지만 내부적으로 어떻게 작동하는지는 아는것 또한 중요합니다. 지금까지는 익명/람다 함수가 필요하지는 않았지만, 추후에 이를 유용하게 사용할 수 있는 상황을 보게 될 것입니다.  연습문제: 지금까지 만든 모든 함수에 타입을 추가하세요. 지금까지 만든 HTML 함수를 el을 사용하도록 구현하세요. 문단과 제목을 정의하는 몇 가지 함수를 추가하세요: p_는 &lt;p&gt; 태그를 사용하는 문단을 정의합니다.h1_는 &lt;h1&gt; 태그를 사용하는 제목을 정의합니다. Hello, world! 문자열을 더욱 풍부한 내용으로 바꾸고, h1_와 p_를 사용하세요.h1_와 p_로 만든 HTML 문자열을 이어붙이기 위해 &lt;&gt; 연산자를 사용할 수 있습니다. 보너스: 재미를 위해, 몇 가지 함수를 람다 함수를 사용하여 다시 작성하세요!  정답: 연습문제 #1 정답 myhtml :: String myhtml = makeHtml &quot;Hello title&quot; &quot;Hello, world!&quot; makeHtml :: String -&gt; String -&gt; String makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content) html_ :: String -&gt; String html_ content = &quot;&lt;html&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/html&gt;&quot; body_ :: String -&gt; String body_ content = &quot;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&quot; head_ :: String -&gt; String head_ content = &quot;&lt;head&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/head&gt;&quot; title_ :: String -&gt; String title_ content = &quot;&lt;title&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/title&gt;&quot;  연습문제 #2 정답 html_ :: String -&gt; String html_ = el &quot;html&quot; body_ :: String -&gt; String body_ = el &quot;body&quot; head_ :: String -&gt; String head_ = el &quot;head&quot; title_ :: String -&gt; String title_ = el &quot;title&quot;  연습문제 #3 정답 p_ :: String -&gt; String p_ = el &quot;p&quot; h1_ :: String -&gt; String h1_ = el &quot;h1&quot;  연습문제 #4 정답 myhtml :: String myhtml = makeHtml &quot;Hello title&quot; (h1_ &quot;Hello, world!&quot; &lt;&gt; p_ &quot;Let's learn about Haskell!&quot;)   최종 프로그램 hello.hs main :: IO () main = putStrLn myhtml myhtml :: String myhtml = makeHtml &quot;Hello title&quot; (h1_ &quot;Hello, world!&quot; &lt;&gt; p_ &quot;Let's learn about Haskell!&quot;) makeHtml :: String -&gt; String -&gt; String makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content) html_ :: String -&gt; String html_ = el &quot;html&quot; body_ :: String -&gt; String body_ = el &quot;body&quot; head_ :: String -&gt; String head_ = el &quot;head&quot; title_ :: String -&gt; String title_ = el &quot;title&quot; p_ :: String -&gt; String p_ = el &quot;p&quot; h1_ :: String -&gt; String h1_ = el &quot;h1&quot; el :: String -&gt; String -&gt; String el tag content = &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;  ","version":"Next","tagName":"h3"},{"title":"하스켈 데이터 타입으로 마크업 언어 표현하기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/markup/data-type","content":"","keywords":"","version":"Next"},{"title":"연습문제​","type":1,"pageTitle":"하스켈 데이터 타입으로 마크업 언어 표현하기","url":"/learn-haskell-blog-generator/markup/data-type#연습문제","content":"다음 마크업 문서를 Document 값으로 표현하세요: Hello, world! * Welcome To this tutorial about Haskell. Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate. # Item 1 of a list # Item 2 of the same list * Compiling programs with ghc Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries. Create a new Haskell source file named hello.hs, and write the following code in it: &gt; main = putStrLn &quot;Hello, Haskell!&quot; Now, we can compile the program by invoking ghc with the file name: &gt; ➜ ghc hello.hs &gt; [1 of 1] Compiling Main ( hello.hs, hello.o ) &gt; Linking hello ... GHC created the following files: - hello.hi - Haskell interface file - hello.o - Object file, the output of the compiler before linking - hello (or hello.exe on Microsoft Windows) - A native runnable executable. GHC will produce an executable when the source file satisfies both conditions: # Defines the main function in the source file # Defines the module name to be Main, or does not have a module declaration Otherwise, it will only produce the .o and .hi files.  정답: 정답 1 example1 :: Document example1 = [ Paragraph &quot;Hello, world!&quot; ]  정답 2 example2 :: Document example2 = [ Heading 1 &quot;Welcome&quot; , Paragraph &quot;To this tutorial about Haskell.&quot; ]  정답 3 example3 :: Document example3 = [ Paragraph &quot;Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate.&quot; , OrderedList [ &quot;Item 1 of a list&quot; , &quot;Item 2 of the same list&quot; ] ]  정답 4 example4 :: Document example4 = [ Heading 1 &quot;Compiling programs with ghc&quot; , Paragraph &quot;Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries.&quot; , Paragraph &quot;Create a new Haskell source file named hello.hs, and write the following code in it:&quot; , CodeBlock [ &quot;main = putStrLn \\&quot;Hello, Haskell!\\&quot;&quot; ] , Paragraph &quot;Now, we can compile the program by invoking ghc with the file name:&quot; , CodeBlock [ &quot;➜ ghc hello.hs&quot; , &quot;[1 of 1] Compiling Main ( hello.hs, hello.o )&quot; , &quot;Linking hello ...&quot; ] , Paragraph &quot;GHC created the following files:&quot; , UnorderedList [ &quot;hello.hi - Haskell interface file&quot; , &quot;hello.o - Object file, the output of the compiler before linking&quot; , &quot;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&quot; ] , Paragraph &quot;GHC will produce an executable when the source file satisfies both conditions:&quot; , OrderedList [ &quot;Defines the main function in the source file&quot; , &quot;Defines the module name to be Main, or does not have a module declaration&quot; ] , Paragraph &quot;Otherwise, it will only produce the .o and .hi files.&quot; ]  Markup 모듈을 만들고 data 타입 정의를 추가하세요.Structure의 생성자들을 내보내야 하는 것에 주의하세요. 정답 Markup.hs module Markup ( Document , Structure(..) ) where import Numeric.Natural type Document = [Structure] data Structure = Heading Natural String | Paragraph String | UnorderedList [String] | OrderedList [String] | CodeBlock [String]   ","version":"Next","tagName":"h3"},{"title":"바로 변환하면 안되나요?​","type":1,"pageTitle":"하스켈 데이터 타입으로 마크업 언어 표현하기","url":"/learn-haskell-blog-generator/markup/data-type#바로-변환하면-안되나요","content":"아마 다음과 같은 의문이 들 수 있습니다. 왜 마크업을 타입으로 표현해야 하나요?파싱할 때 바로 HTML로 변환하면 어떨까요? 좋은 질문이고 유효한 전략입니다. 우리가 마크업을 먼저 하스켈 타입으로 표현하는 이유는 유연성과 모듈성 때문입니다. 만약 파싱 작업이 HTML 생성과 결합되어 있다면, 마크업 문서를 사전 처리할 수 있는 기회를 잃게 됩니다. 예를 들어 요약을 위해 문서의 일부분만 가져오거나, 제목으로 목차를 만들기 어렵게됩니다. 또는 단순히 HTML이 아닌 마크다운 형식이나 GUI 리더기 같은 다른 형식으로 변환하고 싶을 수도 있습니다. 파싱을 &quot;추상 데이터 타입&quot; (ADT) 표현으로(예를 들어 순서 목록을 위한 '#' 같은 언어의 세부 사항을 포함하지 않는)하면 HTML 변환 외에도 많은 일을 할 수 있습니다. 따라서 최적화가 정말로 필요하지 않는 한 ADT로 변환하는 것이 좋다고 생각합니다. ","version":"Next","tagName":"h2"},{"title":"파싱 결과 보여주기 (타입 클래스)","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/markup/displaying-results","content":"","keywords":"","version":"Next"},{"title":"인스턴스 자동구현​","type":1,"pageTitle":"파싱 결과 보여주기 (타입 클래스)","url":"/learn-haskell-blog-generator/markup/displaying-results#인스턴스-자동구현","content":"몇 가지 타입 클래스는 인스턴스를 자동으로 생성할 수 있습니다. 다행히 Show도 그 중 하나입니다. 만약 우리가 정의한 데이터 타입의 모든 타입이 Show 인스턴스를 이미 구현하고 있다면, 데이터 정의 끝에 deriving Show를 추가하면 Show 인스턴스를 자동으로 생성할 수 있습니다. data Structure = Heading Natural String | Paragraph String | UnorderedList [String] | OrderedList [String] | CodeBlock [String] deriving Show  이제 Show인스턴스를 구현한 어떠한 타입에 대해서도 show :: Show a =&gt; a -&gt; String 함수를 사용할 수 있습니다. 예를 들어 print 함수를 사용할 수 있습니다: print :: Show a =&gt; a -&gt; IO () print = putStrLn . show  print 함수는 show 함수를 사용하여 값을 String으로 변환하고, 표준 출력으로 출력합니다. 리스트 또한 요소가 Show 인스턴스를 가졌다면 Show 인스턴스를 구현합니다. 그래서 Document는 [Structure]의 별칭이기 때문에 Show 인스턴스를 가집니다. 한 번 시도해보세요! 하스켈러들이 자주 사용하는 다양한 타입 클래스가 있습니다. 그 중에 동등성을 위한 Eq와 정렬을 위한 Ord도 있습니다. 이 두 타입 클래스 역시 인스턴스를 자동으로 생성할 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"법칙​","type":1,"pageTitle":"파싱 결과 보여주기 (타입 클래스)","url":"/learn-haskell-blog-generator/markup/displaying-results#법칙","content":"타입 클래스에는 인스턴스가 준수해야 하는 &quot;법칙&quot;이나 &quot;규칙&quot;이 있습니다. 이러한 법칙의 목적은 인스턴스 간에 예측 가능한 동작을 제공하는 것입니다. 따라서 새로운 인스턴스를 접할 때, 이것이 예상대로 동작할 것이라고 확신할 수 있으며, 이러한 법칙을 준수하는 모든 인스턴스에 대해 일반적으로 작동하는 코드를 작성할 수 있습니다. 예들 들어, Semigroup 타입 클래스를 살펴보겠습니다: class Semigroup a where (&lt;&gt;) :: a -&gt; a -&gt; a  이 타입 클래스는 두 값을 어떠한 방식으로 결합해 하나의 값을 만들 수 있는 연산자 &lt;&gt;를 제공하는 타입에 대한 공통된 인터페이스를 제공합니다. 이 타입 클래스는 또한 &lt;&gt; 연산자가 결합법칙을 만족해야 한다는 것을 의미합니다. 즉, 아래 등식이 성립해야 합니다. x &lt;&gt; (y &lt;&gt; z) = (x &lt;&gt; y) &lt;&gt; z  Semigroup을 만족하는 인스턴스의 예로 리스트와 ++ 연산자가 있습니다: instance Semigroup [a] where (&lt;&gt;) = (++)  아쉽게도 하스켈 타입 시스템은 이러한 법칙을 &quot;증명&quot;할 수 없기에, 법칙을 만족하지 않는 인스턴스 사용하지 않는것이 좋습니다. 많은 데이터 타입(그리고 각 연산자)은 Semigroup을 만족하며, 인스턴스들은 비슷해 보이거나 공통적인 유사성/비유를 가져야 할 필요가 없습니다. (이는 많은 다른 타입 클래스에도 해당됩니다.) 타입 클래스는 종종 법칙(또는 예상 동작)이 있는 인터페이스에 불과합니다.이러한 관점으로 접근하면 매우 자유로울 수 있습니다! 다르게 말하면, 타입 클래스는 추상화를 만드는 데 사용할 수 있습니다.주어진 타입의 구체적인 세부 사항에 대해 신경 쓰지 않고, 단지 API를 구현하고 특정 방식으로 동작한다는 것을 보장하는 인터페이스입니다. 사실 이전 장에서 Html EDSL을 위한 &lt;&gt; 연산자를 만들었습니다!Structure 타입에 Semigroup 인스턴스를 추가하면 더 나은 API를 가질 수 있습니다!  연습문제: append_ 함수를 제거하고 Semigroup 인스턴스를 추가하세요. 정답 다음 코드를: append_ :: Structure -&gt; Structure -&gt; Structure append_ c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) 아래처럼 변경합니다: instance Semigroup Structure where (&lt;&gt;) c1 c2 = Structure (getStructureString c1 &lt;&gt; getStructureString c2) 그리고 Html.hs에서 append_를 제거합니다. 타입 클래스는 자동으로 내보내지기 때문에 따로 내보내지 않아도 됩니다. hello.hs에서 append_를 &lt;&gt;로 바꾸는 작업도 필요합니다.  ","version":"Next","tagName":"h2"},{"title":"마크업 파싱하기 01 (재귀)","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/markup/parsing-01","content":"","keywords":"","version":"Next"},{"title":"재귀와 정보 누적​","type":1,"pageTitle":"마크업 파싱하기 01 (재귀)","url":"/learn-haskell-blog-generator/markup/parsing-01#재귀와-정보-누적","content":"loop 대신, 하스켈에서는 재귀를 사용하여 반복을 모델링합니다. 다음과 같은 인위적인 예를 생각해 보겠습니다: 두 개의 자연수를 더하는 알고리즘이 필요하다고 가정해 보겠습니다. 하지만 일반적인 덧셈 연산자 +를 사용할 수 없고, 각 숫자에 대해 increment와 decrement라는 두 개의 연산을 사용할 수 있습니다. 이 문제를 해결하기 위한 방법은 하나의 숫자를 다른 숫자로 점진적으로 &quot;전달&quot;하는 것입니다. 즉, 하나를 증가시키고 다른 하나를 감소시키고, 이를 반복하여 두 번째 숫자가 0이 될 때까지 수행합니다. 예를 들어 3과 2를 더한다고 가정해 보겠습니다: 3과 2를 시작으로 합니다. 3을 증가시키고 2를 감소시킵니다.다음 단계에서는 4와 1이 됩니다. 4를 증가시키고 1을 감소시킵니다.다음 단계에서는 5와 0이 됩니다. 2가 0이므로 5를 결과로 반환합니다. 이를 명령형으로 작성하면 다음과 같습니다: function add(n, m) { while ((m /= 0)) { n = increment(n); m = decrement(m); } return n; }  하스켈에서는 변수의 변경없이 재귀를 사용하여 동일한 알고리즘을 작성할 수 있습니다: add n m = if m /= 0 then add (increment n) (decrement m) else n  하스켈에서는 가변 상태를 활용해 반복을 구현하는 대신, 함수를 다시 호출하여 변수의 값을 다음 반복에 사용하도록 합니다. ","version":"Next","tagName":"h2"},{"title":"재귀의 평가​","type":1,"pageTitle":"마크업 파싱하기 01 (재귀)","url":"/learn-haskell-blog-generator/markup/parsing-01#재귀의-평가","content":"배귀는 일반적으로 loop보다 느리고, 안전하지 않다고 알려져 있습니다. 이는 명령형 언어에서 함수 호출이 새로운 호출 스택을 생성을 요구하기 때문입니다. 그러나 함수형 언어(특히 하스켈)는 다른 규칙을 따르며, 꼬리 호출 제거(tail call elimination) 이라는 기능을 구현합니다. 함수 호출의 결과가 함수 자체의 결과인 경우(이를 꼬리 위치(tail position) 이라고 함), 현재 스택 프레임을 삭제하고 호출하는 함수를 위한 하나의 스택 프레임을 할당하여 N번의 반복에 대해 N개의 스택 프레임이 필요하지 않도록 합니다. 물론, 이는 꼬리 호출 제거를 수행하는 한 가지 방법일 뿐이며, 우리가 위에서 재귀적으로 작성한 add 함수와 같은 코드를 반복 버전으로 변환하는 것과 같은 다른 전략도 존재합니다. 지연성​ Haskell은 흔히 사용되는 엄격한 평가 전략(strict evaluation strategy)이 아닌 지연 평가 전략(lazy evaluation strategy)을 사용하기 때문에 조금 다른 규칙을 따릅니다. 여기서 평가 전략(evaluation strategy)이란 &quot;언제 계산을 평가할 것인가&quot;를 의미합니다. 엄격한 언어에서의 법칙은 간단합니다: 함수에 전달되는 인수를 함수에 진입하기 전에 평가합니다. 예를 들어 add (increment 3) (decrement 2)를 엄격하게 평가하면 다음과 같습니다: increment 3을 평가하여 4를 얻습니다.decrement 2를 평가하여 1을 얻습니다.add 4 1을 평가합니다Evaluate increment 3 to 4Evaluate decrement 2 to 1Evaluate add 4 1 또는 (언어에 따라서) (1)과 (2)의 순서를 반대로 하고 인수를 오른쪽에서 왼쪽으로 평가합니다. 반면 지연 평가 전략에서는, 실제로 필요한 시점에만 계산을 평가합니다. 예를 들어 표준 출력에 연산을 출력하거나 네트워크로 보내는 등, 외부 세계에 영향을 미치는 연산을 포함할 때 평가합니다. 따라서 계산이 필요하지 않은 경우, 평가하지 않습니다. 예들 들면: main = if add (increment 2) (decrement 3) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot;  이 경우 add (increment 2) (decrement 3)의 결과가 필요하므로 평가합니다. 하지만: main = let five = add (increment 2) (decrement 3) in putStrLn &quot;Not required&quot;  이 경우는 five가 필요하지 않으므로 평가하지 않습니다! 그렇다면 add (increment 2) (decrement 3)가 필요하다고 판단하면 엄격한 평가를 수행할까요? 그렇지 않습니다 - 왜냐하면 계산을 완료하기 위해 인자를 평가할 필요가 없을 수도 있기 때문입니다. 예를 들어 다음과 같은 경우: const a b = a main = if const (increment 2) (decrement 3) == 3 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot;  const는 두 번째 인자를 무시하고 첫 번째 인자를 반환하므로, 계산의 결과를 제공하고 화면에 출력하기 위해 decrement 3을 평가할 필요가 없습니다. 지연 평가 전략에서는 필요할 때만 계산을 평가하며 (사용자가 무언가를 수행하기 위해 필요할 때), 바깥에서 안으로 평가합니다 - 먼저 함수에 진입하고, 그 다음에 필요할 때 인자를 평가합니다 (대부분의 경우 if 표현식의 조건이나 패턴 매칭의 패턴에 나타날 때).  하스켈에서 이런 전략이 어떻게 이루어지는지에 대한 자세한 내용을 다음 블로그 포스트에서 확인할 수 있습니다:Substitution and Equational Reasoning. 읽어본 후, 다음 프로그램을 직접 평가해 보세요: import Prelude hiding (const) -- 이 줄은 무시해도 좋습니다 increment n = n + 1 decrement n = n - 1 const a b = a add n m = if m /= 0 then add (increment n) (decrement m) else n main = if const (add 3 2) (decrement 3) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot;  평가는 언제나 main에서 시작하는 점을 명심하세요. 정답 main 평가 if const (add 3 2) (decrement 3) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; const 평가 if add 3 2 == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; add 평가 if (if 2 /= 0 then add (increment 3) (decrement 2) else 3) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; 제어문 2 /= 0 평가 if (if True then add (increment 3) (decrement 2) else 3) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; then 분기 평가 if (add (increment 3) (decrement 2)) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; add 평가 if ( if decrement 2 /= 0 then add (increment (increment 3)) (decrement (decrement 2)) else (increment 3) ) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; 제어문에서 decrement 2 평가 (두 곳이 변경되는 것에 주목하세요!) if ( if 1 /= 0 then add (increment (increment 3)) (decrement 1) else (increment 3) ) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; 제어문 1 /= 0 평가 if ( if True then add (increment (increment 3)) (decrement 1) else (increment 3) ) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; then 분기 평가 if ( add (increment (increment 3)) (decrement 1) ) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; add 평가 if ( if decrement 1 /= 0 then add (increment (increment (increment 3))) (decrement (decrement 1)) else increment (increment 3) ) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; 제어문 decrement 1 평가 if ( if 0 /= 0 then add (increment (increment (increment 3))) (decrement 0) else increment (increment 3) ) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; 제어문 0 /= 0 평가 if ( if False then add (increment (increment (increment 3))) (decrement 0) else increment (increment 3) ) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; else 분기 평가 if (increment (increment 3)) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; 제어문 increment (increment 3) 평가 if (increment 3 + 1) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; 제어문 increment 3 평가 if (3 + 1 + 1) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; 제어문 3 + 1 평가 if (4 + 1) == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; 제어문 4 + 1 평가 if 5 == 5 then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; 제어문 5 == 5 평가 if True then putStrLn &quot;Yes.&quot; else putStrLn &quot;No.&quot; then 분기 평가 putStrLn &quot;Yes.&quot; 화면에 Yes.를 출력합니다.  ","version":"Next","tagName":"h3"},{"title":"일반 재귀​","type":1,"pageTitle":"마크업 파싱하기 01 (재귀)","url":"/learn-haskell-blog-generator/markup/parsing-01#일반-재귀","content":"일반적으로, 재귀적으로 문제를 해결하려면 다음 세 가지 부분을 고려해야 합니다: In general, when trying to solve problems recursively, it is useful to think about the problem in three parts: 기저 사례(base case) (가장 간단한 경우 - 이미 답을 알고 있는 경우)문제를 더 간단한 것으로 축소(reduce)하는 방업을 찾습니다. (기저 사례에 가까워지도록)축소된 버전과 제공해야 하는 해결책 간의 차이를 완화(mitigate)합니다. 축소와 완화 단계를 합쳐서 재귀 단계(recursive step)라고 부릅니다. 또 다른 예제 문제를 살펴보겠습니다: 특정 크기로 리스트를 생성하고 각 요소에 특정 값을 넣는 것입니다. 하스켈에서는, 다음과 같은 시그니처를 가진 함수가 있습니다: replicate :: Int -&gt; a -&gt; [a]  다음은 replicate의 몇 가지 사용 예입니다: ghci&gt; replicate 4 True [True,True,True,True] ghci&gt; replicate 0 True [] ghci&gt; replicate (-13) True []  어떻게 이 함수를 재귀적으로 구현할 수 있을까요? 위의 세 단계를 어떻게 적용할 수 있을까요? 기저 사례: 이미 알고 있는 경우는 리스트의 길이가 0(또는 그 이하)인 경우입니다. 이 경우에는 빈 리스트를 반환합니다.축소: (양수인) N 크기의 리스트를 생성하는 방법을 모르더라도, N-1 크기의 리스트를 생성하는 방법을 알고 있다면 유도할 수 있습니다.완화: N-1 크기일 때의 해답에 : (cons) 연산자를 사용하여 다른 요소를 추가합니다.  하스켈로 이를 구현해보세요! 정답 replicate :: Int -&gt; a -&gt; [a] replicate n x = if n &lt;= 0 -- 기저 사례인 경우 then [] -- 기저 사례의 답 else x : replicate (n - 1) x -- --- ------------------- -- ^ ^ -- | | -- | +-------- 축소 -- | -- +--- 완화   ","version":"Next","tagName":"h3"},{"title":"상호 재귀​","type":1,"pageTitle":"마크업 파싱하기 01 (재귀)","url":"/learn-haskell-blog-generator/markup/parsing-01#상호-재귀","content":"함수를 재귀적으로 해결할 때 우리는 보통 같은 함수를 다시 호출합니다. 하지만 꼭 그렇게 할 필요는 없습니다. 다른 함수를 호출하여 문제를 더 간단한 것으로 축소할 수도 있습니다. 만약, 그 함수가 (또는 호출 체인의 또 다른 함수가) 다시 기존 함수를 호출한다면, 이는 상호 재귀적(mutual recursive) 이라고 할 수 있습니다. 예를 들어, 주어진 자연수가 짝수인지 홀수인지를 판별하는 두 개의 함수를 작성해보겠습니다. 이 함수들은 주어진 수를 감소시키는 방법을 사용하여 문제를 해결할 수 있습니다. even :: Int -&gt; Bool odd :: Int -&gt; Bool  먼저 even을 구현해보겠습니다. 어떻게 하면 이 함수를 재귀적으로 구현할 수 있을까요? 기저 사례: 이미 알고 있는 경우는 0인 경우입니다. 이 경우에는 True를 반환합니다.축소: 일반적인 N에 대한 답을 모르더라도, N - 1에 대한 답은 확인할 수 있습니다.완화: N - 1이 홀수인 경우, N은 짝수입니다! N - 1이 홀수가 아닌 경우, N은 짝수가 아닙니다. odd는 어떻게 구현할 수 있을까요? 기저 사례: 이미 알고 있는 경우는 0인 경우입니다. 이 경우에는 False를 반환합니다.축소: 일반적인 N에 대한 답을 모르더라도, N - 1에 대한 답은 확인할 수 있습니다.완화: N - 1이 짝수인 경우, N은 홀수입니다! N - 1이 짝수가 아닌 경우, N은 홀수가 아닙니다.  이제 하스켈로 구현해보세요! 정답 even :: Int -&gt; Bool even n = if n == 0 then True else odd (n - 1) odd :: Int -&gt; Bool odd n = if n == 0 then False else even (n - 1)   ","version":"Next","tagName":"h3"},{"title":"부분 함수​","type":1,"pageTitle":"마크업 파싱하기 01 (재귀)","url":"/learn-haskell-blog-generator/markup/parsing-01#부분-함수","content":"위 예제에서 음수에 대한 경우는 다루지 않았기때문에, 음수를 입력으로 받으면 무한 루프에 빠질 수 있습니다. 특정 값에 대해 결과를 반환하지 않는 함수(함수가 종료되지 않거나 에러를 발생시키는 경우)를 (가능한 입력의 일부에 대해서만 결과를 반환하기 때문에) 부분 함수(partial function) 라고 합니다. 부분 함수는 런타임에 예상하지 못한 동작(런타임 예외 또는 무한루프)을 할 수 있기 때문에, 나쁜 관례(bad practice)로 여겨집니다. 그래서, 부분 함수 사용을 지양하고, 부분 함수 작성을 지양해야합니다. 부분 함수를 작성하지 않는 가장 좋은 방법은 모든 입력을 처리하는 것입니다! 위의 경우에는 음수를 처리할 수 있기 때문에, 이를 처리해야합니다! 또는 함수가 Int 대신 Natural을 받도록 만들 수 있고, 이 경우 타입 시스템이 우리가 처리하지 않은 값을 사용하는 것을 막아줄 것입니다. 모든 입력을 처리할 수 없는 경우에는, 코드를 다시 검토해보고 타입을 사용하여 입력을 더 제한할 수 있는지 확인해야합니다. 예를 들어, Prelude 모듈의 head :: [a] -&gt; a 함수는 리스트의 첫 번째 요소를 반환할 것으로 기대합니다. 하지만 빈 목록을 제공한다면, 이 함수가 기대한 대로 동작할 수 있을까요? 아쉽게도, 그렇지 않습니다. 하지만 정상적으로 동작하는 다른 함수가 있습니다: 바로 Data.List.NonEmpty 모듈의head :: NonEmpty a -&gt; a 함수입니다! 이 함수는 일반 리스트가 아닌 완전히 다른 타입을 입력으로 받습니다. 이 타입은 적어도 하나의 요소가 있음을 보장하기 때문에, 함수는 기대한 대로 동작할 수 있습니다! 이전 장에서 본 것처럼, newtype을 활용하는 스마트 생성자를 사용해 타입 시스템에 어떤 제한을 강제할 수도 있습니다. 하지만 이 해결책은 때때로 사용하기에 불편할 수 있습니다. 또 다른 해결책은 data 타입을 사용하여 결과가 없는 경우를 표현하는 것입니다. 예를 들어, Maybe 타입을 사용할 수 있습니다. 이에 대해서는 이후 장에서 자세히 다루겠습니다. 함수를 작성할 때에는 입력을 제한하거나, 결과가 없는 경우를 표현하는 타입을 사용해서 모든 입력에 대해 결과를 반환할 수 있도록 해야합니다. ","version":"Next","tagName":"h2"},{"title":"마크업 파싱하기​","type":1,"pageTitle":"마크업 파싱하기 01 (재귀)","url":"/learn-haskell-blog-generator/markup/parsing-01#마크업-파싱하기","content":"우리의 원래 목표로 돌아가봅시다. 이전에 언급했듯이, 마크업을 파싱하는 전략은 다음과 같습니다: 문자열을 줄 단위로 분할해 리스트를 만듭니다. (이는 lines) 함수를 사용하여 수행할 수 있습니다.)리스트를 순회하면서, 각 줄을 처리합니다. 필요한경우 이전 줄의 정보를 기억합니다. 처음에는 모든 마크업 문법은 무시하고 줄을 그룹화하여 문단을 만들기로 한 것을 기억하세요. (문단은 빈 줄로 구분됩니다) 그리고 이후 장에서 점진적으로 새로운 기능을 추가합니다. parse :: String -&gt; Document parse = parseLines [] . lines -- (1) parseLines :: [String] -&gt; [String] -&gt; Document parseLines currentParagraph txts = let paragraph = Paragraph (unlines (reverse currentParagraph)) -- (2), (3) in case txts of -- (4) [] -&gt; [paragraph] currentLine : rest -&gt; if trim currentLine == &quot;&quot; then paragraph : parseLines [] rest -- (5) else parseLines (currentLine : currentParagraph) rest -- (6) trim :: String -&gt; String trim = unwords . words  주목할 점: 문단으로 그룹화할 리스트를 전달합니다. (문단은 빈 줄로 구분됩니다) 지연평가로 인해, paragraph는 필요할 때까지 계산되지 않습니다. 따라서, 아직 문단을 그룹화하는 중이라면 성능을 걱정할 필요가 없습니다. 왜 currentParagraph를 뒤집을까요? (6번을 참고하세요) case 표현식을 사용해 newtype과 Char를 구조분해 한것처럼, 다른 ADT와 리스트에 대해서도 패턴 매칭을 할 수 있습니다! 이 경우에는 두 가지 패턴을 사용합니다. 빈 리스트 ([])과 &quot;cons cell&quot; - 적어도 하나의 요소가 있는 리스트 (currentLine : rest)입니다. &quot;cons&quot; 패턴의 본문에서, 첫 번째 요소를 currentLine이라는 이름으로 바인딩하고, 나머지 요소를 rest라는 이름으로 바인딩합니다. 이것이 어떻게 작동하는지는 곧 알아볼 예정입니다! 빈 줄에 도달한 경우 누적한 문단을 리스트에 추가하고 (Document는 Structure의 리스트입니다) 나머지 입력으로 함수를 다시 호출합니다. 새로운 줄을 문단에 추가할 때 역순으로 추가합니다. 이는 성능을 고려했기 때문입니다 - 단일 연결 리스트의 특성 때문에, 요소를 추가하는 것은 느리지만, 앞에 추가하는 것은 빠릅니다. 요소를 앞에 추가하는 것은 값과 리스트를 가리키는 포인터를 담은 새로운 cons (:) 셀을 생성하는 것만으로 충분하지만, 요소를 뒤에 추가하는 것은 리스트의 끝까지 이동하고 cons 셀을 재구성해야 합니다. 마지막 cons 셀은 리스트의 마지막 값을 가리키고 추가할 리스트를 가리키는 포인터를 포함하고, 그 다음 cons 셀은 리스트의 마지막 값의 앞의 값을 가리키고 마지막 요소와 추가된 리스트를 가리키는 포인터를 포함합니다. 이와 같은 과정이 반복됩니다. 위 함수는 이제 우리가 원하는 기능을 제공할것입니다. 하지만 함수의 결과를 어떻게 확인할 수 있을까요? 다음 장에서는 타입 클래스에 대해 간략히 살펴보고, 이를 사용하여 결과를 확인하는 방법을 알아보겠습니다. ","version":"Next","tagName":"h2"},{"title":"더 나아가기","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/next","content":"","keywords":"","version":"Next"},{"title":"프로젝트 확장하기​","type":1,"pageTitle":"더 나아가기","url":"/learn-haskell-blog-generator/next#프로젝트-확장하기","content":"이 프로젝트를 확장하고 싶다면 다음과 같은 아이디어를 고려해 보세요: HTTP로 제공하기 - wai나twain과 같은 웹 라이브러리를 사용하여 이 블로그를 정적으로 생성하는 대신 HTTP로 제공할 수 있습니다.라이브러리를 활용해 다시 작성하기 - 이 블로그를 다시 작성하고 실제 HTML 패키지와마크다운 파서를 사용할 수 있습니다.기능 추가하기 각 게시글 상단에 블로그 제목, 게시 날짜 및 태그를 포함하는 메타데이터 블록을 추가하고, HTML, 인덱스 페이지 및 심지어 태그 페이지를 생성할 때 사용할 수 있습니다.mustache 또는 유사한 것을 사용하여 HTML 페이지 템플릿을 추가하고, 페이지를 좀 더 멋지고 사용자 정의할 수 있도록 만들 수 있습니다.마크업 언어 파서에 링크 및 이미지 지원을 추가할 수 있습니다.블로그 제목, 설명 또는 twitter cards와 같은 다른 메타 정보를 포함하는 구성 파일을 지원할 수 있습니다. 또는 다른 아이디어가 있다면, 이 프로젝트는 당신의 놀이터라 생각하고 원하는 대로 수정해보세요! ","version":"Next","tagName":"h2"},{"title":"다른 자료들​","type":1,"pageTitle":"더 나아가기","url":"/learn-haskell-blog-generator/next#다른-자료들","content":"때로는 새로운 개념, 기술 또는 &quot;이것을 더 잘할 수 있을 것 같은 느낌&quot;을 경험하는 순간이 올 것입니다. 필요할 때마다 추가 정보를 찾고 새로운 Haskell 것들을 배울 수 있도록 적절한 방향을 제시하고자 합니다. 저는 Haskell study plan이라는 곳에 하스켈 학습을 위한 자료를 모았습니다. 매우 유용한 기사, 커뮤니티 허브 및 뉴스 집계기, 프로젝트 제안, 그리고 멋진 오픈 소스 하스켈 프로젝트 링크를 포함하고 있습니다. 우리가 다른 것을 다른 관점으로 보고 싶을 때를 대비해 다른 하스켈 튜토리얼, 가이드 및 책 링크도 찾아볼 수 있습니다. 또한, GHC 사용자 가이드는 언어와 GHC 도구에 대한 많은 기사와 정보를 담고 있는 훌륭한 자료입니다. 하스켈 언어를 배우는 가장 좋은 수단이 될 수도 있습니다. 하지만 하스켈이 제공하는 모든 것을 한 번에 배울 필요는 없습니다. 하스켈을 마스터하는 것은 많은 시간이 걸릴 수 있는 여행입니다. 우리 대부분은 아직 그 곳에 도달하지 못했지만, 여전히 하스켈로 매우 생산적이고, 실제 프로젝트를 구축하고, 심지어 새로운 기술과 개념을 발견할 수 있습니다. 지연 언어에서는 필요한 순간에 평가를 수행한다는 것을 기억하세요. 하스켈 개념을 배우는 것도 같은 방식을 적용할 수 있습니다! ","version":"Next","tagName":"h2"},{"title":"요약","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/recap","content":"","keywords":"","version":"Next"},{"title":"감사합니다!​","type":1,"pageTitle":"요약","url":"/learn-haskell-blog-generator/recap#감사합니다","content":"이 책을 읽어주셔서 감사합니다. 당신이 이 책을 재미있게 읽으셨고 하스켈에 흥미를 느끼셨으면 좋겠습니다. 이 책에 대한 피드백을 듣고 싶습니다. 만약 피드백을 주고 싶으시다면, 이 책의토론 게시판, 또는 mastodon 또는 이메일을 통해 직접 연락하실 수 있습니다. 연락처는 저의 웹사이트에서 찾을 수 있습니다. 이 책이 마음에 드셨다면 알려주세요. 당신의 친절한 말은 큰 힘이 됩니다. 마지막으로 당신이 정말로 이 책을 좋아하셨고 미래의 열정적인 프로젝트를 지원하고 싶다면,Ko-fi를 통해 직접 후원할 수 있습니다. 감사드리며 당신의 다음 하스켈 프로젝트에 행운을 빕니다! ","version":"Next","tagName":"h2"},{"title":"마크업 파싱하기 02 (패턴 매칭)","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/markup/parsing-02","content":"","keywords":"","version":"Next"},{"title":"Maybe​","type":1,"pageTitle":"마크업 파싱하기 02 (패턴 매칭)","url":"/learn-haskell-blog-generator/markup/parsing-02#maybe","content":"이전에 부분 함수를 만들지 않는 방법 중 하나로, Maybe를 사용하여 결과가 없는 경우를 표현하는 것을 살펴 보았습니다. data Maybe a = Nothing | Just a  Maybe는 표준 라이브러리(base)에서 제공하는 데이터 타입으로, 값의 부재를 의미하는 추가적인 값을 타입에 추가하는 데 사용됩니다. 예를 들어, Just 생성자는 일반적인 불리언 값이 있음을 나타내고, (Just True와 Just False)Nothing 생성자는 불리언 값이 없음을 나타냅니다. 이를 통해 주어진 리스트의 첫 번째 요소를 반환하는 head 함수를 부분 함수로 만들지 않고 항상 값을 반환하게 만들 수 있습니다. safeHead :: [a] -&gt; Maybe a  위 방식은 리스트가 비어있다면, Nothing을 반환하고, 비어있지 않다면 Just &lt;첫 번째 요소&gt;를 반환합니다.Data.Maybe 모듈의listToMaybe 함수가 이 역할을 합니다. Maybe &lt;무언가&gt; 또는 다른 data로 생성된 타입의 값을 꺼내기위해, 패턴 매칭을 사용할 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"패턴 매칭​","type":1,"pageTitle":"마크업 파싱하기 02 (패턴 매칭)","url":"/learn-haskell-blog-generator/markup/parsing-02#패턴-매칭","content":"이전에 패턴 매칭에 대해 이미 몇 번 보았습니다. 패턴 매칭은 하스켈의 매우 유용한 기능으로, 주로 두 가지 주요 목적으로 사용합니다: 복잡한 값을 분해흐름 제어 이전 newtype을 소개할 때,case 표현식과 함수 정의를 사용하여 newtype을 분해하는 방법을 살펴보았습니다.data 타입에 대해서도 같은 방법을 적용할 수 있습니다: -- | 색상을 표현하는 데이터 타입 data Color = RGB Word8 Word8 Word8 getBluePart :: Color -&gt; Word8 getBluePart color = case color of RGB _ _ blue -&gt; blue  getBluePart 함수는 주어진 합성 값을 분해하여 RGB에서 세 번째 요소인 파란색 값을 추출합니다. blue는 color의 세 번째 요소에 준 이름으로 오른쪽 화살표 다음에 오는 패턴에 바인딩됩니다. 이는 함수 인수와 유사합니다. 또한 _는 이름을 바인딩하지 않고 모든 값과 일치하는 패턴입니다. 값을 두 개 이상의 패턴과 비교할 수도 있습니다: data Brightness = Dark | Bright data EightColor = Black | Red | Green | Yellow | Blue | Magenta | Cyan | White data AnsiColor = AnsiColor Brightness EightColor ansiColorToVGA :: AnsiColor -&gt; Color ansiColorToVGA ansicolor = case ansicolor of AnsiColor Dark Black -&gt; RGB 0 0 0 AnsiColor Bright Black -&gt; RGB 85 85 85 AnsiColor Dark Red -&gt; RGB 170 0 0 AnsiColor Bright Red -&gt; RGB 255 85 85 -- and so on  다음 항목을 주목하세요: 패턴은 중첩될 수 있습니다. ansicolor를 여러 단계로 분해하는 것을 알 수 있습니다.패턴은 위에서 아래로 매칭되므로, 패턴이 중첩되면 위에 있는 패턴이 우선합니다.어떤 값이 주어진 모든 패턴과 일치하지 않으면 런타임에 에러가 발생합니다. GHC에게 우리가 실수로 패턴을 중복해서 작성했거나, 모든 가능한 값을 매칭할 수 있도록 작성하지 않았다는 것을 알려주도록 할 수 있습니다.ghc 또는 runghc에 -Wall 플래그를 전달하면 됩니다. 항상 -Wall을 사용하는 것을 권장합니다! 노트 함수를 여러번 정의하는 방식을 통해, 패턴 매칭을 함수 정의에도 사용할 수도 있습니다. 하지만 개인적으로 그 기능을 썩 좋아하지 않습니다가능하면 case 표현식을 사용하는 것을 권장합니다. 하지만 원한다면 case 표현식 대신 사용해도 좋습니다. ","version":"Next","tagName":"h2"},{"title":"연결 리스트 패턴 매칭​","type":1,"pageTitle":"마크업 파싱하기 02 (패턴 매칭)","url":"/learn-haskell-blog-generator/markup/parsing-02#연결-리스트-패턴-매칭","content":"연결 리스트에는 특별한 문법이 있는데, 패턴 매칭에도 특별한 문법이 있습니다. 리스트를 만들 때 사용한 특별한 문법을 통해, 리스트의 요소를 패턴으로 사용할 수 있습니다. 예를 들어: safeHead :: [a] -&gt; Maybe a safeHead list = case list of -- 빈 리스트 [] -&gt; Nothing -- cons 셀 패턴, 리스트의 첫 번째 요소를 x에 매칭 x : _ -&gt; Just x  exactlyTwo :: [a] -&gt; Maybe (a, a) exactlyTwo list = case list of -- 정확히 두 개의 요소를 가진 리스트와 매칭 [x, y] -&gt; Just (x, y) -- 나머지 모든 패턴과 매칭 _ -&gt; Nothing  -- 다음 함수도 같은 결과를 반환합니다 exactlyTwoVersion2 :: [a] -&gt; Maybe (a, a) exactlyTwoVersion2 list = case list of -- 정확히 두 개의 요소를 가진 리스트와 매칭 x : y : [] -&gt; Just (x, y) -- 나머지 모든 패턴과 매칭 _ -&gt; Nothing   연습문제: 주어진 색이 밝은 색인지를 확인하는 isBright :: AnsiColor -&gt; Bool 함수를 작성하세요.이 표를 사용하여 ansiToUbuntu 함수를 작성하세요.listToMaybe를 사용해 리스트가 비어있는지 확인하는 isEmpty :: [a] -&gt; Bool 함수를 작성하세요.listToMaybe를 사용하지 않고 리스트가 비어있는지 확인하는 isEmpty :: [a] -&gt; Bool 함수를 작성하세요. 정답: 연습문제 (1) isBright :: AnsiColor -&gt; Bool isBright ansiColor = case ansiColor of AnsiColor Bright _ -&gt; True AnsiColor Dark _ -&gt; False  연습문제 (2) ansiToUbuntu :: AnsiColor -&gt; Color ansiToUbuntu ansiColor = case ansiColor of AnsiColor brightness color -&gt; case brightness of Dark -&gt; case color of Black -&gt; RGB 1 1 1 Red -&gt; RGB 22 56 43 Green -&gt; RGB 57 181 74 Yellow -&gt; RGB 255 199 6 Blue -&gt; RGB 0 111 184 Magenta -&gt; RGB 118 38 113 Cyan -&gt; RGB 44 181 233 White -&gt; RGB 204 204 204 Bright -&gt; case color of Black -&gt; RGB 128 128 128 Red -&gt; RGB 255 0 0 Green -&gt; RGB 0 255 0 Yellow -&gt; RGB 255 255 0 Blue -&gt; RGB 0 0 255 Magenta -&gt; RGB 255 0 255 Cyan -&gt; RGB 0 255 255 White -&gt; RGB 255 255 255 위 코드처럼 패턴 매칭은 한 없이 깊어질 수 있기에, 하나의 case 표현식을 사용해 모든 경우를 매칭할 수도 있습니다. ansiToUbuntu :: AnsiColor -&gt; Color ansiToUbuntu ansiColor = case ansiColor of AnsiColor Dark Black -&gt; RGB 1 1 1 AnsiColor Dark Red -&gt; RGB 22 56 43 AnsiColor Dark Green -&gt; RGB 57 181 74 AnsiColor Dark Yellow -&gt; RGB 255 199 6 AnsiColor Dark Blue -&gt; RGB 0 111 184 AnsiColor Dark Magenta -&gt; RGB 118 38 113 AnsiColor Dark Cyan -&gt; RGB 44 181 233 AnsiColor Dark White -&gt; RGB 204 204 204 AnsiColor Bright Black -&gt; RGB 128 128 128 AnsiColor Bright Red -&gt; RGB 255 0 0 AnsiColor Bright Green -&gt; RGB 0 255 0 AnsiColor Bright Yellow -&gt; RGB 255 255 0 AnsiColor Bright Blue -&gt; RGB 0 0 255 AnsiColor Bright Magenta -&gt; RGB 255 0 255 AnsiColor Bright Cyan -&gt; RGB 0 255 255 AnsiColor Bright White -&gt; RGB 255 255 255 하지만 이 방식은 AnsiColor, Dark 그리고 Bright가 많이 반복되는 단점이 있습니다. 연습문제 (3) isEmpty :: [a] -&gt; Bool isEmpty list = case listToMaybe list of Nothing -&gt; True Just _ -&gt; False  연습문제 (4) isEmpty :: [a] -&gt; Bool isEmpty list = case list of [] -&gt; True _ : _ -&gt; False   ","version":"Next","tagName":"h3"},{"title":"풍부한 문맥을 통해 파싱하기​","type":1,"pageTitle":"마크업 파싱하기 02 (패턴 매칭)","url":"/learn-haskell-blog-generator/markup/parsing-02#풍부한-문맥을-통해-파싱하기","content":"이전에는 문서를 여러 문단으로 분리하는 파서를 작성했습니다. 새로운 기능을 추가하여 이제는 우리가 어떤 문맥(context)에 있는지(텍스트 단락, 목록, 또는 코드 블록) 정확히 기억하고 그에 따라 작동할 수 있습니다! 이전에 작성한 파싱 코드를 다시 살펴보겠습니다: parse :: String -&gt; Document parse = parseLines [] . lines parseLines :: [String] -&gt; [String] -&gt; Document parseLines currentParagraph txts = let paragraph = Paragraph (unlines (reverse currentParagraph)) in case txts of [] -&gt; [paragraph] currentLine : rest -&gt; if trim currentLine == &quot;&quot; then paragraph : parseLines [] rest else parseLines (currentLine : currentParagraph) rest trim :: String -&gt; String trim = unwords . words  위 코드에서 currentParagraph이 문맥을 의미하며, 인접한 줄들을 그룹으로 묶는 역할을 합니다. 이번에는 인접한 줄을 [String]이 아닌 문맥을 나타내는 Structure 타입으로 표현해보겠습니다. 하지만 Structure 타입으로 문맥을 표현할 때의 문제점 중 하나는, 파싱을 시작할 때는 어떤 문맥도 가지고 있지 않다는 것입니다. 그러나 Maybe를 사용하여 값이 없음을 나타내는 방법을 배웠습니다! 그래서 우리의 새로운 문맥 유형은 Maybe Structure 이 될 수 있습니다. 위 코드를 새로운 문맥 타입으로 수정해보겠습니다: parse :: String -&gt; Document parse = parseLines Nothing . lines -- (1) parseLines :: Maybe Structure -&gt; [String] -&gt; Document parseLines context txts = case txts of [] -&gt; maybeToList context -- (2) -- 문단인 경우 currentLine : rest -&gt; let line = trim currentLine in if line == &quot;&quot; then maybe id (:) context (parseLines Nothing rest) -- (3) else case context of Just (Paragraph paragraph) -&gt; parseLines (Just (Paragraph (unwords [paragraph, line]))) rest -- (4) _ -&gt; maybe id (:) context (parseLines (Just (Paragraph line)) rest) trim :: String -&gt; String trim = unwords . words  아직 문맥이 없으므로 Nothing을 사용합니다. maybeToList가 무엇인지 모르겠다면 Hoogle을 사용해보세요! 이 줄을 두 가지 중요한 부분으로 나눌 수 있습니다: maybe id (:) context - 문맥을 문서의 나머지 부분에 앞에 붙입니다.parseLines Nothing rest - 문서의 나머지 부분을 파싱합니다. 먼저 첫 번째 부분을 살펴보겠습니다. 우리는 context를 문서의 나머지 요소 앞에 붙이고 싶지만, context가 Maybe Structure 타입을 가지고 있기 때문에 context : parseLines Nothing rest와 같이 작성할 수 없습니다. 또한 Structure 타입이 아니기 때문에 context가 Structure를 가지고 있을 수도 있고, 그렇지 않을 수도 있습니다. 만약 Structure를 가지고 있다면 그것을 앞에 붙여야 하고, 그렇지 않다면 parseLines Nothing rest의 결과를 그대로 반환해야 합니다. 이를 패턴 매칭을 사용해 작성해보세요! 정답 case context of Nothing -&gt; parseLines Nothing rest Just structure -&gt; structure : parseLines Nothing rest maybe 함수를 사용하면 위 작업을 더 간결하게 할 수 있습니다. 이 함수는 Maybe에 대해 패턴 매칭을 하는 것과 비슷하게 작동합니다:maybe의 세 번째 인자는 패턴 매칭할 값이고, 두 번째 인자는 Just인 경우에 적용할 함수이며, 첫 번째 인자는 패턴 매칭한 결과가 Nothing인 경우 반환할 값입니다.maybe id (:) context (parseLines Nothing rest)를 패턴 매칭을 사용한 코드로 바꿔보세요! 정답 ( case context of Nothing -&gt; id Just structure -&gt; (:) structure ) (parseLines Nothing rest) case 표현식의 결과가 타입이 Document -&gt; Document인 함수라는 것에 주목하세요.(:)에 structure을 부분적으로 적용하여 structure을 앞에 붙이는 함수를 만들고,parseLines Nothing rest를 case 표현식에 적용하는 방식을 살펴보세요. 함수를 사용하여 패턴 매칭을 인코딩하는 이러한 방식은 자주 사용됩니다. id, (:) 그리고 maybe id (:)의 타입을 GHCi에서 확인해보세요! 앗! 전에 (unwords 함수가 하는) String이나 리스트 뒤에 요소를 추가하는 것은 느리다고 하지 않았나요? 맞습니다! 하지만 우리의 Structure 타입에서는 문단이 Paragraph String으로 정의되어 있고,Paragraph [String]이 아니기 때문에 리스트를 뒤집는 방법을 사용할 수 없습니다. 그럼 어떻게 해야 할까요? 이를 처리하는 방법에는 여러 가지가 있지만, 한 가지 간단한 방법은 올바른 모양으로 다른 타입을 만드는 것입니다: data Context = CtxHeading Natural String | CtxParagraph [String] | CtxUnorderedList [String] | CtxOrderedList [String] | CtxCodeBlock [String] 하스켈에서 새로운 타입을 만드는 것은 비용이 저렴하기에, 이 방법은 매우 유용합니다. 하지만 이번에는 위와 같은 방법을 사용하지 않겠습니다. 왜냐하면 나중에 필요한 경우 쉽게 수정할 수 있는 로컬 코드 조각이기 때문입니다. 다음 파싱 단계로 넘어가 이번에는 제목과 리스트를 처리해보겠습니다. 줄의 첫 번째 문자를 검사하여 이를 처리할 수 있습니다: parse :: String -&gt; Document parse = parseLines Nothing . lines parseLines :: Maybe Structure -&gt; [String] -&gt; Document parseLines context txts = case txts of -- 종료 조건 [] -&gt; maybeToList context -- 제목 1 인 경우 ('*' : ' ' : line) : rest -&gt; maybe id (:) context (Heading 1 (trim line) : parseLines Nothing rest) -- 순서 없는 목록인 경우 ('-' : ' ' : line) : rest -&gt; case context of Just (UnorderedList list) -&gt; parseLines (Just (UnorderedList (list &lt;&gt; [trim line]))) rest _ -&gt; maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest) -- 문단인 경우 currentLine : rest -&gt; let line = trim currentLine in if line == &quot;&quot; then maybe id (:) context (parseLines Nothing rest) else case context of Just (Paragraph paragraph) -&gt; parseLines (Just (Paragraph (unwords [paragraph, line]))) rest _ -&gt; maybe id (:) context (parseLines (Just (Paragraph line)) rest) trim :: String -&gt; String trim = unwords . words   연습문제: 코드 블록과 순서 있는 목록의 경우도 처리해보세요! 정답 Markup.hs module Markup ( Document , Structure(..) , parse ) where import Numeric.Natural import Data.Maybe (maybeToList) type Document = [Structure] data Structure = Heading Natural String | Paragraph String | UnorderedList [String] | OrderedList [String] | CodeBlock [String] deriving (Eq, Show) -- (1) parse :: String -&gt; Document parse = parseLines Nothing . lines parseLines :: Maybe Structure -&gt; [String] -&gt; Document parseLines context txts = case txts of -- done case [] -&gt; maybeToList context -- Heading 1 case ('*' : ' ' : line) : rest -&gt; maybe id (:) context (Heading 1 (trim line) : parseLines Nothing rest) -- Unordered list case ('-' : ' ' : line) : rest -&gt; case context of Just (UnorderedList list) -&gt; parseLines (Just (UnorderedList (list &lt;&gt; [trim line]))) rest _ -&gt; maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest) -- Ordered list case ('#' : ' ' : line) : rest -&gt; case context of Just (OrderedList list) -&gt; parseLines (Just (OrderedList (list &lt;&gt; [trim line]))) rest _ -&gt; maybe id (:) context (parseLines (Just (OrderedList [trim line])) rest) -- Code block case ('&gt;' : ' ' : line) : rest -&gt; case context of Just (CodeBlock code) -&gt; parseLines (Just (CodeBlock (code &lt;&gt; [line]))) rest _ -&gt; maybe id (:) context (parseLines (Just (CodeBlock [line])) rest) -- Paragraph case currentLine : rest -&gt; let line = trim currentLine in if line == &quot;&quot; then maybe id (:) context (parseLines Nothing rest) else case context of Just (Paragraph paragraph) -&gt; parseLines (Just (Paragraph (unwords [paragraph, line]))) rest _ -&gt; maybe id (:) context (parseLines (Just (Paragraph line)) rest) trim :: String -&gt; String trim = unwords . words   ","version":"Next","tagName":"h2"},{"title":"우리의 파서가 제대로 동작하는지 어떻게 알 수 있을까요?​","type":1,"pageTitle":"마크업 파싱하기 02 (패턴 매칭)","url":"/learn-haskell-blog-generator/markup/parsing-02#우리의-파서가-제대로-동작하는지-어떻게-알-수-있을까요","content":"이전 장에서, 우리는 몇 가지 마크업 언어 예제를 직접 파싱해봤습니다. (관련 연습문제)Structure 데이터 타입의 Eq 인스턴스를 만들었으므로 (위 정답에서 (1) 표시된 부분) 이제 == 연산자를 사용하여 두 결과가 같은지 비교할 수 있습니다. GHCi를 사용해 확인해보세요! 다음과 같은 문법을 사용하여 텍스트 파일을 읽을 수 있습니다: ghci&gt; txt &lt;- readFile &quot;/tmp/sample.txt&quot;  그리고 이전 손으로 작성한 답안과 이번에 작성한 정답과 비교해보세요 (모듈에 추가하고 GHCi에서 불러온 후 수행하세요): ghci&gt; parse txt == example4  이후 장에서, 테스트 프레임워크를 사용하여 자동화된 테스트를 작성할 것입니다. 하지만 그 전에, 다음과 같은 작업들을 하나로 묶는 작업을 진행하고자 합니다. 파일에서 마크업 텍스트 읽기텍스트 파싱하기HTML EDSL로 변환하기HTML 코드 생성하기 또한 하스켈에서 IO 를 어떻게 다루는지도 함께 살펴보겠습니다. Git 커밋을 통해이번에 수정한 내역과 현재까지 코드 를 확인할 수 있습니다. ","version":"Next","tagName":"h3"},{"title":"테스트","type":0,"sectionRef":"#","url":"/learn-haskell-blog-generator/testing","content":"","keywords":"","version":"Next"},{"title":"초기 설정​","type":1,"pageTitle":"테스트","url":"/learn-haskell-blog-generator/testing#초기-설정","content":"","version":"Next","tagName":"h2"},{"title":"Cabal 파일 수정​","type":1,"pageTitle":"테스트","url":"/learn-haskell-blog-generator/testing#cabal-파일-수정","content":"새로운 테스트 스위트를 정의하기 위해 hs-blog-gen.cabal 파일에 새로운 섹션을 정의할 것입니다.test-suite라는 섹션이며, library와 executable 섹션과 매우 유사합니다. Cabal 문서에 테스트 스위트를 정의하는 방법에 대한 설명이 있습니다. 우리는 exitcode-stdio-1.0 인터페이스를 사용할 것입니다. 다양한 설정과 옵션을 살펴보겠습니다. test-suite hs-blog-gen-test import: common-settings type: exitcode-stdio-1.0 hs-source-dirs: test main-is: Spec.hs -- other-modules: build-depends: base , hspec , hspec-discover , raw-strings-qq , hs-blog ghc-options: -O -threaded -rtsopts -with-rtsopts=-N build-tool-depends: hspec-discover:hspec-discover  hs-source-dirs: test - 테스트 스위트의 소스 파일 디렉토리main-is: Spec.hs - 테스트 스위트의 진입점other-modules - 테스트 스위트의 모듈정의, 현재는 존재하지 않아서 주석처리 하였습니다build-depends - 사용할 패키지: base - 하스켈 표준 라이브러리, 이전에 사용했던 것과 같습니다hspec - 이번에 사용할 테스트 프레임워크hspec-discover - 자동으로 Hspec 테스트를 찾아줍니다raw-strings-qq - 문자열 리터럴을 작성하기 위한 추가적인 문법을 제공합니다hs-blog - 우리가 작성한 라이브러리 ghc-options - GHC의 추가 옵션과 플래그: -O - 최적화 옵션을 사용하여 컴파일합니다-threaded - 단일 코어 런타임 대신 멀티 코어 런타임을 사용합니다. 경험상 멀티 코어 런타임이 약간 느리지만, 실제로 여러 코어를 사용하는 코드(예를 들어 테스트 프레임워크에서 테스트를 병렬로 실행하는 경우)를 작성할 때는 성능 향상을 얻을 수 있습니다.-rtsopts - 애플리케이션에 명령행 인수를 전달하여 하스켈 런타임 시스템을 구성할 수 있습니다.-with-rtsopts=-N - 링크 시간에 프로그램에 대한 특정 기본 옵션을 설정합니다. 특히, -N옵션은 프로그램에서 사용할 코어의 수를 설정합니다. build-tool-depends - 패키지 빌드를 위한 특별한 실행파일을 지정합니다. 예제에서는 hspec-discover 패키지에 포함된 hspec-discover 실행파일을 사용합니다. 이 실행파일은 테스트 소스 디렉토리를 검사하여 모든 Spec 파일을 찾고, 찾은 테스트를 실행하는 프로그램의 진입점을 생성합니다. ","version":"Next","tagName":"h3"},{"title":"Hspec 탐색​","type":1,"pageTitle":"테스트","url":"/learn-haskell-blog-generator/testing#hspec-탐색","content":"hspec-discover가 작동하려면, 테스트 스위트의 &quot;main&quot; 파일에 다음을 추가해야 합니다. 우리의 경우 test/Spec.hs입니다: {-# OPTIONS_GHC -F -pgmF hspec-discover #-}  이제 hspec-discover가 자동으로 main을 정의할 것입니다.stack test 또는 cabal test (선택한 항목에 따라)를 사용하여 테스트를 실행할 수 있습니다. 아직 테스트를 정의하지 않았으므로 출력은 다음과 같습니다: Finished in 0.0000 seconds 0 examples, 0 failures  새로운 Hspec 테스트를 추가할 때마다 hspec-discover가 자동으로 찾아서 실행할 것입니다. (물론 cabal 파일의 other-modules 섹션에 추가해야 합니다). hspec-discover가 모듈을 테스트 모듈로 인식하려면, 다음 규칙을 따라야 합니다: 모듈 이름은 Spec로 끝나야 합니다.(테스트 의미하는) spec :: Spec이라는 값을 정의해야 합니다. 그리고 모듈 외부로 내보내야 합니다. (예를 들어, 모듈의 내보내기 목록에 추가해야 합니다) ","version":"Next","tagName":"h3"},{"title":"테스트 작성하기​","type":1,"pageTitle":"테스트","url":"/learn-haskell-blog-generator/testing#테스트-작성하기","content":"첫 번째 테스트를 작성해 보겠습니다. 마크업 파싱을 테스트하는 모듈을 작성해봅시다.MarkupParsing.hs라는 새로운 파일을 생성하고, 다음과 같은 모듈을 가져옵니다: module MarkupParsingSpec where import Test.Hspec import HsBlog.Markup  Hspec은 테스트 사양(Spec)을 기술하고, 조합하고, 중첩하는 monadic 인터페이스를 제공합니다. describe 함수를 사용하여 테스트 그룹을 기술할 수 있습니다. 또한 it 함수를 사용하여 새로운 테스트를 추가할 수 있습니다.shouldBe와 같은 함수를 사용하여 두 값을 비교하고, Eq 인스턴스를 사용하여 두 값이 동일한지 확인할 수 있습니다. 만약 동일하다면 테스트는 통과하고, 그렇지 않다면 테스트는 실패하고 에러 메시지를 출력합니다. 무조건 실패하는 테스트를 먼저 작성해보겠습니다! spec :: Spec spec = do describe &quot;Markup parsing tests&quot; $ do it &quot;empty&quot; $ shouldBe (parse &quot;&quot;) [Heading 1 &quot;bug&quot;]  cabal 파일의 other-modules 목록에 이 모듈을 추가한 후  other-modules: MarkupParsingSpec  테스트를 실행하면 다음과 같은 결과를 얻을 수 있습니다: MarkupParsing Markup parsing tests empty FAILED [1] Failures: test/MarkupParsingSpec.hs:10:7: 1) MarkupParsing, Markup parsing tests, empty expected: [Heading 1 &quot;bug&quot;] but got: [] To rerun use: --match &quot;/MarkupParsing/Markup parsing tests/empty/&quot; Randomized with seed 763489823 Finished in 0.0004 seconds 1 example, 1 failure  계층 트리(모듈, 그룹, 테스트) 형태로 실행되는 테스트 결과가 출력됩니다. 이를 통해 어떤 테스트가 실행되었고, 테스트가 통과했는지 실패했는지, 실패했다면 어떤 출력과 기대 출력이 있는지 알 수 있습니다. 테스트를 통과하도록 수정해보겠습니다.  shouldBe (parse &quot;&quot;) []  이제 테스트가 통과하고 다음과 같은 결과를 얻을 수 있습니다: MarkupParsing Markup parsing tests empty Finished in 0.0001 seconds 1 example, 0 failures  몇 가지 테스트를 더 추가해보겠습니다:  it &quot;paragraph&quot; $ shouldBe (parse &quot;hello world&quot;) [Paragraph &quot;hello world&quot;] it &quot;heading 1&quot; $ shouldBe (parse &quot;* Heading 1&quot;) [Heading 1 &quot;Heading 1&quot;] it &quot;code&quot; $ shouldBe (parse &quot;&gt; main = putStrLn \\&quot;hello world!\\&quot;&quot;) [CodeBlock [&quot;main = putStrLn \\&quot;hello world!\\&quot;&quot;]]  이후 테스트를 실행하면 다음과 같은 결과를 얻을 수 있습니다: MarkupParsing Markup parsing tests Test empty paragraph heading 1 code Finished in 0.0003 seconds 4 examples, 0 failures  지금까지 Hspec을 사용하여 테스트를 작성하는 방법을 살펴보았습니다.describe를 사용하여 Spec을 중첩한 트리구조를 만들 수 있다는 점이 중요합니다. 물론 테스트를 다른 함수와 모듈로 이동시켜서 테스트 스위트를 더 잘 구성할 수도 있습니다. 예들 들어, 다음과 같이 테스트를 작성할 수 있습니다: spec :: Spec spec = do describe &quot;Markup parsing tests&quot; $ do simple simple :: Spec simple = do describe &quot;simple&quot; $ do it &quot;empty&quot; $ shouldBe (parse &quot;&quot;) [] it &quot;paragraph&quot; $ shouldBe (parse &quot;hello world&quot;) [Paragraph &quot;hello world&quot;] it &quot;heading 1&quot; $ shouldBe (parse &quot;* Heading 1&quot;) [Heading 1 &quot;Heading 1&quot;] it &quot;code&quot; $ shouldBe (parse &quot;&gt; main = putStrLn \\&quot;hello world!\\&quot;&quot;) [CodeBlock [&quot;main = putStrLn \\&quot;hello world!\\&quot;&quot;]]  또한 테스트에서 사용할 수 있는, shouldBe와 비슷한 다른 &quot;검증문(expectations)&quot;도 있습니다.Hspec 튜토리얼또는haddock 문서에서 그 목록을 확인할 수 있습니다. ","version":"Next","tagName":"h2"},{"title":"Raw 문자열​","type":1,"pageTitle":"테스트","url":"/learn-haskell-blog-generator/testing#raw-문자열","content":"다중 라인 문자열을 작성하거나, &quot;code&quot; 테스트 케이스에서 했던 것처럼 문자열을 이스케이프 하지 않으려면raw-strings-qq라이브러리를 사용할 수 있습니다. 이 라이브러리는QuasiQuotes언어 확장을 사용합니다.QuasiQuotes는 하스켈의 문법을 확장하는 메타 프로그래밍 확장입니다. quasi-quote는 [quoter| string |] 형태를 가지며, 여기서 quoter는 우리가 사용하고자 하는 문법을 제공하는 함수의 이름이고, string은 입력입니다. 예를 들어raw-strings-qq에 정의된 quoter r을 사용하여 다중 라인과 이스케이프되지 않은 문자열을 작성할 수 있습니다! 이를 활용해 이전에 작성한 코드에 대한 테스트를 작성해보겠습니다. {-# language QuasiQuotes #-} ... import Text.RawString.QQ ... example3 :: String example3 = [r| Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate. # Item 1 of a list # Item 2 of the same list |]  이제 다중 라인 테스트를 추가합니다: spec :: Spec spec = do describe &quot;Markup parsing tests&quot; $ do simple multiline multiline :: Spec multiline = do describe &quot;Multi-line tests&quot; $ do it &quot;example3&quot; $ shouldBe (parse example3) example3Result example3 :: String example3 = [r| Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate. # Item 1 of a list # Item 2 of the same list |] example3Result :: Document example3Result = [ Paragraph &quot;Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate.&quot; , OrderedList [ &quot;Item 1 of a list&quot; , &quot;Item 2 of the same list&quot; ] ]  테스트를 실행하면 다음과 같은 결과를 얻을 수 있습니다: MarkupParsing Markup parsing tests simple Test empty paragraph heading 1 code Multi-line tests example3 Finished in 0.0004 seconds 5 examples, 0 failures   연습문제: 이전 연습문제의 네 번째 예제에 대한 테스트를 추가하세요. 정답 multiline :: Spec multiline = do describe &quot;Multi-line tests&quot; $ do it &quot;example3&quot; $ shouldBe (parse example3) example3Result it &quot;example4&quot; $ shouldBe (parse example4) example4Result example4 :: String example4 = [r| * Compiling programs with ghc Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries. Create a new Haskell source file named hello.hs, and write the following code in it: &gt; main = putStrLn &quot;Hello, Haskell!&quot; Now, we can compile the program by invoking ghc with the file name: &gt; ➜ ghc hello.hs &gt; [1 of 1] Compiling Main ( hello.hs, hello.o ) &gt; Linking hello ... GHC created the following files: - hello.hi - Haskell interface file - hello.o - Object file, the output of the compiler before linking - hello (or hello.exe on Microsoft Windows) - A native runnable executable. GHC will produce an executable when the source file satisfies both conditions: # Defines the main function in the source file # Defines the module name to be Main, or does not have a module declaration Otherwise, it will only produce the .o and .hi files. |] example4Result :: Document example4Result = [ Heading 1 &quot;Compiling programs with ghc&quot; , Paragraph &quot;Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries.&quot; , Paragraph &quot;Create a new Haskell source file named hello.hs, and write the following code in it:&quot; , CodeBlock [ &quot;main = putStrLn \\&quot;Hello, Haskell!\\&quot;&quot; ] , Paragraph &quot;Now, we can compile the program by invoking ghc with the file name:&quot; , CodeBlock [ &quot;➜ ghc hello.hs&quot; , &quot;[1 of 1] Compiling Main ( hello.hs, hello.o )&quot; , &quot;Linking hello ...&quot; ] , Paragraph &quot;GHC created the following files:&quot; , UnorderedList [ &quot;hello.hi - Haskell interface file&quot; , &quot;hello.o - Object file, the output of the compiler before linking&quot; , &quot;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&quot; ] , Paragraph &quot;GHC will produce an executable when the source file satisfies both conditions:&quot; , OrderedList [ &quot;Defines the main function in the source file&quot; , &quot;Defines the module name to be Main, or does not have a module declaration&quot; ] , Paragraph &quot;Otherwise, it will only produce the .o and .hi files.&quot; ]   ","version":"Next","tagName":"h3"},{"title":"병렬 테스트 실행​","type":1,"pageTitle":"테스트","url":"/learn-haskell-blog-generator/testing#병렬-테스트-실행","content":"특별한 설정을 하지 않았다면, Hspec은 모든 테스트를 메인 스레드에서 순차적으로 실행합니다. 테스트를 병렬로 실행할 수 있는 몇 가지 방법이 있습니다. 하나는 Spec을 직접 parallel 함수에 전달하여 병렬로 실행하도록 표시하는 것이고, 다른 하나는 hspec-discover를 사용하여 자동으로 parallel을 적용하는 /hook/ 을 생성하는 것입니다. Hspec 문서를 참고하여 두 가지 방법을 모두 시도해보세요. 우리는 이미 cabal 파일에서 스레드 기반 런타임을 활성화하고 멀티 코어를 사용하도록 설정했습니다. ","version":"Next","tagName":"h2"},{"title":"요약​","type":1,"pageTitle":"테스트","url":"/learn-haskell-blog-generator/testing#요약","content":"이번 장에서 소개한 테스트 방법에 대한 내용은 빙산의 일각에 불과합니다.속성 테스트 또는골든 테스트에 대해서는 언급조차 하지 않았습니다. 또한 예외 테스트, IO 코드 테스트, 테스트 분석, 벤치마크 등등에 대해서도 다루지 않았습니다. 이를 다루기에는 너무 방대한 주제이기 때문입니다! 이번 장을 통해 프로젝트에 테스트 작성을 시작하기 위한 기본적인 내용을 전달하고자 했습니다. 선택한 테스트 프레임워크의 튜토리얼을 참고하고, 직접 테스트에 대한 추가적인 문서를 읽어보세요. Git 커밋을 통해이번에 수정한 내역과 현재까지 코드 를 확인할 수 있습니다. ","version":"Next","tagName":"h2"}]